
RTOS_BLINK_LED.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003108  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000014  00800060  00003108  0000319c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000038b  00800074  00800074  000031b0  2**0
                  ALLOC
  3 .stab         00004914  00000000  00000000  000031b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002b0b  00000000  00000000  00007ac4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 a7 0b 	jmp	0x174e	; 0x174e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e0       	ldi	r30, 0x08	; 8
      68:	f1 e3       	ldi	r31, 0x31	; 49
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 37       	cpi	r26, 0x74	; 116
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a4 e7       	ldi	r26, 0x74	; 116
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 3f       	cpi	r26, 0xFF	; 255
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 74 08 	call	0x10e8	; 0x10e8 <main>
      8a:	0c 94 82 18 	jmp	0x3104	; 0x3104 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Dio_vidSetPinValue>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <Dio_vidSetPinValue+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <Dio_vidSetPinValue+0x8>
      9a:	0f 92       	push	r0
      9c:	cd b7       	in	r28, 0x3d	; 61
      9e:	de b7       	in	r29, 0x3e	; 62
      a0:	89 83       	std	Y+1, r24	; 0x01
      a2:	6a 83       	std	Y+2, r22	; 0x02
      a4:	4b 83       	std	Y+3, r20	; 0x03
      a6:	89 81       	ldd	r24, Y+1	; 0x01
      a8:	28 2f       	mov	r18, r24
      aa:	30 e0       	ldi	r19, 0x00	; 0
      ac:	3d 83       	std	Y+5, r19	; 0x05
      ae:	2c 83       	std	Y+4, r18	; 0x04
      b0:	8c 81       	ldd	r24, Y+4	; 0x04
      b2:	9d 81       	ldd	r25, Y+5	; 0x05
      b4:	81 30       	cpi	r24, 0x01	; 1
      b6:	91 05       	cpc	r25, r1
      b8:	09 f4       	brne	.+2      	; 0xbc <Dio_vidSetPinValue+0x2a>
      ba:	47 c0       	rjmp	.+142    	; 0x14a <Dio_vidSetPinValue+0xb8>
      bc:	2c 81       	ldd	r18, Y+4	; 0x04
      be:	3d 81       	ldd	r19, Y+5	; 0x05
      c0:	22 30       	cpi	r18, 0x02	; 2
      c2:	31 05       	cpc	r19, r1
      c4:	2c f4       	brge	.+10     	; 0xd0 <Dio_vidSetPinValue+0x3e>
      c6:	8c 81       	ldd	r24, Y+4	; 0x04
      c8:	9d 81       	ldd	r25, Y+5	; 0x05
      ca:	00 97       	sbiw	r24, 0x00	; 0
      cc:	71 f0       	breq	.+28     	; 0xea <Dio_vidSetPinValue+0x58>
      ce:	cb c0       	rjmp	.+406    	; 0x266 <Dio_vidSetPinValue+0x1d4>
      d0:	2c 81       	ldd	r18, Y+4	; 0x04
      d2:	3d 81       	ldd	r19, Y+5	; 0x05
      d4:	22 30       	cpi	r18, 0x02	; 2
      d6:	31 05       	cpc	r19, r1
      d8:	09 f4       	brne	.+2      	; 0xdc <Dio_vidSetPinValue+0x4a>
      da:	67 c0       	rjmp	.+206    	; 0x1aa <Dio_vidSetPinValue+0x118>
      dc:	8c 81       	ldd	r24, Y+4	; 0x04
      de:	9d 81       	ldd	r25, Y+5	; 0x05
      e0:	83 30       	cpi	r24, 0x03	; 3
      e2:	91 05       	cpc	r25, r1
      e4:	09 f4       	brne	.+2      	; 0xe8 <Dio_vidSetPinValue+0x56>
      e6:	91 c0       	rjmp	.+290    	; 0x20a <Dio_vidSetPinValue+0x178>
      e8:	be c0       	rjmp	.+380    	; 0x266 <Dio_vidSetPinValue+0x1d4>
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	81 30       	cpi	r24, 0x01	; 1
      ee:	a1 f4       	brne	.+40     	; 0x118 <Dio_vidSetPinValue+0x86>
      f0:	ab e3       	ldi	r26, 0x3B	; 59
      f2:	b0 e0       	ldi	r27, 0x00	; 0
      f4:	eb e3       	ldi	r30, 0x3B	; 59
      f6:	f0 e0       	ldi	r31, 0x00	; 0
      f8:	80 81       	ld	r24, Z
      fa:	48 2f       	mov	r20, r24
      fc:	8a 81       	ldd	r24, Y+2	; 0x02
      fe:	28 2f       	mov	r18, r24
     100:	30 e0       	ldi	r19, 0x00	; 0
     102:	81 e0       	ldi	r24, 0x01	; 1
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	02 2e       	mov	r0, r18
     108:	02 c0       	rjmp	.+4      	; 0x10e <Dio_vidSetPinValue+0x7c>
     10a:	88 0f       	add	r24, r24
     10c:	99 1f       	adc	r25, r25
     10e:	0a 94       	dec	r0
     110:	e2 f7       	brpl	.-8      	; 0x10a <Dio_vidSetPinValue+0x78>
     112:	84 2b       	or	r24, r20
     114:	8c 93       	st	X, r24
     116:	a7 c0       	rjmp	.+334    	; 0x266 <Dio_vidSetPinValue+0x1d4>
     118:	8b 81       	ldd	r24, Y+3	; 0x03
     11a:	88 23       	and	r24, r24
     11c:	09 f0       	breq	.+2      	; 0x120 <Dio_vidSetPinValue+0x8e>
     11e:	a3 c0       	rjmp	.+326    	; 0x266 <Dio_vidSetPinValue+0x1d4>
     120:	ab e3       	ldi	r26, 0x3B	; 59
     122:	b0 e0       	ldi	r27, 0x00	; 0
     124:	eb e3       	ldi	r30, 0x3B	; 59
     126:	f0 e0       	ldi	r31, 0x00	; 0
     128:	80 81       	ld	r24, Z
     12a:	48 2f       	mov	r20, r24
     12c:	8a 81       	ldd	r24, Y+2	; 0x02
     12e:	28 2f       	mov	r18, r24
     130:	30 e0       	ldi	r19, 0x00	; 0
     132:	81 e0       	ldi	r24, 0x01	; 1
     134:	90 e0       	ldi	r25, 0x00	; 0
     136:	02 2e       	mov	r0, r18
     138:	02 c0       	rjmp	.+4      	; 0x13e <Dio_vidSetPinValue+0xac>
     13a:	88 0f       	add	r24, r24
     13c:	99 1f       	adc	r25, r25
     13e:	0a 94       	dec	r0
     140:	e2 f7       	brpl	.-8      	; 0x13a <Dio_vidSetPinValue+0xa8>
     142:	80 95       	com	r24
     144:	84 23       	and	r24, r20
     146:	8c 93       	st	X, r24
     148:	8e c0       	rjmp	.+284    	; 0x266 <Dio_vidSetPinValue+0x1d4>
     14a:	8b 81       	ldd	r24, Y+3	; 0x03
     14c:	81 30       	cpi	r24, 0x01	; 1
     14e:	a1 f4       	brne	.+40     	; 0x178 <Dio_vidSetPinValue+0xe6>
     150:	a8 e3       	ldi	r26, 0x38	; 56
     152:	b0 e0       	ldi	r27, 0x00	; 0
     154:	e8 e3       	ldi	r30, 0x38	; 56
     156:	f0 e0       	ldi	r31, 0x00	; 0
     158:	80 81       	ld	r24, Z
     15a:	48 2f       	mov	r20, r24
     15c:	8a 81       	ldd	r24, Y+2	; 0x02
     15e:	28 2f       	mov	r18, r24
     160:	30 e0       	ldi	r19, 0x00	; 0
     162:	81 e0       	ldi	r24, 0x01	; 1
     164:	90 e0       	ldi	r25, 0x00	; 0
     166:	02 2e       	mov	r0, r18
     168:	02 c0       	rjmp	.+4      	; 0x16e <Dio_vidSetPinValue+0xdc>
     16a:	88 0f       	add	r24, r24
     16c:	99 1f       	adc	r25, r25
     16e:	0a 94       	dec	r0
     170:	e2 f7       	brpl	.-8      	; 0x16a <Dio_vidSetPinValue+0xd8>
     172:	84 2b       	or	r24, r20
     174:	8c 93       	st	X, r24
     176:	77 c0       	rjmp	.+238    	; 0x266 <Dio_vidSetPinValue+0x1d4>
     178:	8b 81       	ldd	r24, Y+3	; 0x03
     17a:	88 23       	and	r24, r24
     17c:	09 f0       	breq	.+2      	; 0x180 <Dio_vidSetPinValue+0xee>
     17e:	73 c0       	rjmp	.+230    	; 0x266 <Dio_vidSetPinValue+0x1d4>
     180:	a8 e3       	ldi	r26, 0x38	; 56
     182:	b0 e0       	ldi	r27, 0x00	; 0
     184:	e8 e3       	ldi	r30, 0x38	; 56
     186:	f0 e0       	ldi	r31, 0x00	; 0
     188:	80 81       	ld	r24, Z
     18a:	48 2f       	mov	r20, r24
     18c:	8a 81       	ldd	r24, Y+2	; 0x02
     18e:	28 2f       	mov	r18, r24
     190:	30 e0       	ldi	r19, 0x00	; 0
     192:	81 e0       	ldi	r24, 0x01	; 1
     194:	90 e0       	ldi	r25, 0x00	; 0
     196:	02 2e       	mov	r0, r18
     198:	02 c0       	rjmp	.+4      	; 0x19e <Dio_vidSetPinValue+0x10c>
     19a:	88 0f       	add	r24, r24
     19c:	99 1f       	adc	r25, r25
     19e:	0a 94       	dec	r0
     1a0:	e2 f7       	brpl	.-8      	; 0x19a <Dio_vidSetPinValue+0x108>
     1a2:	80 95       	com	r24
     1a4:	84 23       	and	r24, r20
     1a6:	8c 93       	st	X, r24
     1a8:	5e c0       	rjmp	.+188    	; 0x266 <Dio_vidSetPinValue+0x1d4>
     1aa:	8b 81       	ldd	r24, Y+3	; 0x03
     1ac:	81 30       	cpi	r24, 0x01	; 1
     1ae:	a1 f4       	brne	.+40     	; 0x1d8 <Dio_vidSetPinValue+0x146>
     1b0:	a5 e3       	ldi	r26, 0x35	; 53
     1b2:	b0 e0       	ldi	r27, 0x00	; 0
     1b4:	e5 e3       	ldi	r30, 0x35	; 53
     1b6:	f0 e0       	ldi	r31, 0x00	; 0
     1b8:	80 81       	ld	r24, Z
     1ba:	48 2f       	mov	r20, r24
     1bc:	8a 81       	ldd	r24, Y+2	; 0x02
     1be:	28 2f       	mov	r18, r24
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	81 e0       	ldi	r24, 0x01	; 1
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	02 2e       	mov	r0, r18
     1c8:	02 c0       	rjmp	.+4      	; 0x1ce <Dio_vidSetPinValue+0x13c>
     1ca:	88 0f       	add	r24, r24
     1cc:	99 1f       	adc	r25, r25
     1ce:	0a 94       	dec	r0
     1d0:	e2 f7       	brpl	.-8      	; 0x1ca <Dio_vidSetPinValue+0x138>
     1d2:	84 2b       	or	r24, r20
     1d4:	8c 93       	st	X, r24
     1d6:	47 c0       	rjmp	.+142    	; 0x266 <Dio_vidSetPinValue+0x1d4>
     1d8:	8b 81       	ldd	r24, Y+3	; 0x03
     1da:	88 23       	and	r24, r24
     1dc:	09 f0       	breq	.+2      	; 0x1e0 <Dio_vidSetPinValue+0x14e>
     1de:	43 c0       	rjmp	.+134    	; 0x266 <Dio_vidSetPinValue+0x1d4>
     1e0:	a5 e3       	ldi	r26, 0x35	; 53
     1e2:	b0 e0       	ldi	r27, 0x00	; 0
     1e4:	e5 e3       	ldi	r30, 0x35	; 53
     1e6:	f0 e0       	ldi	r31, 0x00	; 0
     1e8:	80 81       	ld	r24, Z
     1ea:	48 2f       	mov	r20, r24
     1ec:	8a 81       	ldd	r24, Y+2	; 0x02
     1ee:	28 2f       	mov	r18, r24
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	81 e0       	ldi	r24, 0x01	; 1
     1f4:	90 e0       	ldi	r25, 0x00	; 0
     1f6:	02 2e       	mov	r0, r18
     1f8:	02 c0       	rjmp	.+4      	; 0x1fe <Dio_vidSetPinValue+0x16c>
     1fa:	88 0f       	add	r24, r24
     1fc:	99 1f       	adc	r25, r25
     1fe:	0a 94       	dec	r0
     200:	e2 f7       	brpl	.-8      	; 0x1fa <Dio_vidSetPinValue+0x168>
     202:	80 95       	com	r24
     204:	84 23       	and	r24, r20
     206:	8c 93       	st	X, r24
     208:	2e c0       	rjmp	.+92     	; 0x266 <Dio_vidSetPinValue+0x1d4>
     20a:	8b 81       	ldd	r24, Y+3	; 0x03
     20c:	81 30       	cpi	r24, 0x01	; 1
     20e:	a1 f4       	brne	.+40     	; 0x238 <Dio_vidSetPinValue+0x1a6>
     210:	a2 e3       	ldi	r26, 0x32	; 50
     212:	b0 e0       	ldi	r27, 0x00	; 0
     214:	e2 e3       	ldi	r30, 0x32	; 50
     216:	f0 e0       	ldi	r31, 0x00	; 0
     218:	80 81       	ld	r24, Z
     21a:	48 2f       	mov	r20, r24
     21c:	8a 81       	ldd	r24, Y+2	; 0x02
     21e:	28 2f       	mov	r18, r24
     220:	30 e0       	ldi	r19, 0x00	; 0
     222:	81 e0       	ldi	r24, 0x01	; 1
     224:	90 e0       	ldi	r25, 0x00	; 0
     226:	02 2e       	mov	r0, r18
     228:	02 c0       	rjmp	.+4      	; 0x22e <Dio_vidSetPinValue+0x19c>
     22a:	88 0f       	add	r24, r24
     22c:	99 1f       	adc	r25, r25
     22e:	0a 94       	dec	r0
     230:	e2 f7       	brpl	.-8      	; 0x22a <Dio_vidSetPinValue+0x198>
     232:	84 2b       	or	r24, r20
     234:	8c 93       	st	X, r24
     236:	17 c0       	rjmp	.+46     	; 0x266 <Dio_vidSetPinValue+0x1d4>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	88 23       	and	r24, r24
     23c:	a1 f4       	brne	.+40     	; 0x266 <Dio_vidSetPinValue+0x1d4>
     23e:	a2 e3       	ldi	r26, 0x32	; 50
     240:	b0 e0       	ldi	r27, 0x00	; 0
     242:	e2 e3       	ldi	r30, 0x32	; 50
     244:	f0 e0       	ldi	r31, 0x00	; 0
     246:	80 81       	ld	r24, Z
     248:	48 2f       	mov	r20, r24
     24a:	8a 81       	ldd	r24, Y+2	; 0x02
     24c:	28 2f       	mov	r18, r24
     24e:	30 e0       	ldi	r19, 0x00	; 0
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <Dio_vidSetPinValue+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <Dio_vidSetPinValue+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	0f 90       	pop	r0
     26c:	0f 90       	pop	r0
     26e:	0f 90       	pop	r0
     270:	cf 91       	pop	r28
     272:	df 91       	pop	r29
     274:	08 95       	ret

00000276 <Dio_u8GetPinValue>:
}



u8 Dio_u8GetPinValue(u8 u8PortNumberCpy,u8 u8PinNumbercpy)
{
     276:	df 93       	push	r29
     278:	cf 93       	push	r28
     27a:	00 d0       	rcall	.+0      	; 0x27c <Dio_u8GetPinValue+0x6>
     27c:	00 d0       	rcall	.+0      	; 0x27e <Dio_u8GetPinValue+0x8>
     27e:	0f 92       	push	r0
     280:	cd b7       	in	r28, 0x3d	; 61
     282:	de b7       	in	r29, 0x3e	; 62
     284:	89 83       	std	Y+1, r24	; 0x01
     286:	6a 83       	std	Y+2, r22	; 0x02
	switch(u8PortNumberCpy)
     288:	89 81       	ldd	r24, Y+1	; 0x01
     28a:	28 2f       	mov	r18, r24
     28c:	30 e0       	ldi	r19, 0x00	; 0
     28e:	3d 83       	std	Y+5, r19	; 0x05
     290:	2c 83       	std	Y+4, r18	; 0x04
     292:	4c 81       	ldd	r20, Y+4	; 0x04
     294:	5d 81       	ldd	r21, Y+5	; 0x05
     296:	41 30       	cpi	r20, 0x01	; 1
     298:	51 05       	cpc	r21, r1
     29a:	49 f1       	breq	.+82     	; 0x2ee <Dio_u8GetPinValue+0x78>
     29c:	8c 81       	ldd	r24, Y+4	; 0x04
     29e:	9d 81       	ldd	r25, Y+5	; 0x05
     2a0:	82 30       	cpi	r24, 0x02	; 2
     2a2:	91 05       	cpc	r25, r1
     2a4:	34 f4       	brge	.+12     	; 0x2b2 <Dio_u8GetPinValue+0x3c>
     2a6:	2c 81       	ldd	r18, Y+4	; 0x04
     2a8:	3d 81       	ldd	r19, Y+5	; 0x05
     2aa:	21 15       	cp	r18, r1
     2ac:	31 05       	cpc	r19, r1
     2ae:	61 f0       	breq	.+24     	; 0x2c8 <Dio_u8GetPinValue+0x52>
     2b0:	57 c0       	rjmp	.+174    	; 0x360 <Dio_u8GetPinValue+0xea>
     2b2:	4c 81       	ldd	r20, Y+4	; 0x04
     2b4:	5d 81       	ldd	r21, Y+5	; 0x05
     2b6:	42 30       	cpi	r20, 0x02	; 2
     2b8:	51 05       	cpc	r21, r1
     2ba:	61 f1       	breq	.+88     	; 0x314 <Dio_u8GetPinValue+0x9e>
     2bc:	8c 81       	ldd	r24, Y+4	; 0x04
     2be:	9d 81       	ldd	r25, Y+5	; 0x05
     2c0:	83 30       	cpi	r24, 0x03	; 3
     2c2:	91 05       	cpc	r25, r1
     2c4:	d1 f1       	breq	.+116    	; 0x33a <Dio_u8GetPinValue+0xc4>
     2c6:	4c c0       	rjmp	.+152    	; 0x360 <Dio_u8GetPinValue+0xea>
	{
	case Dio_PORTA:
		return getbit(PINA,u8PinNumbercpy);
     2c8:	e9 e3       	ldi	r30, 0x39	; 57
     2ca:	f0 e0       	ldi	r31, 0x00	; 0
     2cc:	80 81       	ld	r24, Z
     2ce:	28 2f       	mov	r18, r24
     2d0:	30 e0       	ldi	r19, 0x00	; 0
     2d2:	8a 81       	ldd	r24, Y+2	; 0x02
     2d4:	88 2f       	mov	r24, r24
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	a9 01       	movw	r20, r18
     2da:	02 c0       	rjmp	.+4      	; 0x2e0 <Dio_u8GetPinValue+0x6a>
     2dc:	55 95       	asr	r21
     2de:	47 95       	ror	r20
     2e0:	8a 95       	dec	r24
     2e2:	e2 f7       	brpl	.-8      	; 0x2dc <Dio_u8GetPinValue+0x66>
     2e4:	ca 01       	movw	r24, r20
     2e6:	58 2f       	mov	r21, r24
     2e8:	51 70       	andi	r21, 0x01	; 1
     2ea:	5b 83       	std	Y+3, r21	; 0x03
     2ec:	3a c0       	rjmp	.+116    	; 0x362 <Dio_u8GetPinValue+0xec>

	break;


	case Dio_PORTB:
		return getbit(PINB,u8PinNumbercpy);
     2ee:	e6 e3       	ldi	r30, 0x36	; 54
     2f0:	f0 e0       	ldi	r31, 0x00	; 0
     2f2:	80 81       	ld	r24, Z
     2f4:	28 2f       	mov	r18, r24
     2f6:	30 e0       	ldi	r19, 0x00	; 0
     2f8:	8a 81       	ldd	r24, Y+2	; 0x02
     2fa:	88 2f       	mov	r24, r24
     2fc:	90 e0       	ldi	r25, 0x00	; 0
     2fe:	a9 01       	movw	r20, r18
     300:	02 c0       	rjmp	.+4      	; 0x306 <Dio_u8GetPinValue+0x90>
     302:	55 95       	asr	r21
     304:	47 95       	ror	r20
     306:	8a 95       	dec	r24
     308:	e2 f7       	brpl	.-8      	; 0x302 <Dio_u8GetPinValue+0x8c>
     30a:	ca 01       	movw	r24, r20
     30c:	58 2f       	mov	r21, r24
     30e:	51 70       	andi	r21, 0x01	; 1
     310:	5b 83       	std	Y+3, r21	; 0x03
     312:	27 c0       	rjmp	.+78     	; 0x362 <Dio_u8GetPinValue+0xec>

	break;


	case Dio_PORTC:
		return	getbit(PINC,u8PinNumbercpy);
     314:	e3 e3       	ldi	r30, 0x33	; 51
     316:	f0 e0       	ldi	r31, 0x00	; 0
     318:	80 81       	ld	r24, Z
     31a:	28 2f       	mov	r18, r24
     31c:	30 e0       	ldi	r19, 0x00	; 0
     31e:	8a 81       	ldd	r24, Y+2	; 0x02
     320:	88 2f       	mov	r24, r24
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	a9 01       	movw	r20, r18
     326:	02 c0       	rjmp	.+4      	; 0x32c <Dio_u8GetPinValue+0xb6>
     328:	55 95       	asr	r21
     32a:	47 95       	ror	r20
     32c:	8a 95       	dec	r24
     32e:	e2 f7       	brpl	.-8      	; 0x328 <Dio_u8GetPinValue+0xb2>
     330:	ca 01       	movw	r24, r20
     332:	58 2f       	mov	r21, r24
     334:	51 70       	andi	r21, 0x01	; 1
     336:	5b 83       	std	Y+3, r21	; 0x03
     338:	14 c0       	rjmp	.+40     	; 0x362 <Dio_u8GetPinValue+0xec>
	break;


	case Dio_PORTD:
		return	getbit(PIND,u8PinNumbercpy);
     33a:	e0 e3       	ldi	r30, 0x30	; 48
     33c:	f0 e0       	ldi	r31, 0x00	; 0
     33e:	80 81       	ld	r24, Z
     340:	28 2f       	mov	r18, r24
     342:	30 e0       	ldi	r19, 0x00	; 0
     344:	8a 81       	ldd	r24, Y+2	; 0x02
     346:	88 2f       	mov	r24, r24
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	a9 01       	movw	r20, r18
     34c:	02 c0       	rjmp	.+4      	; 0x352 <Dio_u8GetPinValue+0xdc>
     34e:	55 95       	asr	r21
     350:	47 95       	ror	r20
     352:	8a 95       	dec	r24
     354:	e2 f7       	brpl	.-8      	; 0x34e <Dio_u8GetPinValue+0xd8>
     356:	ca 01       	movw	r24, r20
     358:	58 2f       	mov	r21, r24
     35a:	51 70       	andi	r21, 0x01	; 1
     35c:	5b 83       	std	Y+3, r21	; 0x03
     35e:	01 c0       	rjmp	.+2      	; 0x362 <Dio_u8GetPinValue+0xec>
	break;

	default:
	{
	return 0;
     360:	1b 82       	std	Y+3, r1	; 0x03
     362:	8b 81       	ldd	r24, Y+3	; 0x03
	}

 }
}
     364:	0f 90       	pop	r0
     366:	0f 90       	pop	r0
     368:	0f 90       	pop	r0
     36a:	0f 90       	pop	r0
     36c:	0f 90       	pop	r0
     36e:	cf 91       	pop	r28
     370:	df 91       	pop	r29
     372:	08 95       	ret

00000374 <Dio_vidSetPinDirection>:

void Dio_vidSetPinDirection(u8 u8PortNumberCpy,u8 u8PinNumberCpy,u8 u8DirectionCpy)
{
     374:	df 93       	push	r29
     376:	cf 93       	push	r28
     378:	00 d0       	rcall	.+0      	; 0x37a <Dio_vidSetPinDirection+0x6>
     37a:	00 d0       	rcall	.+0      	; 0x37c <Dio_vidSetPinDirection+0x8>
     37c:	0f 92       	push	r0
     37e:	cd b7       	in	r28, 0x3d	; 61
     380:	de b7       	in	r29, 0x3e	; 62
     382:	89 83       	std	Y+1, r24	; 0x01
     384:	6a 83       	std	Y+2, r22	; 0x02
     386:	4b 83       	std	Y+3, r20	; 0x03
	switch(u8PortNumberCpy)
     388:	89 81       	ldd	r24, Y+1	; 0x01
     38a:	28 2f       	mov	r18, r24
     38c:	30 e0       	ldi	r19, 0x00	; 0
     38e:	3d 83       	std	Y+5, r19	; 0x05
     390:	2c 83       	std	Y+4, r18	; 0x04
     392:	8c 81       	ldd	r24, Y+4	; 0x04
     394:	9d 81       	ldd	r25, Y+5	; 0x05
     396:	81 30       	cpi	r24, 0x01	; 1
     398:	91 05       	cpc	r25, r1
     39a:	09 f4       	brne	.+2      	; 0x39e <Dio_vidSetPinDirection+0x2a>
     39c:	46 c0       	rjmp	.+140    	; 0x42a <Dio_vidSetPinDirection+0xb6>
     39e:	2c 81       	ldd	r18, Y+4	; 0x04
     3a0:	3d 81       	ldd	r19, Y+5	; 0x05
     3a2:	22 30       	cpi	r18, 0x02	; 2
     3a4:	31 05       	cpc	r19, r1
     3a6:	2c f4       	brge	.+10     	; 0x3b2 <Dio_vidSetPinDirection+0x3e>
     3a8:	8c 81       	ldd	r24, Y+4	; 0x04
     3aa:	9d 81       	ldd	r25, Y+5	; 0x05
     3ac:	00 97       	sbiw	r24, 0x00	; 0
     3ae:	71 f0       	breq	.+28     	; 0x3cc <Dio_vidSetPinDirection+0x58>
     3b0:	ca c0       	rjmp	.+404    	; 0x546 <Dio_vidSetPinDirection+0x1d2>
     3b2:	2c 81       	ldd	r18, Y+4	; 0x04
     3b4:	3d 81       	ldd	r19, Y+5	; 0x05
     3b6:	22 30       	cpi	r18, 0x02	; 2
     3b8:	31 05       	cpc	r19, r1
     3ba:	09 f4       	brne	.+2      	; 0x3be <Dio_vidSetPinDirection+0x4a>
     3bc:	66 c0       	rjmp	.+204    	; 0x48a <Dio_vidSetPinDirection+0x116>
     3be:	8c 81       	ldd	r24, Y+4	; 0x04
     3c0:	9d 81       	ldd	r25, Y+5	; 0x05
     3c2:	83 30       	cpi	r24, 0x03	; 3
     3c4:	91 05       	cpc	r25, r1
     3c6:	09 f4       	brne	.+2      	; 0x3ca <Dio_vidSetPinDirection+0x56>
     3c8:	90 c0       	rjmp	.+288    	; 0x4ea <Dio_vidSetPinDirection+0x176>
     3ca:	bd c0       	rjmp	.+378    	; 0x546 <Dio_vidSetPinDirection+0x1d2>
	{
	case Dio_PORTA:
		if(u8DirectionCpy==0){
     3cc:	8b 81       	ldd	r24, Y+3	; 0x03
     3ce:	88 23       	and	r24, r24
     3d0:	a1 f4       	brne	.+40     	; 0x3fa <Dio_vidSetPinDirection+0x86>
		clearbit(DDRA,u8PinNumberCpy);
     3d2:	aa e3       	ldi	r26, 0x3A	; 58
     3d4:	b0 e0       	ldi	r27, 0x00	; 0
     3d6:	ea e3       	ldi	r30, 0x3A	; 58
     3d8:	f0 e0       	ldi	r31, 0x00	; 0
     3da:	80 81       	ld	r24, Z
     3dc:	48 2f       	mov	r20, r24
     3de:	8a 81       	ldd	r24, Y+2	; 0x02
     3e0:	28 2f       	mov	r18, r24
     3e2:	30 e0       	ldi	r19, 0x00	; 0
     3e4:	81 e0       	ldi	r24, 0x01	; 1
     3e6:	90 e0       	ldi	r25, 0x00	; 0
     3e8:	02 2e       	mov	r0, r18
     3ea:	02 c0       	rjmp	.+4      	; 0x3f0 <Dio_vidSetPinDirection+0x7c>
     3ec:	88 0f       	add	r24, r24
     3ee:	99 1f       	adc	r25, r25
     3f0:	0a 94       	dec	r0
     3f2:	e2 f7       	brpl	.-8      	; 0x3ec <Dio_vidSetPinDirection+0x78>
     3f4:	80 95       	com	r24
     3f6:	84 23       	and	r24, r20
     3f8:	8c 93       	st	X, r24
		}
		if(u8DirectionCpy==1){
     3fa:	8b 81       	ldd	r24, Y+3	; 0x03
     3fc:	81 30       	cpi	r24, 0x01	; 1
     3fe:	09 f0       	breq	.+2      	; 0x402 <Dio_vidSetPinDirection+0x8e>
     400:	a2 c0       	rjmp	.+324    	; 0x546 <Dio_vidSetPinDirection+0x1d2>

			setbit(DDRA,u8PinNumberCpy);
     402:	aa e3       	ldi	r26, 0x3A	; 58
     404:	b0 e0       	ldi	r27, 0x00	; 0
     406:	ea e3       	ldi	r30, 0x3A	; 58
     408:	f0 e0       	ldi	r31, 0x00	; 0
     40a:	80 81       	ld	r24, Z
     40c:	48 2f       	mov	r20, r24
     40e:	8a 81       	ldd	r24, Y+2	; 0x02
     410:	28 2f       	mov	r18, r24
     412:	30 e0       	ldi	r19, 0x00	; 0
     414:	81 e0       	ldi	r24, 0x01	; 1
     416:	90 e0       	ldi	r25, 0x00	; 0
     418:	02 2e       	mov	r0, r18
     41a:	02 c0       	rjmp	.+4      	; 0x420 <Dio_vidSetPinDirection+0xac>
     41c:	88 0f       	add	r24, r24
     41e:	99 1f       	adc	r25, r25
     420:	0a 94       	dec	r0
     422:	e2 f7       	brpl	.-8      	; 0x41c <Dio_vidSetPinDirection+0xa8>
     424:	84 2b       	or	r24, r20
     426:	8c 93       	st	X, r24
     428:	8e c0       	rjmp	.+284    	; 0x546 <Dio_vidSetPinDirection+0x1d2>
		}

	break;

	case Dio_PORTB:
		if(u8DirectionCpy==0){
     42a:	8b 81       	ldd	r24, Y+3	; 0x03
     42c:	88 23       	and	r24, r24
     42e:	a9 f4       	brne	.+42     	; 0x45a <Dio_vidSetPinDirection+0xe6>
				clearbit(DDRB,u8PinNumberCpy);
     430:	a7 e3       	ldi	r26, 0x37	; 55
     432:	b0 e0       	ldi	r27, 0x00	; 0
     434:	e7 e3       	ldi	r30, 0x37	; 55
     436:	f0 e0       	ldi	r31, 0x00	; 0
     438:	80 81       	ld	r24, Z
     43a:	48 2f       	mov	r20, r24
     43c:	8a 81       	ldd	r24, Y+2	; 0x02
     43e:	28 2f       	mov	r18, r24
     440:	30 e0       	ldi	r19, 0x00	; 0
     442:	81 e0       	ldi	r24, 0x01	; 1
     444:	90 e0       	ldi	r25, 0x00	; 0
     446:	02 2e       	mov	r0, r18
     448:	02 c0       	rjmp	.+4      	; 0x44e <Dio_vidSetPinDirection+0xda>
     44a:	88 0f       	add	r24, r24
     44c:	99 1f       	adc	r25, r25
     44e:	0a 94       	dec	r0
     450:	e2 f7       	brpl	.-8      	; 0x44a <Dio_vidSetPinDirection+0xd6>
     452:	80 95       	com	r24
     454:	84 23       	and	r24, r20
     456:	8c 93       	st	X, r24
     458:	76 c0       	rjmp	.+236    	; 0x546 <Dio_vidSetPinDirection+0x1d2>
				}
		else if(u8DirectionCpy==1){
     45a:	8b 81       	ldd	r24, Y+3	; 0x03
     45c:	81 30       	cpi	r24, 0x01	; 1
     45e:	09 f0       	breq	.+2      	; 0x462 <Dio_vidSetPinDirection+0xee>
     460:	72 c0       	rjmp	.+228    	; 0x546 <Dio_vidSetPinDirection+0x1d2>

					setbit(DDRB,u8PinNumberCpy);
     462:	a7 e3       	ldi	r26, 0x37	; 55
     464:	b0 e0       	ldi	r27, 0x00	; 0
     466:	e7 e3       	ldi	r30, 0x37	; 55
     468:	f0 e0       	ldi	r31, 0x00	; 0
     46a:	80 81       	ld	r24, Z
     46c:	48 2f       	mov	r20, r24
     46e:	8a 81       	ldd	r24, Y+2	; 0x02
     470:	28 2f       	mov	r18, r24
     472:	30 e0       	ldi	r19, 0x00	; 0
     474:	81 e0       	ldi	r24, 0x01	; 1
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	02 2e       	mov	r0, r18
     47a:	02 c0       	rjmp	.+4      	; 0x480 <Dio_vidSetPinDirection+0x10c>
     47c:	88 0f       	add	r24, r24
     47e:	99 1f       	adc	r25, r25
     480:	0a 94       	dec	r0
     482:	e2 f7       	brpl	.-8      	; 0x47c <Dio_vidSetPinDirection+0x108>
     484:	84 2b       	or	r24, r20
     486:	8c 93       	st	X, r24
     488:	5e c0       	rjmp	.+188    	; 0x546 <Dio_vidSetPinDirection+0x1d2>
				}
		break;

	case Dio_PORTC:
		if(u8DirectionCpy==0){
     48a:	8b 81       	ldd	r24, Y+3	; 0x03
     48c:	88 23       	and	r24, r24
     48e:	a9 f4       	brne	.+42     	; 0x4ba <Dio_vidSetPinDirection+0x146>
				clearbit(DDRC,u8PinNumberCpy);
     490:	a4 e3       	ldi	r26, 0x34	; 52
     492:	b0 e0       	ldi	r27, 0x00	; 0
     494:	e4 e3       	ldi	r30, 0x34	; 52
     496:	f0 e0       	ldi	r31, 0x00	; 0
     498:	80 81       	ld	r24, Z
     49a:	48 2f       	mov	r20, r24
     49c:	8a 81       	ldd	r24, Y+2	; 0x02
     49e:	28 2f       	mov	r18, r24
     4a0:	30 e0       	ldi	r19, 0x00	; 0
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	02 2e       	mov	r0, r18
     4a8:	02 c0       	rjmp	.+4      	; 0x4ae <Dio_vidSetPinDirection+0x13a>
     4aa:	88 0f       	add	r24, r24
     4ac:	99 1f       	adc	r25, r25
     4ae:	0a 94       	dec	r0
     4b0:	e2 f7       	brpl	.-8      	; 0x4aa <Dio_vidSetPinDirection+0x136>
     4b2:	80 95       	com	r24
     4b4:	84 23       	and	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	46 c0       	rjmp	.+140    	; 0x546 <Dio_vidSetPinDirection+0x1d2>
				}
		else if(u8DirectionCpy==1){
     4ba:	8b 81       	ldd	r24, Y+3	; 0x03
     4bc:	81 30       	cpi	r24, 0x01	; 1
     4be:	09 f0       	breq	.+2      	; 0x4c2 <Dio_vidSetPinDirection+0x14e>
     4c0:	42 c0       	rjmp	.+132    	; 0x546 <Dio_vidSetPinDirection+0x1d2>

					setbit(DDRC,u8PinNumberCpy);
     4c2:	a4 e3       	ldi	r26, 0x34	; 52
     4c4:	b0 e0       	ldi	r27, 0x00	; 0
     4c6:	e4 e3       	ldi	r30, 0x34	; 52
     4c8:	f0 e0       	ldi	r31, 0x00	; 0
     4ca:	80 81       	ld	r24, Z
     4cc:	48 2f       	mov	r20, r24
     4ce:	8a 81       	ldd	r24, Y+2	; 0x02
     4d0:	28 2f       	mov	r18, r24
     4d2:	30 e0       	ldi	r19, 0x00	; 0
     4d4:	81 e0       	ldi	r24, 0x01	; 1
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	02 2e       	mov	r0, r18
     4da:	02 c0       	rjmp	.+4      	; 0x4e0 <Dio_vidSetPinDirection+0x16c>
     4dc:	88 0f       	add	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	0a 94       	dec	r0
     4e2:	e2 f7       	brpl	.-8      	; 0x4dc <Dio_vidSetPinDirection+0x168>
     4e4:	84 2b       	or	r24, r20
     4e6:	8c 93       	st	X, r24
     4e8:	2e c0       	rjmp	.+92     	; 0x546 <Dio_vidSetPinDirection+0x1d2>
				}

		break;

	case Dio_PORTD:
		if(u8DirectionCpy==0){
     4ea:	8b 81       	ldd	r24, Y+3	; 0x03
     4ec:	88 23       	and	r24, r24
     4ee:	a9 f4       	brne	.+42     	; 0x51a <Dio_vidSetPinDirection+0x1a6>
				clearbit(DDRD,u8PinNumberCpy);
     4f0:	a1 e3       	ldi	r26, 0x31	; 49
     4f2:	b0 e0       	ldi	r27, 0x00	; 0
     4f4:	e1 e3       	ldi	r30, 0x31	; 49
     4f6:	f0 e0       	ldi	r31, 0x00	; 0
     4f8:	80 81       	ld	r24, Z
     4fa:	48 2f       	mov	r20, r24
     4fc:	8a 81       	ldd	r24, Y+2	; 0x02
     4fe:	28 2f       	mov	r18, r24
     500:	30 e0       	ldi	r19, 0x00	; 0
     502:	81 e0       	ldi	r24, 0x01	; 1
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	02 2e       	mov	r0, r18
     508:	02 c0       	rjmp	.+4      	; 0x50e <Dio_vidSetPinDirection+0x19a>
     50a:	88 0f       	add	r24, r24
     50c:	99 1f       	adc	r25, r25
     50e:	0a 94       	dec	r0
     510:	e2 f7       	brpl	.-8      	; 0x50a <Dio_vidSetPinDirection+0x196>
     512:	80 95       	com	r24
     514:	84 23       	and	r24, r20
     516:	8c 93       	st	X, r24
     518:	16 c0       	rjmp	.+44     	; 0x546 <Dio_vidSetPinDirection+0x1d2>
				}
		else if(u8DirectionCpy==1){
     51a:	8b 81       	ldd	r24, Y+3	; 0x03
     51c:	81 30       	cpi	r24, 0x01	; 1
     51e:	99 f4       	brne	.+38     	; 0x546 <Dio_vidSetPinDirection+0x1d2>

					setbit(DDRD,u8PinNumberCpy);
     520:	a1 e3       	ldi	r26, 0x31	; 49
     522:	b0 e0       	ldi	r27, 0x00	; 0
     524:	e1 e3       	ldi	r30, 0x31	; 49
     526:	f0 e0       	ldi	r31, 0x00	; 0
     528:	80 81       	ld	r24, Z
     52a:	48 2f       	mov	r20, r24
     52c:	8a 81       	ldd	r24, Y+2	; 0x02
     52e:	28 2f       	mov	r18, r24
     530:	30 e0       	ldi	r19, 0x00	; 0
     532:	81 e0       	ldi	r24, 0x01	; 1
     534:	90 e0       	ldi	r25, 0x00	; 0
     536:	02 2e       	mov	r0, r18
     538:	02 c0       	rjmp	.+4      	; 0x53e <Dio_vidSetPinDirection+0x1ca>
     53a:	88 0f       	add	r24, r24
     53c:	99 1f       	adc	r25, r25
     53e:	0a 94       	dec	r0
     540:	e2 f7       	brpl	.-8      	; 0x53a <Dio_vidSetPinDirection+0x1c6>
     542:	84 2b       	or	r24, r20
     544:	8c 93       	st	X, r24
				}

		break;

	}
}
     546:	0f 90       	pop	r0
     548:	0f 90       	pop	r0
     54a:	0f 90       	pop	r0
     54c:	0f 90       	pop	r0
     54e:	0f 90       	pop	r0
     550:	cf 91       	pop	r28
     552:	df 91       	pop	r29
     554:	08 95       	ret

00000556 <Dio_vidSetPortDirection>:

void Dio_vidSetPortDirection(u8 u8PortNumberCpy,u8 u8ValueCpy)
{
     556:	df 93       	push	r29
     558:	cf 93       	push	r28
     55a:	00 d0       	rcall	.+0      	; 0x55c <Dio_vidSetPortDirection+0x6>
     55c:	00 d0       	rcall	.+0      	; 0x55e <Dio_vidSetPortDirection+0x8>
     55e:	cd b7       	in	r28, 0x3d	; 61
     560:	de b7       	in	r29, 0x3e	; 62
     562:	89 83       	std	Y+1, r24	; 0x01
     564:	6a 83       	std	Y+2, r22	; 0x02
	switch(u8PortNumberCpy)
     566:	89 81       	ldd	r24, Y+1	; 0x01
     568:	28 2f       	mov	r18, r24
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	3c 83       	std	Y+4, r19	; 0x04
     56e:	2b 83       	std	Y+3, r18	; 0x03
     570:	8b 81       	ldd	r24, Y+3	; 0x03
     572:	9c 81       	ldd	r25, Y+4	; 0x04
     574:	81 30       	cpi	r24, 0x01	; 1
     576:	91 05       	cpc	r25, r1
     578:	d1 f0       	breq	.+52     	; 0x5ae <Dio_vidSetPortDirection+0x58>
     57a:	2b 81       	ldd	r18, Y+3	; 0x03
     57c:	3c 81       	ldd	r19, Y+4	; 0x04
     57e:	22 30       	cpi	r18, 0x02	; 2
     580:	31 05       	cpc	r19, r1
     582:	2c f4       	brge	.+10     	; 0x58e <Dio_vidSetPortDirection+0x38>
     584:	8b 81       	ldd	r24, Y+3	; 0x03
     586:	9c 81       	ldd	r25, Y+4	; 0x04
     588:	00 97       	sbiw	r24, 0x00	; 0
     58a:	61 f0       	breq	.+24     	; 0x5a4 <Dio_vidSetPortDirection+0x4e>
     58c:	1e c0       	rjmp	.+60     	; 0x5ca <Dio_vidSetPortDirection+0x74>
     58e:	2b 81       	ldd	r18, Y+3	; 0x03
     590:	3c 81       	ldd	r19, Y+4	; 0x04
     592:	22 30       	cpi	r18, 0x02	; 2
     594:	31 05       	cpc	r19, r1
     596:	81 f0       	breq	.+32     	; 0x5b8 <Dio_vidSetPortDirection+0x62>
     598:	8b 81       	ldd	r24, Y+3	; 0x03
     59a:	9c 81       	ldd	r25, Y+4	; 0x04
     59c:	83 30       	cpi	r24, 0x03	; 3
     59e:	91 05       	cpc	r25, r1
     5a0:	81 f0       	breq	.+32     	; 0x5c2 <Dio_vidSetPortDirection+0x6c>
     5a2:	13 c0       	rjmp	.+38     	; 0x5ca <Dio_vidSetPortDirection+0x74>
	{
	case Dio_PORTA:
		DDRA=u8ValueCpy;
     5a4:	ea e3       	ldi	r30, 0x3A	; 58
     5a6:	f0 e0       	ldi	r31, 0x00	; 0
     5a8:	8a 81       	ldd	r24, Y+2	; 0x02
     5aa:	80 83       	st	Z, r24
     5ac:	0e c0       	rjmp	.+28     	; 0x5ca <Dio_vidSetPortDirection+0x74>
	break;

	case Dio_PORTB:
			DDRB=u8ValueCpy;
     5ae:	e7 e3       	ldi	r30, 0x37	; 55
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
     5b2:	8a 81       	ldd	r24, Y+2	; 0x02
     5b4:	80 83       	st	Z, r24
     5b6:	09 c0       	rjmp	.+18     	; 0x5ca <Dio_vidSetPortDirection+0x74>
		break;

	case Dio_PORTC:
			DDRC=u8ValueCpy;
     5b8:	e4 e3       	ldi	r30, 0x34	; 52
     5ba:	f0 e0       	ldi	r31, 0x00	; 0
     5bc:	8a 81       	ldd	r24, Y+2	; 0x02
     5be:	80 83       	st	Z, r24
     5c0:	04 c0       	rjmp	.+8      	; 0x5ca <Dio_vidSetPortDirection+0x74>
		break;

	case Dio_PORTD:
			DDRD=u8ValueCpy;
     5c2:	e1 e3       	ldi	r30, 0x31	; 49
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	8a 81       	ldd	r24, Y+2	; 0x02
     5c8:	80 83       	st	Z, r24
		break;

	}
}
     5ca:	0f 90       	pop	r0
     5cc:	0f 90       	pop	r0
     5ce:	0f 90       	pop	r0
     5d0:	0f 90       	pop	r0
     5d2:	cf 91       	pop	r28
     5d4:	df 91       	pop	r29
     5d6:	08 95       	ret

000005d8 <Dio_vidSetPortValue>:

void Dio_vidSetPortValue(u8 u8PortNumberCpy,u8 u8ValueCpy)
{
     5d8:	df 93       	push	r29
     5da:	cf 93       	push	r28
     5dc:	00 d0       	rcall	.+0      	; 0x5de <Dio_vidSetPortValue+0x6>
     5de:	00 d0       	rcall	.+0      	; 0x5e0 <Dio_vidSetPortValue+0x8>
     5e0:	cd b7       	in	r28, 0x3d	; 61
     5e2:	de b7       	in	r29, 0x3e	; 62
     5e4:	89 83       	std	Y+1, r24	; 0x01
     5e6:	6a 83       	std	Y+2, r22	; 0x02
	switch(u8PortNumberCpy)
     5e8:	89 81       	ldd	r24, Y+1	; 0x01
     5ea:	28 2f       	mov	r18, r24
     5ec:	30 e0       	ldi	r19, 0x00	; 0
     5ee:	3c 83       	std	Y+4, r19	; 0x04
     5f0:	2b 83       	std	Y+3, r18	; 0x03
     5f2:	8b 81       	ldd	r24, Y+3	; 0x03
     5f4:	9c 81       	ldd	r25, Y+4	; 0x04
     5f6:	81 30       	cpi	r24, 0x01	; 1
     5f8:	91 05       	cpc	r25, r1
     5fa:	d1 f0       	breq	.+52     	; 0x630 <Dio_vidSetPortValue+0x58>
     5fc:	2b 81       	ldd	r18, Y+3	; 0x03
     5fe:	3c 81       	ldd	r19, Y+4	; 0x04
     600:	22 30       	cpi	r18, 0x02	; 2
     602:	31 05       	cpc	r19, r1
     604:	2c f4       	brge	.+10     	; 0x610 <Dio_vidSetPortValue+0x38>
     606:	8b 81       	ldd	r24, Y+3	; 0x03
     608:	9c 81       	ldd	r25, Y+4	; 0x04
     60a:	00 97       	sbiw	r24, 0x00	; 0
     60c:	61 f0       	breq	.+24     	; 0x626 <Dio_vidSetPortValue+0x4e>
     60e:	1e c0       	rjmp	.+60     	; 0x64c <Dio_vidSetPortValue+0x74>
     610:	2b 81       	ldd	r18, Y+3	; 0x03
     612:	3c 81       	ldd	r19, Y+4	; 0x04
     614:	22 30       	cpi	r18, 0x02	; 2
     616:	31 05       	cpc	r19, r1
     618:	81 f0       	breq	.+32     	; 0x63a <Dio_vidSetPortValue+0x62>
     61a:	8b 81       	ldd	r24, Y+3	; 0x03
     61c:	9c 81       	ldd	r25, Y+4	; 0x04
     61e:	83 30       	cpi	r24, 0x03	; 3
     620:	91 05       	cpc	r25, r1
     622:	81 f0       	breq	.+32     	; 0x644 <Dio_vidSetPortValue+0x6c>
     624:	13 c0       	rjmp	.+38     	; 0x64c <Dio_vidSetPortValue+0x74>
	{
	case Dio_PORTA:
		PORTA=u8ValueCpy;
     626:	eb e3       	ldi	r30, 0x3B	; 59
     628:	f0 e0       	ldi	r31, 0x00	; 0
     62a:	8a 81       	ldd	r24, Y+2	; 0x02
     62c:	80 83       	st	Z, r24
     62e:	0e c0       	rjmp	.+28     	; 0x64c <Dio_vidSetPortValue+0x74>
		break;

	case Dio_PORTB:
		PORTB =u8ValueCpy;
     630:	e8 e3       	ldi	r30, 0x38	; 56
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	8a 81       	ldd	r24, Y+2	; 0x02
     636:	80 83       	st	Z, r24
     638:	09 c0       	rjmp	.+18     	; 0x64c <Dio_vidSetPortValue+0x74>
		break;

	case Dio_PORTC:
			PORTC =u8ValueCpy;
     63a:	e5 e3       	ldi	r30, 0x35	; 53
     63c:	f0 e0       	ldi	r31, 0x00	; 0
     63e:	8a 81       	ldd	r24, Y+2	; 0x02
     640:	80 83       	st	Z, r24
     642:	04 c0       	rjmp	.+8      	; 0x64c <Dio_vidSetPortValue+0x74>
			break;

	case Dio_PORTD:
			PORTD =u8ValueCpy;
     644:	e2 e3       	ldi	r30, 0x32	; 50
     646:	f0 e0       	ldi	r31, 0x00	; 0
     648:	8a 81       	ldd	r24, Y+2	; 0x02
     64a:	80 83       	st	Z, r24
			break;

	}
}
     64c:	0f 90       	pop	r0
     64e:	0f 90       	pop	r0
     650:	0f 90       	pop	r0
     652:	0f 90       	pop	r0
     654:	cf 91       	pop	r28
     656:	df 91       	pop	r29
     658:	08 95       	ret

0000065a <Dio_u8GetPortValue>:


u8 Dio_u8GetPortValue(u8 u8PortNumberCpy)
{
     65a:	df 93       	push	r29
     65c:	cf 93       	push	r28
     65e:	00 d0       	rcall	.+0      	; 0x660 <Dio_u8GetPortValue+0x6>
     660:	00 d0       	rcall	.+0      	; 0x662 <Dio_u8GetPortValue+0x8>
     662:	cd b7       	in	r28, 0x3d	; 61
     664:	de b7       	in	r29, 0x3e	; 62
     666:	89 83       	std	Y+1, r24	; 0x01
	switch(u8PortNumberCpy)
     668:	89 81       	ldd	r24, Y+1	; 0x01
     66a:	28 2f       	mov	r18, r24
     66c:	30 e0       	ldi	r19, 0x00	; 0
     66e:	3c 83       	std	Y+4, r19	; 0x04
     670:	2b 83       	std	Y+3, r18	; 0x03
     672:	8b 81       	ldd	r24, Y+3	; 0x03
     674:	9c 81       	ldd	r25, Y+4	; 0x04
     676:	81 30       	cpi	r24, 0x01	; 1
     678:	91 05       	cpc	r25, r1
     67a:	d1 f0       	breq	.+52     	; 0x6b0 <Dio_u8GetPortValue+0x56>
     67c:	2b 81       	ldd	r18, Y+3	; 0x03
     67e:	3c 81       	ldd	r19, Y+4	; 0x04
     680:	22 30       	cpi	r18, 0x02	; 2
     682:	31 05       	cpc	r19, r1
     684:	2c f4       	brge	.+10     	; 0x690 <Dio_u8GetPortValue+0x36>
     686:	8b 81       	ldd	r24, Y+3	; 0x03
     688:	9c 81       	ldd	r25, Y+4	; 0x04
     68a:	00 97       	sbiw	r24, 0x00	; 0
     68c:	61 f0       	breq	.+24     	; 0x6a6 <Dio_u8GetPortValue+0x4c>
     68e:	1f c0       	rjmp	.+62     	; 0x6ce <Dio_u8GetPortValue+0x74>
     690:	2b 81       	ldd	r18, Y+3	; 0x03
     692:	3c 81       	ldd	r19, Y+4	; 0x04
     694:	22 30       	cpi	r18, 0x02	; 2
     696:	31 05       	cpc	r19, r1
     698:	81 f0       	breq	.+32     	; 0x6ba <Dio_u8GetPortValue+0x60>
     69a:	8b 81       	ldd	r24, Y+3	; 0x03
     69c:	9c 81       	ldd	r25, Y+4	; 0x04
     69e:	83 30       	cpi	r24, 0x03	; 3
     6a0:	91 05       	cpc	r25, r1
     6a2:	81 f0       	breq	.+32     	; 0x6c4 <Dio_u8GetPortValue+0x6a>
     6a4:	14 c0       	rjmp	.+40     	; 0x6ce <Dio_u8GetPortValue+0x74>
	{
	case Dio_PORTA:
		return PINA;
     6a6:	e9 e3       	ldi	r30, 0x39	; 57
     6a8:	f0 e0       	ldi	r31, 0x00	; 0
     6aa:	90 81       	ld	r25, Z
     6ac:	9a 83       	std	Y+2, r25	; 0x02
     6ae:	10 c0       	rjmp	.+32     	; 0x6d0 <Dio_u8GetPortValue+0x76>
	break;

	case Dio_PORTB:
		return PINB;
     6b0:	e6 e3       	ldi	r30, 0x36	; 54
     6b2:	f0 e0       	ldi	r31, 0x00	; 0
     6b4:	20 81       	ld	r18, Z
     6b6:	2a 83       	std	Y+2, r18	; 0x02
     6b8:	0b c0       	rjmp	.+22     	; 0x6d0 <Dio_u8GetPortValue+0x76>
		break;

	case Dio_PORTC:
		return PINC;
     6ba:	e3 e3       	ldi	r30, 0x33	; 51
     6bc:	f0 e0       	ldi	r31, 0x00	; 0
     6be:	30 81       	ld	r19, Z
     6c0:	3a 83       	std	Y+2, r19	; 0x02
     6c2:	06 c0       	rjmp	.+12     	; 0x6d0 <Dio_u8GetPortValue+0x76>
		break;

	case Dio_PORTD:
		return PIND;
     6c4:	e0 e3       	ldi	r30, 0x30	; 48
     6c6:	f0 e0       	ldi	r31, 0x00	; 0
     6c8:	80 81       	ld	r24, Z
     6ca:	8a 83       	std	Y+2, r24	; 0x02
     6cc:	01 c0       	rjmp	.+2      	; 0x6d0 <Dio_u8GetPortValue+0x76>

	default:
		return 0;
     6ce:	1a 82       	std	Y+2, r1	; 0x02
     6d0:	8a 81       	ldd	r24, Y+2	; 0x02

	}

}
     6d2:	0f 90       	pop	r0
     6d4:	0f 90       	pop	r0
     6d6:	0f 90       	pop	r0
     6d8:	0f 90       	pop	r0
     6da:	cf 91       	pop	r28
     6dc:	df 91       	pop	r29
     6de:	08 95       	ret

000006e0 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     6e0:	df 93       	push	r29
     6e2:	cf 93       	push	r28
     6e4:	cd b7       	in	r28, 0x3d	; 61
     6e6:	de b7       	in	r29, 0x3e	; 62
     6e8:	27 97       	sbiw	r28, 0x07	; 7
     6ea:	0f b6       	in	r0, 0x3f	; 63
     6ec:	f8 94       	cli
     6ee:	de bf       	out	0x3e, r29	; 62
     6f0:	0f be       	out	0x3f, r0	; 63
     6f2:	cd bf       	out	0x3d, r28	; 61
     6f4:	9d 83       	std	Y+5, r25	; 0x05
     6f6:	8c 83       	std	Y+4, r24	; 0x04
     6f8:	6e 83       	std	Y+6, r22	; 0x06
     6fa:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     6fc:	8e e1       	ldi	r24, 0x1E	; 30
     6fe:	90 e0       	ldi	r25, 0x00	; 0
     700:	0e 94 b9 06 	call	0xd72	; 0xd72 <pvPortMalloc>
     704:	9a 83       	std	Y+2, r25	; 0x02
     706:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     708:	89 81       	ldd	r24, Y+1	; 0x01
     70a:	9a 81       	ldd	r25, Y+2	; 0x02
     70c:	00 97       	sbiw	r24, 0x00	; 0
     70e:	09 f4       	brne	.+2      	; 0x712 <xCoRoutineCreate+0x32>
     710:	7a c0       	rjmp	.+244    	; 0x806 <xCoRoutineCreate+0x126>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     712:	80 91 74 00 	lds	r24, 0x0074
     716:	90 91 75 00 	lds	r25, 0x0075
     71a:	00 97       	sbiw	r24, 0x00	; 0
     71c:	41 f4       	brne	.+16     	; 0x72e <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	9a 81       	ldd	r25, Y+2	; 0x02
     722:	90 93 75 00 	sts	0x0075, r25
     726:	80 93 74 00 	sts	0x0074, r24
			prvInitialiseCoRoutineLists();
     72a:	0e 94 45 06 	call	0xc8a	; 0xc8a <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     72e:	8e 81       	ldd	r24, Y+6	; 0x06
     730:	82 30       	cpi	r24, 0x02	; 2
     732:	10 f0       	brcs	.+4      	; 0x738 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     738:	e9 81       	ldd	r30, Y+1	; 0x01
     73a:	fa 81       	ldd	r31, Y+2	; 0x02
     73c:	15 8e       	std	Z+29, r1	; 0x1d
     73e:	14 8e       	std	Z+28, r1	; 0x1c
		pxCoRoutine->uxPriority = uxPriority;
     740:	e9 81       	ldd	r30, Y+1	; 0x01
     742:	fa 81       	ldd	r31, Y+2	; 0x02
     744:	8e 81       	ldd	r24, Y+6	; 0x06
     746:	82 8f       	std	Z+26, r24	; 0x1a
		pxCoRoutine->uxIndex = uxIndex;
     748:	e9 81       	ldd	r30, Y+1	; 0x01
     74a:	fa 81       	ldd	r31, Y+2	; 0x02
     74c:	8f 81       	ldd	r24, Y+7	; 0x07
     74e:	83 8f       	std	Z+27, r24	; 0x1b
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     750:	e9 81       	ldd	r30, Y+1	; 0x01
     752:	fa 81       	ldd	r31, Y+2	; 0x02
     754:	8c 81       	ldd	r24, Y+4	; 0x04
     756:	9d 81       	ldd	r25, Y+5	; 0x05
     758:	91 83       	std	Z+1, r25	; 0x01
     75a:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     75c:	89 81       	ldd	r24, Y+1	; 0x01
     75e:	9a 81       	ldd	r25, Y+2	; 0x02
     760:	02 96       	adiw	r24, 0x02	; 2
     762:	0e 94 53 07 	call	0xea6	; 0xea6 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     766:	89 81       	ldd	r24, Y+1	; 0x01
     768:	9a 81       	ldd	r25, Y+2	; 0x02
     76a:	0e 96       	adiw	r24, 0x0e	; 14
     76c:	0e 94 53 07 	call	0xea6	; 0xea6 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     770:	e9 81       	ldd	r30, Y+1	; 0x01
     772:	fa 81       	ldd	r31, Y+2	; 0x02
     774:	89 81       	ldd	r24, Y+1	; 0x01
     776:	9a 81       	ldd	r25, Y+2	; 0x02
     778:	93 87       	std	Z+11, r25	; 0x0b
     77a:	82 87       	std	Z+10, r24	; 0x0a
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     77c:	e9 81       	ldd	r30, Y+1	; 0x01
     77e:	fa 81       	ldd	r31, Y+2	; 0x02
     780:	89 81       	ldd	r24, Y+1	; 0x01
     782:	9a 81       	ldd	r25, Y+2	; 0x02
     784:	97 8b       	std	Z+23, r25	; 0x17
     786:	86 8b       	std	Z+22, r24	; 0x16
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     788:	8e 81       	ldd	r24, Y+6	; 0x06
     78a:	28 2f       	mov	r18, r24
     78c:	30 e0       	ldi	r19, 0x00	; 0
     78e:	40 e0       	ldi	r20, 0x00	; 0
     790:	50 e0       	ldi	r21, 0x00	; 0
     792:	8f e0       	ldi	r24, 0x0F	; 15
     794:	90 e0       	ldi	r25, 0x00	; 0
     796:	a0 e0       	ldi	r26, 0x00	; 0
     798:	b0 e0       	ldi	r27, 0x00	; 0
     79a:	82 1b       	sub	r24, r18
     79c:	93 0b       	sbc	r25, r19
     79e:	a4 0b       	sbc	r26, r20
     7a0:	b5 0b       	sbc	r27, r21
     7a2:	e9 81       	ldd	r30, Y+1	; 0x01
     7a4:	fa 81       	ldd	r31, Y+2	; 0x02
     7a6:	86 87       	std	Z+14, r24	; 0x0e
     7a8:	97 87       	std	Z+15, r25	; 0x0f
     7aa:	a0 8b       	std	Z+16, r26	; 0x10
     7ac:	b1 8b       	std	Z+17, r27	; 0x11
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     7ae:	e9 81       	ldd	r30, Y+1	; 0x01
     7b0:	fa 81       	ldd	r31, Y+2	; 0x02
     7b2:	92 8d       	ldd	r25, Z+26	; 0x1a
     7b4:	80 91 76 00 	lds	r24, 0x0076
     7b8:	89 17       	cp	r24, r25
     7ba:	28 f4       	brcc	.+10     	; 0x7c6 <xCoRoutineCreate+0xe6>
     7bc:	e9 81       	ldd	r30, Y+1	; 0x01
     7be:	fa 81       	ldd	r31, Y+2	; 0x02
     7c0:	82 8d       	ldd	r24, Z+26	; 0x1a
     7c2:	80 93 76 00 	sts	0x0076, r24
     7c6:	e9 81       	ldd	r30, Y+1	; 0x01
     7c8:	fa 81       	ldd	r31, Y+2	; 0x02
     7ca:	82 8d       	ldd	r24, Z+26	; 0x1a
     7cc:	48 2f       	mov	r20, r24
     7ce:	50 e0       	ldi	r21, 0x00	; 0
     7d0:	ca 01       	movw	r24, r20
     7d2:	88 0f       	add	r24, r24
     7d4:	99 1f       	adc	r25, r25
     7d6:	9c 01       	movw	r18, r24
     7d8:	22 0f       	add	r18, r18
     7da:	33 1f       	adc	r19, r19
     7dc:	22 0f       	add	r18, r18
     7de:	33 1f       	adc	r19, r19
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	84 0f       	add	r24, r20
     7e6:	95 1f       	adc	r25, r21
     7e8:	ac 01       	movw	r20, r24
     7ea:	4d 57       	subi	r20, 0x7D	; 125
     7ec:	5f 4f       	sbci	r21, 0xFF	; 255
     7ee:	89 81       	ldd	r24, Y+1	; 0x01
     7f0:	9a 81       	ldd	r25, Y+2	; 0x02
     7f2:	9c 01       	movw	r18, r24
     7f4:	2e 5f       	subi	r18, 0xFE	; 254
     7f6:	3f 4f       	sbci	r19, 0xFF	; 255
     7f8:	ca 01       	movw	r24, r20
     7fa:	b9 01       	movw	r22, r18
     7fc:	0e 94 63 07 	call	0xec6	; 0xec6 <vListInsertEnd>

		xReturn = pdPASS;
     800:	81 e0       	ldi	r24, 0x01	; 1
     802:	8b 83       	std	Y+3, r24	; 0x03
     804:	02 c0       	rjmp	.+4      	; 0x80a <xCoRoutineCreate+0x12a>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     806:	8f ef       	ldi	r24, 0xFF	; 255
     808:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     80a:	8b 81       	ldd	r24, Y+3	; 0x03
}
     80c:	27 96       	adiw	r28, 0x07	; 7
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	f8 94       	cli
     812:	de bf       	out	0x3e, r29	; 62
     814:	0f be       	out	0x3f, r0	; 63
     816:	cd bf       	out	0x3d, r28	; 61
     818:	cf 91       	pop	r28
     81a:	df 91       	pop	r29
     81c:	08 95       	ret

0000081e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     81e:	df 93       	push	r29
     820:	cf 93       	push	r28
     822:	cd b7       	in	r28, 0x3d	; 61
     824:	de b7       	in	r29, 0x3e	; 62
     826:	2a 97       	sbiw	r28, 0x0a	; 10
     828:	0f b6       	in	r0, 0x3f	; 63
     82a:	f8 94       	cli
     82c:	de bf       	out	0x3e, r29	; 62
     82e:	0f be       	out	0x3f, r0	; 63
     830:	cd bf       	out	0x3d, r28	; 61
     832:	6d 83       	std	Y+5, r22	; 0x05
     834:	7e 83       	std	Y+6, r23	; 0x06
     836:	8f 83       	std	Y+7, r24	; 0x07
     838:	98 87       	std	Y+8, r25	; 0x08
     83a:	5a 87       	std	Y+10, r21	; 0x0a
     83c:	49 87       	std	Y+9, r20	; 0x09
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     83e:	20 91 77 00 	lds	r18, 0x0077
     842:	30 91 78 00 	lds	r19, 0x0078
     846:	40 91 79 00 	lds	r20, 0x0079
     84a:	50 91 7a 00 	lds	r21, 0x007A
     84e:	8d 81       	ldd	r24, Y+5	; 0x05
     850:	9e 81       	ldd	r25, Y+6	; 0x06
     852:	af 81       	ldd	r26, Y+7	; 0x07
     854:	b8 85       	ldd	r27, Y+8	; 0x08
     856:	82 0f       	add	r24, r18
     858:	93 1f       	adc	r25, r19
     85a:	a4 1f       	adc	r26, r20
     85c:	b5 1f       	adc	r27, r21
     85e:	89 83       	std	Y+1, r24	; 0x01
     860:	9a 83       	std	Y+2, r25	; 0x02
     862:	ab 83       	std	Y+3, r26	; 0x03
     864:	bc 83       	std	Y+4, r27	; 0x04

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     866:	80 91 74 00 	lds	r24, 0x0074
     86a:	90 91 75 00 	lds	r25, 0x0075
     86e:	02 96       	adiw	r24, 0x02	; 2
     870:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     874:	e0 91 74 00 	lds	r30, 0x0074
     878:	f0 91 75 00 	lds	r31, 0x0075
     87c:	89 81       	ldd	r24, Y+1	; 0x01
     87e:	9a 81       	ldd	r25, Y+2	; 0x02
     880:	ab 81       	ldd	r26, Y+3	; 0x03
     882:	bc 81       	ldd	r27, Y+4	; 0x04
     884:	82 83       	std	Z+2, r24	; 0x02
     886:	93 83       	std	Z+3, r25	; 0x03
     888:	a4 83       	std	Z+4, r26	; 0x04
     88a:	b5 83       	std	Z+5, r27	; 0x05

	if( xTimeToWake < xCoRoutineTickCount )
     88c:	20 91 77 00 	lds	r18, 0x0077
     890:	30 91 78 00 	lds	r19, 0x0078
     894:	40 91 79 00 	lds	r20, 0x0079
     898:	50 91 7a 00 	lds	r21, 0x007A
     89c:	89 81       	ldd	r24, Y+1	; 0x01
     89e:	9a 81       	ldd	r25, Y+2	; 0x02
     8a0:	ab 81       	ldd	r26, Y+3	; 0x03
     8a2:	bc 81       	ldd	r27, Y+4	; 0x04
     8a4:	82 17       	cp	r24, r18
     8a6:	93 07       	cpc	r25, r19
     8a8:	a4 07       	cpc	r26, r20
     8aa:	b5 07       	cpc	r27, r21
     8ac:	70 f4       	brcc	.+28     	; 0x8ca <__stack+0x6b>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     8ae:	80 91 b1 00 	lds	r24, 0x00B1
     8b2:	90 91 b2 00 	lds	r25, 0x00B2
     8b6:	20 91 74 00 	lds	r18, 0x0074
     8ba:	30 91 75 00 	lds	r19, 0x0075
     8be:	2e 5f       	subi	r18, 0xFE	; 254
     8c0:	3f 4f       	sbci	r19, 0xFF	; 255
     8c2:	b9 01       	movw	r22, r18
     8c4:	0e 94 af 07 	call	0xf5e	; 0xf5e <vListInsert>
     8c8:	0d c0       	rjmp	.+26     	; 0x8e4 <__stack+0x85>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     8ca:	80 91 af 00 	lds	r24, 0x00AF
     8ce:	90 91 b0 00 	lds	r25, 0x00B0
     8d2:	20 91 74 00 	lds	r18, 0x0074
     8d6:	30 91 75 00 	lds	r19, 0x0075
     8da:	2e 5f       	subi	r18, 0xFE	; 254
     8dc:	3f 4f       	sbci	r19, 0xFF	; 255
     8de:	b9 01       	movw	r22, r18
     8e0:	0e 94 af 07 	call	0xf5e	; 0xf5e <vListInsert>
	}

	if( pxEventList )
     8e4:	89 85       	ldd	r24, Y+9	; 0x09
     8e6:	9a 85       	ldd	r25, Y+10	; 0x0a
     8e8:	00 97       	sbiw	r24, 0x00	; 0
     8ea:	61 f0       	breq	.+24     	; 0x904 <__stack+0xa5>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     8ec:	80 91 74 00 	lds	r24, 0x0074
     8f0:	90 91 75 00 	lds	r25, 0x0075
     8f4:	9c 01       	movw	r18, r24
     8f6:	22 5f       	subi	r18, 0xF2	; 242
     8f8:	3f 4f       	sbci	r19, 0xFF	; 255
     8fa:	89 85       	ldd	r24, Y+9	; 0x09
     8fc:	9a 85       	ldd	r25, Y+10	; 0x0a
     8fe:	b9 01       	movw	r22, r18
     900:	0e 94 af 07 	call	0xf5e	; 0xf5e <vListInsert>
	}
}
     904:	2a 96       	adiw	r28, 0x0a	; 10
     906:	0f b6       	in	r0, 0x3f	; 63
     908:	f8 94       	cli
     90a:	de bf       	out	0x3e, r29	; 62
     90c:	0f be       	out	0x3f, r0	; 63
     90e:	cd bf       	out	0x3d, r28	; 61
     910:	cf 91       	pop	r28
     912:	df 91       	pop	r29
     914:	08 95       	ret

00000916 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     916:	df 93       	push	r29
     918:	cf 93       	push	r28
     91a:	00 d0       	rcall	.+0      	; 0x91c <prvCheckPendingReadyList+0x6>
     91c:	cd b7       	in	r28, 0x3d	; 61
     91e:	de b7       	in	r29, 0x3e	; 62
     920:	3d c0       	rjmp	.+122    	; 0x99c <prvCheckPendingReadyList+0x86>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     922:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     924:	e0 91 ba 00 	lds	r30, 0x00BA
     928:	f0 91 bb 00 	lds	r31, 0x00BB
     92c:	80 85       	ldd	r24, Z+8	; 0x08
     92e:	91 85       	ldd	r25, Z+9	; 0x09
     930:	9a 83       	std	Y+2, r25	; 0x02
     932:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     934:	89 81       	ldd	r24, Y+1	; 0x01
     936:	9a 81       	ldd	r25, Y+2	; 0x02
     938:	0e 96       	adiw	r24, 0x0e	; 14
     93a:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     93e:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     940:	89 81       	ldd	r24, Y+1	; 0x01
     942:	9a 81       	ldd	r25, Y+2	; 0x02
     944:	02 96       	adiw	r24, 0x02	; 2
     946:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     94a:	e9 81       	ldd	r30, Y+1	; 0x01
     94c:	fa 81       	ldd	r31, Y+2	; 0x02
     94e:	92 8d       	ldd	r25, Z+26	; 0x1a
     950:	80 91 76 00 	lds	r24, 0x0076
     954:	89 17       	cp	r24, r25
     956:	28 f4       	brcc	.+10     	; 0x962 <prvCheckPendingReadyList+0x4c>
     958:	e9 81       	ldd	r30, Y+1	; 0x01
     95a:	fa 81       	ldd	r31, Y+2	; 0x02
     95c:	82 8d       	ldd	r24, Z+26	; 0x1a
     95e:	80 93 76 00 	sts	0x0076, r24
     962:	e9 81       	ldd	r30, Y+1	; 0x01
     964:	fa 81       	ldd	r31, Y+2	; 0x02
     966:	82 8d       	ldd	r24, Z+26	; 0x1a
     968:	48 2f       	mov	r20, r24
     96a:	50 e0       	ldi	r21, 0x00	; 0
     96c:	ca 01       	movw	r24, r20
     96e:	88 0f       	add	r24, r24
     970:	99 1f       	adc	r25, r25
     972:	9c 01       	movw	r18, r24
     974:	22 0f       	add	r18, r18
     976:	33 1f       	adc	r19, r19
     978:	22 0f       	add	r18, r18
     97a:	33 1f       	adc	r19, r19
     97c:	82 0f       	add	r24, r18
     97e:	93 1f       	adc	r25, r19
     980:	84 0f       	add	r24, r20
     982:	95 1f       	adc	r25, r21
     984:	ac 01       	movw	r20, r24
     986:	4d 57       	subi	r20, 0x7D	; 125
     988:	5f 4f       	sbci	r21, 0xFF	; 255
     98a:	89 81       	ldd	r24, Y+1	; 0x01
     98c:	9a 81       	ldd	r25, Y+2	; 0x02
     98e:	9c 01       	movw	r18, r24
     990:	2e 5f       	subi	r18, 0xFE	; 254
     992:	3f 4f       	sbci	r19, 0xFF	; 255
     994:	ca 01       	movw	r24, r20
     996:	b9 01       	movw	r22, r18
     998:	0e 94 63 07 	call	0xec6	; 0xec6 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     99c:	80 91 b3 00 	lds	r24, 0x00B3
     9a0:	88 23       	and	r24, r24
     9a2:	09 f0       	breq	.+2      	; 0x9a6 <prvCheckPendingReadyList+0x90>
     9a4:	be cf       	rjmp	.-132    	; 0x922 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     9a6:	0f 90       	pop	r0
     9a8:	0f 90       	pop	r0
     9aa:	cf 91       	pop	r28
     9ac:	df 91       	pop	r29
     9ae:	08 95       	ret

000009b0 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     9b0:	df 93       	push	r29
     9b2:	cf 93       	push	r28
     9b4:	00 d0       	rcall	.+0      	; 0x9b6 <prvCheckDelayedList+0x6>
     9b6:	00 d0       	rcall	.+0      	; 0x9b8 <prvCheckDelayedList+0x8>
     9b8:	cd b7       	in	r28, 0x3d	; 61
     9ba:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     9bc:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <xTaskGetTickCount>
     9c0:	dc 01       	movw	r26, r24
     9c2:	cb 01       	movw	r24, r22
     9c4:	20 91 7b 00 	lds	r18, 0x007B
     9c8:	30 91 7c 00 	lds	r19, 0x007C
     9cc:	40 91 7d 00 	lds	r20, 0x007D
     9d0:	50 91 7e 00 	lds	r21, 0x007E
     9d4:	82 1b       	sub	r24, r18
     9d6:	93 0b       	sbc	r25, r19
     9d8:	a4 0b       	sbc	r26, r20
     9da:	b5 0b       	sbc	r27, r21
     9dc:	80 93 7f 00 	sts	0x007F, r24
     9e0:	90 93 80 00 	sts	0x0080, r25
     9e4:	a0 93 81 00 	sts	0x0081, r26
     9e8:	b0 93 82 00 	sts	0x0082, r27
     9ec:	aa c0       	rjmp	.+340    	; 0xb42 <prvCheckDelayedList+0x192>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     9ee:	80 91 77 00 	lds	r24, 0x0077
     9f2:	90 91 78 00 	lds	r25, 0x0078
     9f6:	a0 91 79 00 	lds	r26, 0x0079
     9fa:	b0 91 7a 00 	lds	r27, 0x007A
     9fe:	01 96       	adiw	r24, 0x01	; 1
     a00:	a1 1d       	adc	r26, r1
     a02:	b1 1d       	adc	r27, r1
     a04:	80 93 77 00 	sts	0x0077, r24
     a08:	90 93 78 00 	sts	0x0078, r25
     a0c:	a0 93 79 00 	sts	0x0079, r26
     a10:	b0 93 7a 00 	sts	0x007A, r27
		xPassedTicks--;
     a14:	80 91 7f 00 	lds	r24, 0x007F
     a18:	90 91 80 00 	lds	r25, 0x0080
     a1c:	a0 91 81 00 	lds	r26, 0x0081
     a20:	b0 91 82 00 	lds	r27, 0x0082
     a24:	01 97       	sbiw	r24, 0x01	; 1
     a26:	a1 09       	sbc	r26, r1
     a28:	b1 09       	sbc	r27, r1
     a2a:	80 93 7f 00 	sts	0x007F, r24
     a2e:	90 93 80 00 	sts	0x0080, r25
     a32:	a0 93 81 00 	sts	0x0081, r26
     a36:	b0 93 82 00 	sts	0x0082, r27

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     a3a:	80 91 77 00 	lds	r24, 0x0077
     a3e:	90 91 78 00 	lds	r25, 0x0078
     a42:	a0 91 79 00 	lds	r26, 0x0079
     a46:	b0 91 7a 00 	lds	r27, 0x007A
     a4a:	00 97       	sbiw	r24, 0x00	; 0
     a4c:	a1 05       	cpc	r26, r1
     a4e:	b1 05       	cpc	r27, r1
     a50:	09 f0       	breq	.+2      	; 0xa54 <prvCheckDelayedList+0xa4>
     a52:	6f c0       	rjmp	.+222    	; 0xb32 <prvCheckDelayedList+0x182>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     a54:	80 91 af 00 	lds	r24, 0x00AF
     a58:	90 91 b0 00 	lds	r25, 0x00B0
     a5c:	9a 83       	std	Y+2, r25	; 0x02
     a5e:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     a60:	80 91 b1 00 	lds	r24, 0x00B1
     a64:	90 91 b2 00 	lds	r25, 0x00B2
     a68:	90 93 b0 00 	sts	0x00B0, r25
     a6c:	80 93 af 00 	sts	0x00AF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     a70:	89 81       	ldd	r24, Y+1	; 0x01
     a72:	9a 81       	ldd	r25, Y+2	; 0x02
     a74:	90 93 b2 00 	sts	0x00B2, r25
     a78:	80 93 b1 00 	sts	0x00B1, r24
     a7c:	5a c0       	rjmp	.+180    	; 0xb32 <prvCheckDelayedList+0x182>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     a7e:	e0 91 af 00 	lds	r30, 0x00AF
     a82:	f0 91 b0 00 	lds	r31, 0x00B0
     a86:	07 80       	ldd	r0, Z+7	; 0x07
     a88:	f0 85       	ldd	r31, Z+8	; 0x08
     a8a:	e0 2d       	mov	r30, r0
     a8c:	80 85       	ldd	r24, Z+8	; 0x08
     a8e:	91 85       	ldd	r25, Z+9	; 0x09
     a90:	9c 83       	std	Y+4, r25	; 0x04
     a92:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     a94:	eb 81       	ldd	r30, Y+3	; 0x03
     a96:	fc 81       	ldd	r31, Y+4	; 0x04
     a98:	22 81       	ldd	r18, Z+2	; 0x02
     a9a:	33 81       	ldd	r19, Z+3	; 0x03
     a9c:	44 81       	ldd	r20, Z+4	; 0x04
     a9e:	55 81       	ldd	r21, Z+5	; 0x05
     aa0:	80 91 77 00 	lds	r24, 0x0077
     aa4:	90 91 78 00 	lds	r25, 0x0078
     aa8:	a0 91 79 00 	lds	r26, 0x0079
     aac:	b0 91 7a 00 	lds	r27, 0x007A
     ab0:	82 17       	cp	r24, r18
     ab2:	93 07       	cpc	r25, r19
     ab4:	a4 07       	cpc	r26, r20
     ab6:	b5 07       	cpc	r27, r21
     ab8:	08 f4       	brcc	.+2      	; 0xabc <prvCheckDelayedList+0x10c>
     aba:	43 c0       	rjmp	.+134    	; 0xb42 <prvCheckDelayedList+0x192>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     abc:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     abe:	8b 81       	ldd	r24, Y+3	; 0x03
     ac0:	9c 81       	ldd	r25, Y+4	; 0x04
     ac2:	02 96       	adiw	r24, 0x02	; 2
     ac4:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     ac8:	eb 81       	ldd	r30, Y+3	; 0x03
     aca:	fc 81       	ldd	r31, Y+4	; 0x04
     acc:	80 8d       	ldd	r24, Z+24	; 0x18
     ace:	91 8d       	ldd	r25, Z+25	; 0x19
     ad0:	00 97       	sbiw	r24, 0x00	; 0
     ad2:	29 f0       	breq	.+10     	; 0xade <prvCheckDelayedList+0x12e>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     ad4:	8b 81       	ldd	r24, Y+3	; 0x03
     ad6:	9c 81       	ldd	r25, Y+4	; 0x04
     ad8:	0e 96       	adiw	r24, 0x0e	; 14
     ada:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     ade:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     ae0:	eb 81       	ldd	r30, Y+3	; 0x03
     ae2:	fc 81       	ldd	r31, Y+4	; 0x04
     ae4:	92 8d       	ldd	r25, Z+26	; 0x1a
     ae6:	80 91 76 00 	lds	r24, 0x0076
     aea:	89 17       	cp	r24, r25
     aec:	28 f4       	brcc	.+10     	; 0xaf8 <prvCheckDelayedList+0x148>
     aee:	eb 81       	ldd	r30, Y+3	; 0x03
     af0:	fc 81       	ldd	r31, Y+4	; 0x04
     af2:	82 8d       	ldd	r24, Z+26	; 0x1a
     af4:	80 93 76 00 	sts	0x0076, r24
     af8:	eb 81       	ldd	r30, Y+3	; 0x03
     afa:	fc 81       	ldd	r31, Y+4	; 0x04
     afc:	82 8d       	ldd	r24, Z+26	; 0x1a
     afe:	48 2f       	mov	r20, r24
     b00:	50 e0       	ldi	r21, 0x00	; 0
     b02:	ca 01       	movw	r24, r20
     b04:	88 0f       	add	r24, r24
     b06:	99 1f       	adc	r25, r25
     b08:	9c 01       	movw	r18, r24
     b0a:	22 0f       	add	r18, r18
     b0c:	33 1f       	adc	r19, r19
     b0e:	22 0f       	add	r18, r18
     b10:	33 1f       	adc	r19, r19
     b12:	82 0f       	add	r24, r18
     b14:	93 1f       	adc	r25, r19
     b16:	84 0f       	add	r24, r20
     b18:	95 1f       	adc	r25, r21
     b1a:	ac 01       	movw	r20, r24
     b1c:	4d 57       	subi	r20, 0x7D	; 125
     b1e:	5f 4f       	sbci	r21, 0xFF	; 255
     b20:	8b 81       	ldd	r24, Y+3	; 0x03
     b22:	9c 81       	ldd	r25, Y+4	; 0x04
     b24:	9c 01       	movw	r18, r24
     b26:	2e 5f       	subi	r18, 0xFE	; 254
     b28:	3f 4f       	sbci	r19, 0xFF	; 255
     b2a:	ca 01       	movw	r24, r20
     b2c:	b9 01       	movw	r22, r18
     b2e:	0e 94 63 07 	call	0xec6	; 0xec6 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     b32:	e0 91 af 00 	lds	r30, 0x00AF
     b36:	f0 91 b0 00 	lds	r31, 0x00B0
     b3a:	80 81       	ld	r24, Z
     b3c:	88 23       	and	r24, r24
     b3e:	09 f0       	breq	.+2      	; 0xb42 <prvCheckDelayedList+0x192>
     b40:	9e cf       	rjmp	.-196    	; 0xa7e <prvCheckDelayedList+0xce>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     b42:	80 91 7f 00 	lds	r24, 0x007F
     b46:	90 91 80 00 	lds	r25, 0x0080
     b4a:	a0 91 81 00 	lds	r26, 0x0081
     b4e:	b0 91 82 00 	lds	r27, 0x0082
     b52:	00 97       	sbiw	r24, 0x00	; 0
     b54:	a1 05       	cpc	r26, r1
     b56:	b1 05       	cpc	r27, r1
     b58:	09 f0       	breq	.+2      	; 0xb5c <prvCheckDelayedList+0x1ac>
     b5a:	49 cf       	rjmp	.-366    	; 0x9ee <prvCheckDelayedList+0x3e>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     b5c:	80 91 77 00 	lds	r24, 0x0077
     b60:	90 91 78 00 	lds	r25, 0x0078
     b64:	a0 91 79 00 	lds	r26, 0x0079
     b68:	b0 91 7a 00 	lds	r27, 0x007A
     b6c:	80 93 7b 00 	sts	0x007B, r24
     b70:	90 93 7c 00 	sts	0x007C, r25
     b74:	a0 93 7d 00 	sts	0x007D, r26
     b78:	b0 93 7e 00 	sts	0x007E, r27
}
     b7c:	0f 90       	pop	r0
     b7e:	0f 90       	pop	r0
     b80:	0f 90       	pop	r0
     b82:	0f 90       	pop	r0
     b84:	cf 91       	pop	r28
     b86:	df 91       	pop	r29
     b88:	08 95       	ret

00000b8a <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     b8a:	df 93       	push	r29
     b8c:	cf 93       	push	r28
     b8e:	00 d0       	rcall	.+0      	; 0xb90 <vCoRoutineSchedule+0x6>
     b90:	cd b7       	in	r28, 0x3d	; 61
     b92:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     b94:	0e 94 8b 04 	call	0x916	; 0x916 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     b98:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <prvCheckDelayedList>
     b9c:	0a c0       	rjmp	.+20     	; 0xbb2 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     b9e:	80 91 76 00 	lds	r24, 0x0076
     ba2:	88 23       	and	r24, r24
     ba4:	09 f4       	brne	.+2      	; 0xba8 <vCoRoutineSchedule+0x1e>
     ba6:	6c c0       	rjmp	.+216    	; 0xc80 <vCoRoutineSchedule+0xf6>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     ba8:	80 91 76 00 	lds	r24, 0x0076
     bac:	81 50       	subi	r24, 0x01	; 1
     bae:	80 93 76 00 	sts	0x0076, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     bb2:	80 91 76 00 	lds	r24, 0x0076
     bb6:	48 2f       	mov	r20, r24
     bb8:	50 e0       	ldi	r21, 0x00	; 0
     bba:	ca 01       	movw	r24, r20
     bbc:	88 0f       	add	r24, r24
     bbe:	99 1f       	adc	r25, r25
     bc0:	9c 01       	movw	r18, r24
     bc2:	22 0f       	add	r18, r18
     bc4:	33 1f       	adc	r19, r19
     bc6:	22 0f       	add	r18, r18
     bc8:	33 1f       	adc	r19, r19
     bca:	82 0f       	add	r24, r18
     bcc:	93 1f       	adc	r25, r19
     bce:	84 0f       	add	r24, r20
     bd0:	95 1f       	adc	r25, r21
     bd2:	fc 01       	movw	r30, r24
     bd4:	ed 57       	subi	r30, 0x7D	; 125
     bd6:	ff 4f       	sbci	r31, 0xFF	; 255
     bd8:	80 81       	ld	r24, Z
     bda:	88 23       	and	r24, r24
     bdc:	01 f3       	breq	.-64     	; 0xb9e <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     bde:	80 91 76 00 	lds	r24, 0x0076
     be2:	48 2f       	mov	r20, r24
     be4:	50 e0       	ldi	r21, 0x00	; 0
     be6:	ca 01       	movw	r24, r20
     be8:	88 0f       	add	r24, r24
     bea:	99 1f       	adc	r25, r25
     bec:	9c 01       	movw	r18, r24
     bee:	22 0f       	add	r18, r18
     bf0:	33 1f       	adc	r19, r19
     bf2:	22 0f       	add	r18, r18
     bf4:	33 1f       	adc	r19, r19
     bf6:	82 0f       	add	r24, r18
     bf8:	93 1f       	adc	r25, r19
     bfa:	84 0f       	add	r24, r20
     bfc:	95 1f       	adc	r25, r21
     bfe:	8d 57       	subi	r24, 0x7D	; 125
     c00:	9f 4f       	sbci	r25, 0xFF	; 255
     c02:	9a 83       	std	Y+2, r25	; 0x02
     c04:	89 83       	std	Y+1, r24	; 0x01
     c06:	e9 81       	ldd	r30, Y+1	; 0x01
     c08:	fa 81       	ldd	r31, Y+2	; 0x02
     c0a:	01 80       	ldd	r0, Z+1	; 0x01
     c0c:	f2 81       	ldd	r31, Z+2	; 0x02
     c0e:	e0 2d       	mov	r30, r0
     c10:	84 81       	ldd	r24, Z+4	; 0x04
     c12:	95 81       	ldd	r25, Z+5	; 0x05
     c14:	e9 81       	ldd	r30, Y+1	; 0x01
     c16:	fa 81       	ldd	r31, Y+2	; 0x02
     c18:	92 83       	std	Z+2, r25	; 0x02
     c1a:	81 83       	std	Z+1, r24	; 0x01
     c1c:	e9 81       	ldd	r30, Y+1	; 0x01
     c1e:	fa 81       	ldd	r31, Y+2	; 0x02
     c20:	21 81       	ldd	r18, Z+1	; 0x01
     c22:	32 81       	ldd	r19, Z+2	; 0x02
     c24:	89 81       	ldd	r24, Y+1	; 0x01
     c26:	9a 81       	ldd	r25, Y+2	; 0x02
     c28:	03 96       	adiw	r24, 0x03	; 3
     c2a:	28 17       	cp	r18, r24
     c2c:	39 07       	cpc	r19, r25
     c2e:	59 f4       	brne	.+22     	; 0xc46 <vCoRoutineSchedule+0xbc>
     c30:	e9 81       	ldd	r30, Y+1	; 0x01
     c32:	fa 81       	ldd	r31, Y+2	; 0x02
     c34:	01 80       	ldd	r0, Z+1	; 0x01
     c36:	f2 81       	ldd	r31, Z+2	; 0x02
     c38:	e0 2d       	mov	r30, r0
     c3a:	84 81       	ldd	r24, Z+4	; 0x04
     c3c:	95 81       	ldd	r25, Z+5	; 0x05
     c3e:	e9 81       	ldd	r30, Y+1	; 0x01
     c40:	fa 81       	ldd	r31, Y+2	; 0x02
     c42:	92 83       	std	Z+2, r25	; 0x02
     c44:	81 83       	std	Z+1, r24	; 0x01
     c46:	e9 81       	ldd	r30, Y+1	; 0x01
     c48:	fa 81       	ldd	r31, Y+2	; 0x02
     c4a:	01 80       	ldd	r0, Z+1	; 0x01
     c4c:	f2 81       	ldd	r31, Z+2	; 0x02
     c4e:	e0 2d       	mov	r30, r0
     c50:	80 85       	ldd	r24, Z+8	; 0x08
     c52:	91 85       	ldd	r25, Z+9	; 0x09
     c54:	90 93 75 00 	sts	0x0075, r25
     c58:	80 93 74 00 	sts	0x0074, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     c5c:	e0 91 74 00 	lds	r30, 0x0074
     c60:	f0 91 75 00 	lds	r31, 0x0075
     c64:	40 81       	ld	r20, Z
     c66:	51 81       	ldd	r21, Z+1	; 0x01
     c68:	80 91 74 00 	lds	r24, 0x0074
     c6c:	90 91 75 00 	lds	r25, 0x0075
     c70:	e0 91 74 00 	lds	r30, 0x0074
     c74:	f0 91 75 00 	lds	r31, 0x0075
     c78:	23 8d       	ldd	r18, Z+27	; 0x1b
     c7a:	62 2f       	mov	r22, r18
     c7c:	fa 01       	movw	r30, r20
     c7e:	09 95       	icall

	return;
}
     c80:	0f 90       	pop	r0
     c82:	0f 90       	pop	r0
     c84:	cf 91       	pop	r28
     c86:	df 91       	pop	r29
     c88:	08 95       	ret

00000c8a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     c8a:	df 93       	push	r29
     c8c:	cf 93       	push	r28
     c8e:	0f 92       	push	r0
     c90:	cd b7       	in	r28, 0x3d	; 61
     c92:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     c94:	19 82       	std	Y+1, r1	; 0x01
     c96:	16 c0       	rjmp	.+44     	; 0xcc4 <prvInitialiseCoRoutineLists+0x3a>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     c98:	89 81       	ldd	r24, Y+1	; 0x01
     c9a:	48 2f       	mov	r20, r24
     c9c:	50 e0       	ldi	r21, 0x00	; 0
     c9e:	ca 01       	movw	r24, r20
     ca0:	88 0f       	add	r24, r24
     ca2:	99 1f       	adc	r25, r25
     ca4:	9c 01       	movw	r18, r24
     ca6:	22 0f       	add	r18, r18
     ca8:	33 1f       	adc	r19, r19
     caa:	22 0f       	add	r18, r18
     cac:	33 1f       	adc	r19, r19
     cae:	82 0f       	add	r24, r18
     cb0:	93 1f       	adc	r25, r19
     cb2:	84 0f       	add	r24, r20
     cb4:	95 1f       	adc	r25, r21
     cb6:	8d 57       	subi	r24, 0x7D	; 125
     cb8:	9f 4f       	sbci	r25, 0xFF	; 255
     cba:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     cbe:	89 81       	ldd	r24, Y+1	; 0x01
     cc0:	8f 5f       	subi	r24, 0xFF	; 255
     cc2:	89 83       	std	Y+1, r24	; 0x01
     cc4:	89 81       	ldd	r24, Y+1	; 0x01
     cc6:	82 30       	cpi	r24, 0x02	; 2
     cc8:	38 f3       	brcs	.-50     	; 0xc98 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     cca:	89 e9       	ldi	r24, 0x99	; 153
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     cd2:	84 ea       	ldi	r24, 0xA4	; 164
     cd4:	90 e0       	ldi	r25, 0x00	; 0
     cd6:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     cda:	83 eb       	ldi	r24, 0xB3	; 179
     cdc:	90 e0       	ldi	r25, 0x00	; 0
     cde:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     ce2:	89 e9       	ldi	r24, 0x99	; 153
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	90 93 b0 00 	sts	0x00B0, r25
     cea:	80 93 af 00 	sts	0x00AF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     cee:	84 ea       	ldi	r24, 0xA4	; 164
     cf0:	90 e0       	ldi	r25, 0x00	; 0
     cf2:	90 93 b2 00 	sts	0x00B2, r25
     cf6:	80 93 b1 00 	sts	0x00B1, r24
}
     cfa:	0f 90       	pop	r0
     cfc:	cf 91       	pop	r28
     cfe:	df 91       	pop	r29
     d00:	08 95       	ret

00000d02 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     d02:	df 93       	push	r29
     d04:	cf 93       	push	r28
     d06:	00 d0       	rcall	.+0      	; 0xd08 <xCoRoutineRemoveFromEventList+0x6>
     d08:	00 d0       	rcall	.+0      	; 0xd0a <xCoRoutineRemoveFromEventList+0x8>
     d0a:	0f 92       	push	r0
     d0c:	cd b7       	in	r28, 0x3d	; 61
     d0e:	de b7       	in	r29, 0x3e	; 62
     d10:	9d 83       	std	Y+5, r25	; 0x05
     d12:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     d14:	ec 81       	ldd	r30, Y+4	; 0x04
     d16:	fd 81       	ldd	r31, Y+5	; 0x05
     d18:	07 80       	ldd	r0, Z+7	; 0x07
     d1a:	f0 85       	ldd	r31, Z+8	; 0x08
     d1c:	e0 2d       	mov	r30, r0
     d1e:	80 85       	ldd	r24, Z+8	; 0x08
     d20:	91 85       	ldd	r25, Z+9	; 0x09
     d22:	9b 83       	std	Y+3, r25	; 0x03
     d24:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     d26:	8a 81       	ldd	r24, Y+2	; 0x02
     d28:	9b 81       	ldd	r25, Y+3	; 0x03
     d2a:	0e 96       	adiw	r24, 0x0e	; 14
     d2c:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     d30:	8a 81       	ldd	r24, Y+2	; 0x02
     d32:	9b 81       	ldd	r25, Y+3	; 0x03
     d34:	9c 01       	movw	r18, r24
     d36:	22 5f       	subi	r18, 0xF2	; 242
     d38:	3f 4f       	sbci	r19, 0xFF	; 255
     d3a:	83 eb       	ldi	r24, 0xB3	; 179
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	b9 01       	movw	r22, r18
     d40:	0e 94 63 07 	call	0xec6	; 0xec6 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     d44:	ea 81       	ldd	r30, Y+2	; 0x02
     d46:	fb 81       	ldd	r31, Y+3	; 0x03
     d48:	92 8d       	ldd	r25, Z+26	; 0x1a
     d4a:	e0 91 74 00 	lds	r30, 0x0074
     d4e:	f0 91 75 00 	lds	r31, 0x0075
     d52:	82 8d       	ldd	r24, Z+26	; 0x1a
     d54:	98 17       	cp	r25, r24
     d56:	18 f0       	brcs	.+6      	; 0xd5e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     d58:	81 e0       	ldi	r24, 0x01	; 1
     d5a:	89 83       	std	Y+1, r24	; 0x01
     d5c:	01 c0       	rjmp	.+2      	; 0xd60 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     d5e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     d60:	89 81       	ldd	r24, Y+1	; 0x01
}
     d62:	0f 90       	pop	r0
     d64:	0f 90       	pop	r0
     d66:	0f 90       	pop	r0
     d68:	0f 90       	pop	r0
     d6a:	0f 90       	pop	r0
     d6c:	cf 91       	pop	r28
     d6e:	df 91       	pop	r29
     d70:	08 95       	ret

00000d72 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d72:	df 93       	push	r29
     d74:	cf 93       	push	r28
     d76:	00 d0       	rcall	.+0      	; 0xd78 <pvPortMalloc+0x6>
     d78:	00 d0       	rcall	.+0      	; 0xd7a <pvPortMalloc+0x8>
     d7a:	cd b7       	in	r28, 0x3d	; 61
     d7c:	de b7       	in	r29, 0x3e	; 62
     d7e:	9c 83       	std	Y+4, r25	; 0x04
     d80:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     d82:	1a 82       	std	Y+2, r1	; 0x02
     d84:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     d86:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     d8a:	80 91 be 00 	lds	r24, 0x00BE
     d8e:	90 91 bf 00 	lds	r25, 0x00BF
     d92:	2b 81       	ldd	r18, Y+3	; 0x03
     d94:	3c 81       	ldd	r19, Y+4	; 0x04
     d96:	82 0f       	add	r24, r18
     d98:	93 1f       	adc	r25, r19
     d9a:	22 e0       	ldi	r18, 0x02	; 2
     d9c:	88 35       	cpi	r24, 0x58	; 88
     d9e:	92 07       	cpc	r25, r18
     da0:	18 f5       	brcc	.+70     	; 0xde8 <pvPortMalloc+0x76>
     da2:	20 91 be 00 	lds	r18, 0x00BE
     da6:	30 91 bf 00 	lds	r19, 0x00BF
     daa:	8b 81       	ldd	r24, Y+3	; 0x03
     dac:	9c 81       	ldd	r25, Y+4	; 0x04
     dae:	28 0f       	add	r18, r24
     db0:	39 1f       	adc	r19, r25
     db2:	80 91 be 00 	lds	r24, 0x00BE
     db6:	90 91 bf 00 	lds	r25, 0x00BF
     dba:	82 17       	cp	r24, r18
     dbc:	93 07       	cpc	r25, r19
     dbe:	a0 f4       	brcc	.+40     	; 0xde8 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     dc0:	80 91 be 00 	lds	r24, 0x00BE
     dc4:	90 91 bf 00 	lds	r25, 0x00BF
     dc8:	80 54       	subi	r24, 0x40	; 64
     dca:	9f 4f       	sbci	r25, 0xFF	; 255
     dcc:	9a 83       	std	Y+2, r25	; 0x02
     dce:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     dd0:	20 91 be 00 	lds	r18, 0x00BE
     dd4:	30 91 bf 00 	lds	r19, 0x00BF
     dd8:	8b 81       	ldd	r24, Y+3	; 0x03
     dda:	9c 81       	ldd	r25, Y+4	; 0x04
     ddc:	82 0f       	add	r24, r18
     dde:	93 1f       	adc	r25, r19
     de0:	90 93 bf 00 	sts	0x00BF, r25
     de4:	80 93 be 00 	sts	0x00BE, r24
		}	
	}
	xTaskResumeAll();
     de8:	0e 94 de 12 	call	0x25bc	; 0x25bc <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     dec:	89 81       	ldd	r24, Y+1	; 0x01
     dee:	9a 81       	ldd	r25, Y+2	; 0x02
}
     df0:	0f 90       	pop	r0
     df2:	0f 90       	pop	r0
     df4:	0f 90       	pop	r0
     df6:	0f 90       	pop	r0
     df8:	cf 91       	pop	r28
     dfa:	df 91       	pop	r29
     dfc:	08 95       	ret

00000dfe <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     dfe:	df 93       	push	r29
     e00:	cf 93       	push	r28
     e02:	00 d0       	rcall	.+0      	; 0xe04 <vPortFree+0x6>
     e04:	cd b7       	in	r28, 0x3d	; 61
     e06:	de b7       	in	r29, 0x3e	; 62
     e08:	9a 83       	std	Y+2, r25	; 0x02
     e0a:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     e0c:	0f 90       	pop	r0
     e0e:	0f 90       	pop	r0
     e10:	cf 91       	pop	r28
     e12:	df 91       	pop	r29
     e14:	08 95       	ret

00000e16 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     e16:	df 93       	push	r29
     e18:	cf 93       	push	r28
     e1a:	cd b7       	in	r28, 0x3d	; 61
     e1c:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     e1e:	10 92 bf 00 	sts	0x00BF, r1
     e22:	10 92 be 00 	sts	0x00BE, r1
}
     e26:	cf 91       	pop	r28
     e28:	df 91       	pop	r29
     e2a:	08 95       	ret

00000e2c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     e2c:	df 93       	push	r29
     e2e:	cf 93       	push	r28
     e30:	cd b7       	in	r28, 0x3d	; 61
     e32:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     e34:	20 91 be 00 	lds	r18, 0x00BE
     e38:	30 91 bf 00 	lds	r19, 0x00BF
     e3c:	88 e5       	ldi	r24, 0x58	; 88
     e3e:	92 e0       	ldi	r25, 0x02	; 2
     e40:	82 1b       	sub	r24, r18
     e42:	93 0b       	sbc	r25, r19
}
     e44:	cf 91       	pop	r28
     e46:	df 91       	pop	r29
     e48:	08 95       	ret

00000e4a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     e4a:	df 93       	push	r29
     e4c:	cf 93       	push	r28
     e4e:	00 d0       	rcall	.+0      	; 0xe50 <vListInitialise+0x6>
     e50:	cd b7       	in	r28, 0x3d	; 61
     e52:	de b7       	in	r29, 0x3e	; 62
     e54:	9a 83       	std	Y+2, r25	; 0x02
     e56:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     e58:	89 81       	ldd	r24, Y+1	; 0x01
     e5a:	9a 81       	ldd	r25, Y+2	; 0x02
     e5c:	03 96       	adiw	r24, 0x03	; 3
     e5e:	e9 81       	ldd	r30, Y+1	; 0x01
     e60:	fa 81       	ldd	r31, Y+2	; 0x02
     e62:	92 83       	std	Z+2, r25	; 0x02
     e64:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     e66:	e9 81       	ldd	r30, Y+1	; 0x01
     e68:	fa 81       	ldd	r31, Y+2	; 0x02
     e6a:	8f ef       	ldi	r24, 0xFF	; 255
     e6c:	9f ef       	ldi	r25, 0xFF	; 255
     e6e:	af ef       	ldi	r26, 0xFF	; 255
     e70:	bf ef       	ldi	r27, 0xFF	; 255
     e72:	83 83       	std	Z+3, r24	; 0x03
     e74:	94 83       	std	Z+4, r25	; 0x04
     e76:	a5 83       	std	Z+5, r26	; 0x05
     e78:	b6 83       	std	Z+6, r27	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     e7a:	89 81       	ldd	r24, Y+1	; 0x01
     e7c:	9a 81       	ldd	r25, Y+2	; 0x02
     e7e:	03 96       	adiw	r24, 0x03	; 3
     e80:	e9 81       	ldd	r30, Y+1	; 0x01
     e82:	fa 81       	ldd	r31, Y+2	; 0x02
     e84:	90 87       	std	Z+8, r25	; 0x08
     e86:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     e88:	89 81       	ldd	r24, Y+1	; 0x01
     e8a:	9a 81       	ldd	r25, Y+2	; 0x02
     e8c:	03 96       	adiw	r24, 0x03	; 3
     e8e:	e9 81       	ldd	r30, Y+1	; 0x01
     e90:	fa 81       	ldd	r31, Y+2	; 0x02
     e92:	92 87       	std	Z+10, r25	; 0x0a
     e94:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     e96:	e9 81       	ldd	r30, Y+1	; 0x01
     e98:	fa 81       	ldd	r31, Y+2	; 0x02
     e9a:	10 82       	st	Z, r1
}
     e9c:	0f 90       	pop	r0
     e9e:	0f 90       	pop	r0
     ea0:	cf 91       	pop	r28
     ea2:	df 91       	pop	r29
     ea4:	08 95       	ret

00000ea6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     ea6:	df 93       	push	r29
     ea8:	cf 93       	push	r28
     eaa:	00 d0       	rcall	.+0      	; 0xeac <vListInitialiseItem+0x6>
     eac:	cd b7       	in	r28, 0x3d	; 61
     eae:	de b7       	in	r29, 0x3e	; 62
     eb0:	9a 83       	std	Y+2, r25	; 0x02
     eb2:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     eb4:	e9 81       	ldd	r30, Y+1	; 0x01
     eb6:	fa 81       	ldd	r31, Y+2	; 0x02
     eb8:	13 86       	std	Z+11, r1	; 0x0b
     eba:	12 86       	std	Z+10, r1	; 0x0a
}
     ebc:	0f 90       	pop	r0
     ebe:	0f 90       	pop	r0
     ec0:	cf 91       	pop	r28
     ec2:	df 91       	pop	r29
     ec4:	08 95       	ret

00000ec6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     ec6:	df 93       	push	r29
     ec8:	cf 93       	push	r28
     eca:	00 d0       	rcall	.+0      	; 0xecc <vListInsertEnd+0x6>
     ecc:	00 d0       	rcall	.+0      	; 0xece <vListInsertEnd+0x8>
     ece:	00 d0       	rcall	.+0      	; 0xed0 <vListInsertEnd+0xa>
     ed0:	cd b7       	in	r28, 0x3d	; 61
     ed2:	de b7       	in	r29, 0x3e	; 62
     ed4:	9c 83       	std	Y+4, r25	; 0x04
     ed6:	8b 83       	std	Y+3, r24	; 0x03
     ed8:	7e 83       	std	Y+6, r23	; 0x06
     eda:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     edc:	eb 81       	ldd	r30, Y+3	; 0x03
     ede:	fc 81       	ldd	r31, Y+4	; 0x04
     ee0:	81 81       	ldd	r24, Z+1	; 0x01
     ee2:	92 81       	ldd	r25, Z+2	; 0x02
     ee4:	9a 83       	std	Y+2, r25	; 0x02
     ee6:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     ee8:	e9 81       	ldd	r30, Y+1	; 0x01
     eea:	fa 81       	ldd	r31, Y+2	; 0x02
     eec:	84 81       	ldd	r24, Z+4	; 0x04
     eee:	95 81       	ldd	r25, Z+5	; 0x05
     ef0:	ed 81       	ldd	r30, Y+5	; 0x05
     ef2:	fe 81       	ldd	r31, Y+6	; 0x06
     ef4:	95 83       	std	Z+5, r25	; 0x05
     ef6:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxList->pxIndex;
     ef8:	eb 81       	ldd	r30, Y+3	; 0x03
     efa:	fc 81       	ldd	r31, Y+4	; 0x04
     efc:	81 81       	ldd	r24, Z+1	; 0x01
     efe:	92 81       	ldd	r25, Z+2	; 0x02
     f00:	ed 81       	ldd	r30, Y+5	; 0x05
     f02:	fe 81       	ldd	r31, Y+6	; 0x06
     f04:	97 83       	std	Z+7, r25	; 0x07
     f06:	86 83       	std	Z+6, r24	; 0x06
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     f08:	e9 81       	ldd	r30, Y+1	; 0x01
     f0a:	fa 81       	ldd	r31, Y+2	; 0x02
     f0c:	04 80       	ldd	r0, Z+4	; 0x04
     f0e:	f5 81       	ldd	r31, Z+5	; 0x05
     f10:	e0 2d       	mov	r30, r0
     f12:	8d 81       	ldd	r24, Y+5	; 0x05
     f14:	9e 81       	ldd	r25, Y+6	; 0x06
     f16:	97 83       	std	Z+7, r25	; 0x07
     f18:	86 83       	std	Z+6, r24	; 0x06
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     f1a:	8d 81       	ldd	r24, Y+5	; 0x05
     f1c:	9e 81       	ldd	r25, Y+6	; 0x06
     f1e:	e9 81       	ldd	r30, Y+1	; 0x01
     f20:	fa 81       	ldd	r31, Y+2	; 0x02
     f22:	95 83       	std	Z+5, r25	; 0x05
     f24:	84 83       	std	Z+4, r24	; 0x04
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     f26:	8d 81       	ldd	r24, Y+5	; 0x05
     f28:	9e 81       	ldd	r25, Y+6	; 0x06
     f2a:	eb 81       	ldd	r30, Y+3	; 0x03
     f2c:	fc 81       	ldd	r31, Y+4	; 0x04
     f2e:	92 83       	std	Z+2, r25	; 0x02
     f30:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     f32:	ed 81       	ldd	r30, Y+5	; 0x05
     f34:	fe 81       	ldd	r31, Y+6	; 0x06
     f36:	8b 81       	ldd	r24, Y+3	; 0x03
     f38:	9c 81       	ldd	r25, Y+4	; 0x04
     f3a:	93 87       	std	Z+11, r25	; 0x0b
     f3c:	82 87       	std	Z+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
     f3e:	eb 81       	ldd	r30, Y+3	; 0x03
     f40:	fc 81       	ldd	r31, Y+4	; 0x04
     f42:	80 81       	ld	r24, Z
     f44:	8f 5f       	subi	r24, 0xFF	; 255
     f46:	eb 81       	ldd	r30, Y+3	; 0x03
     f48:	fc 81       	ldd	r31, Y+4	; 0x04
     f4a:	80 83       	st	Z, r24
}
     f4c:	26 96       	adiw	r28, 0x06	; 6
     f4e:	0f b6       	in	r0, 0x3f	; 63
     f50:	f8 94       	cli
     f52:	de bf       	out	0x3e, r29	; 62
     f54:	0f be       	out	0x3f, r0	; 63
     f56:	cd bf       	out	0x3d, r28	; 61
     f58:	cf 91       	pop	r28
     f5a:	df 91       	pop	r29
     f5c:	08 95       	ret

00000f5e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     f5e:	df 93       	push	r29
     f60:	cf 93       	push	r28
     f62:	cd b7       	in	r28, 0x3d	; 61
     f64:	de b7       	in	r29, 0x3e	; 62
     f66:	2a 97       	sbiw	r28, 0x0a	; 10
     f68:	0f b6       	in	r0, 0x3f	; 63
     f6a:	f8 94       	cli
     f6c:	de bf       	out	0x3e, r29	; 62
     f6e:	0f be       	out	0x3f, r0	; 63
     f70:	cd bf       	out	0x3d, r28	; 61
     f72:	98 87       	std	Y+8, r25	; 0x08
     f74:	8f 83       	std	Y+7, r24	; 0x07
     f76:	7a 87       	std	Y+10, r23	; 0x0a
     f78:	69 87       	std	Y+9, r22	; 0x09
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     f7a:	e9 85       	ldd	r30, Y+9	; 0x09
     f7c:	fa 85       	ldd	r31, Y+10	; 0x0a
     f7e:	80 81       	ld	r24, Z
     f80:	91 81       	ldd	r25, Z+1	; 0x01
     f82:	a2 81       	ldd	r26, Z+2	; 0x02
     f84:	b3 81       	ldd	r27, Z+3	; 0x03
     f86:	89 83       	std	Y+1, r24	; 0x01
     f88:	9a 83       	std	Y+2, r25	; 0x02
     f8a:	ab 83       	std	Y+3, r26	; 0x03
     f8c:	bc 83       	std	Y+4, r27	; 0x04
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     f8e:	89 81       	ldd	r24, Y+1	; 0x01
     f90:	9a 81       	ldd	r25, Y+2	; 0x02
     f92:	ab 81       	ldd	r26, Y+3	; 0x03
     f94:	bc 81       	ldd	r27, Y+4	; 0x04
     f96:	8f 3f       	cpi	r24, 0xFF	; 255
     f98:	2f ef       	ldi	r18, 0xFF	; 255
     f9a:	92 07       	cpc	r25, r18
     f9c:	2f ef       	ldi	r18, 0xFF	; 255
     f9e:	a2 07       	cpc	r26, r18
     fa0:	2f ef       	ldi	r18, 0xFF	; 255
     fa2:	b2 07       	cpc	r27, r18
     fa4:	39 f4       	brne	.+14     	; 0xfb4 <vListInsert+0x56>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     fa6:	ef 81       	ldd	r30, Y+7	; 0x07
     fa8:	f8 85       	ldd	r31, Y+8	; 0x08
     faa:	81 85       	ldd	r24, Z+9	; 0x09
     fac:	92 85       	ldd	r25, Z+10	; 0x0a
     fae:	9e 83       	std	Y+6, r25	; 0x06
     fb0:	8d 83       	std	Y+5, r24	; 0x05
     fb2:	1e c0       	rjmp	.+60     	; 0xff0 <vListInsert+0x92>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     fb4:	8f 81       	ldd	r24, Y+7	; 0x07
     fb6:	98 85       	ldd	r25, Y+8	; 0x08
     fb8:	03 96       	adiw	r24, 0x03	; 3
     fba:	9e 83       	std	Y+6, r25	; 0x06
     fbc:	8d 83       	std	Y+5, r24	; 0x05
     fbe:	06 c0       	rjmp	.+12     	; 0xfcc <vListInsert+0x6e>
     fc0:	ed 81       	ldd	r30, Y+5	; 0x05
     fc2:	fe 81       	ldd	r31, Y+6	; 0x06
     fc4:	84 81       	ldd	r24, Z+4	; 0x04
     fc6:	95 81       	ldd	r25, Z+5	; 0x05
     fc8:	9e 83       	std	Y+6, r25	; 0x06
     fca:	8d 83       	std	Y+5, r24	; 0x05
     fcc:	ed 81       	ldd	r30, Y+5	; 0x05
     fce:	fe 81       	ldd	r31, Y+6	; 0x06
     fd0:	04 80       	ldd	r0, Z+4	; 0x04
     fd2:	f5 81       	ldd	r31, Z+5	; 0x05
     fd4:	e0 2d       	mov	r30, r0
     fd6:	20 81       	ld	r18, Z
     fd8:	31 81       	ldd	r19, Z+1	; 0x01
     fda:	42 81       	ldd	r20, Z+2	; 0x02
     fdc:	53 81       	ldd	r21, Z+3	; 0x03
     fde:	89 81       	ldd	r24, Y+1	; 0x01
     fe0:	9a 81       	ldd	r25, Y+2	; 0x02
     fe2:	ab 81       	ldd	r26, Y+3	; 0x03
     fe4:	bc 81       	ldd	r27, Y+4	; 0x04
     fe6:	82 17       	cp	r24, r18
     fe8:	93 07       	cpc	r25, r19
     fea:	a4 07       	cpc	r26, r20
     fec:	b5 07       	cpc	r27, r21
     fee:	40 f7       	brcc	.-48     	; 0xfc0 <vListInsert+0x62>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     ff0:	ed 81       	ldd	r30, Y+5	; 0x05
     ff2:	fe 81       	ldd	r31, Y+6	; 0x06
     ff4:	84 81       	ldd	r24, Z+4	; 0x04
     ff6:	95 81       	ldd	r25, Z+5	; 0x05
     ff8:	e9 85       	ldd	r30, Y+9	; 0x09
     ffa:	fa 85       	ldd	r31, Y+10	; 0x0a
     ffc:	95 83       	std	Z+5, r25	; 0x05
     ffe:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1000:	e9 85       	ldd	r30, Y+9	; 0x09
    1002:	fa 85       	ldd	r31, Y+10	; 0x0a
    1004:	04 80       	ldd	r0, Z+4	; 0x04
    1006:	f5 81       	ldd	r31, Z+5	; 0x05
    1008:	e0 2d       	mov	r30, r0
    100a:	89 85       	ldd	r24, Y+9	; 0x09
    100c:	9a 85       	ldd	r25, Y+10	; 0x0a
    100e:	97 83       	std	Z+7, r25	; 0x07
    1010:	86 83       	std	Z+6, r24	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
    1012:	e9 85       	ldd	r30, Y+9	; 0x09
    1014:	fa 85       	ldd	r31, Y+10	; 0x0a
    1016:	8d 81       	ldd	r24, Y+5	; 0x05
    1018:	9e 81       	ldd	r25, Y+6	; 0x06
    101a:	97 83       	std	Z+7, r25	; 0x07
    101c:	86 83       	std	Z+6, r24	; 0x06
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    101e:	89 85       	ldd	r24, Y+9	; 0x09
    1020:	9a 85       	ldd	r25, Y+10	; 0x0a
    1022:	ed 81       	ldd	r30, Y+5	; 0x05
    1024:	fe 81       	ldd	r31, Y+6	; 0x06
    1026:	95 83       	std	Z+5, r25	; 0x05
    1028:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    102a:	e9 85       	ldd	r30, Y+9	; 0x09
    102c:	fa 85       	ldd	r31, Y+10	; 0x0a
    102e:	8f 81       	ldd	r24, Y+7	; 0x07
    1030:	98 85       	ldd	r25, Y+8	; 0x08
    1032:	93 87       	std	Z+11, r25	; 0x0b
    1034:	82 87       	std	Z+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
    1036:	ef 81       	ldd	r30, Y+7	; 0x07
    1038:	f8 85       	ldd	r31, Y+8	; 0x08
    103a:	80 81       	ld	r24, Z
    103c:	8f 5f       	subi	r24, 0xFF	; 255
    103e:	ef 81       	ldd	r30, Y+7	; 0x07
    1040:	f8 85       	ldd	r31, Y+8	; 0x08
    1042:	80 83       	st	Z, r24
}
    1044:	2a 96       	adiw	r28, 0x0a	; 10
    1046:	0f b6       	in	r0, 0x3f	; 63
    1048:	f8 94       	cli
    104a:	de bf       	out	0x3e, r29	; 62
    104c:	0f be       	out	0x3f, r0	; 63
    104e:	cd bf       	out	0x3d, r28	; 61
    1050:	cf 91       	pop	r28
    1052:	df 91       	pop	r29
    1054:	08 95       	ret

00001056 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1056:	df 93       	push	r29
    1058:	cf 93       	push	r28
    105a:	00 d0       	rcall	.+0      	; 0x105c <vListRemove+0x6>
    105c:	00 d0       	rcall	.+0      	; 0x105e <vListRemove+0x8>
    105e:	cd b7       	in	r28, 0x3d	; 61
    1060:	de b7       	in	r29, 0x3e	; 62
    1062:	9c 83       	std	Y+4, r25	; 0x04
    1064:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1066:	eb 81       	ldd	r30, Y+3	; 0x03
    1068:	fc 81       	ldd	r31, Y+4	; 0x04
    106a:	a4 81       	ldd	r26, Z+4	; 0x04
    106c:	b5 81       	ldd	r27, Z+5	; 0x05
    106e:	eb 81       	ldd	r30, Y+3	; 0x03
    1070:	fc 81       	ldd	r31, Y+4	; 0x04
    1072:	86 81       	ldd	r24, Z+6	; 0x06
    1074:	97 81       	ldd	r25, Z+7	; 0x07
    1076:	17 96       	adiw	r26, 0x07	; 7
    1078:	9c 93       	st	X, r25
    107a:	8e 93       	st	-X, r24
    107c:	16 97       	sbiw	r26, 0x06	; 6
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    107e:	eb 81       	ldd	r30, Y+3	; 0x03
    1080:	fc 81       	ldd	r31, Y+4	; 0x04
    1082:	a6 81       	ldd	r26, Z+6	; 0x06
    1084:	b7 81       	ldd	r27, Z+7	; 0x07
    1086:	eb 81       	ldd	r30, Y+3	; 0x03
    1088:	fc 81       	ldd	r31, Y+4	; 0x04
    108a:	84 81       	ldd	r24, Z+4	; 0x04
    108c:	95 81       	ldd	r25, Z+5	; 0x05
    108e:	15 96       	adiw	r26, 0x05	; 5
    1090:	9c 93       	st	X, r25
    1092:	8e 93       	st	-X, r24
    1094:	14 97       	sbiw	r26, 0x04	; 4
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1096:	eb 81       	ldd	r30, Y+3	; 0x03
    1098:	fc 81       	ldd	r31, Y+4	; 0x04
    109a:	82 85       	ldd	r24, Z+10	; 0x0a
    109c:	93 85       	ldd	r25, Z+11	; 0x0b
    109e:	9a 83       	std	Y+2, r25	; 0x02
    10a0:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    10a2:	e9 81       	ldd	r30, Y+1	; 0x01
    10a4:	fa 81       	ldd	r31, Y+2	; 0x02
    10a6:	21 81       	ldd	r18, Z+1	; 0x01
    10a8:	32 81       	ldd	r19, Z+2	; 0x02
    10aa:	8b 81       	ldd	r24, Y+3	; 0x03
    10ac:	9c 81       	ldd	r25, Y+4	; 0x04
    10ae:	28 17       	cp	r18, r24
    10b0:	39 07       	cpc	r19, r25
    10b2:	41 f4       	brne	.+16     	; 0x10c4 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    10b4:	eb 81       	ldd	r30, Y+3	; 0x03
    10b6:	fc 81       	ldd	r31, Y+4	; 0x04
    10b8:	86 81       	ldd	r24, Z+6	; 0x06
    10ba:	97 81       	ldd	r25, Z+7	; 0x07
    10bc:	e9 81       	ldd	r30, Y+1	; 0x01
    10be:	fa 81       	ldd	r31, Y+2	; 0x02
    10c0:	92 83       	std	Z+2, r25	; 0x02
    10c2:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    10c4:	eb 81       	ldd	r30, Y+3	; 0x03
    10c6:	fc 81       	ldd	r31, Y+4	; 0x04
    10c8:	13 86       	std	Z+11, r1	; 0x0b
    10ca:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
    10cc:	e9 81       	ldd	r30, Y+1	; 0x01
    10ce:	fa 81       	ldd	r31, Y+2	; 0x02
    10d0:	80 81       	ld	r24, Z
    10d2:	81 50       	subi	r24, 0x01	; 1
    10d4:	e9 81       	ldd	r30, Y+1	; 0x01
    10d6:	fa 81       	ldd	r31, Y+2	; 0x02
    10d8:	80 83       	st	Z, r24
}
    10da:	0f 90       	pop	r0
    10dc:	0f 90       	pop	r0
    10de:	0f 90       	pop	r0
    10e0:	0f 90       	pop	r0
    10e2:	cf 91       	pop	r28
    10e4:	df 91       	pop	r29
    10e6:	08 95       	ret

000010e8 <main>:
	}
}*/


int main(void)
{
    10e8:	af 92       	push	r10
    10ea:	bf 92       	push	r11
    10ec:	cf 92       	push	r12
    10ee:	df 92       	push	r13
    10f0:	ef 92       	push	r14
    10f2:	ff 92       	push	r15
    10f4:	0f 93       	push	r16
    10f6:	df 93       	push	r29
    10f8:	cf 93       	push	r28
    10fa:	cd b7       	in	r28, 0x3d	; 61
    10fc:	de b7       	in	r29, 0x3e	; 62
    Dio_vidSetPortDirection(Dio_PORTB,0xff);
    10fe:	81 e0       	ldi	r24, 0x01	; 1
    1100:	6f ef       	ldi	r22, 0xFF	; 255
    1102:	0e 94 ab 02 	call	0x556	; 0x556 <Dio_vidSetPortDirection>
	Dio_vidSetPinDirection(Dio_PORTB,0,STD_HIGH);
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	60 e0       	ldi	r22, 0x00	; 0
    110a:	41 e0       	ldi	r20, 0x01	; 1
    110c:	0e 94 ba 01 	call	0x374	; 0x374 <Dio_vidSetPinDirection>
	xTaskCreate(led_blink,"led_blink",60,NULL,1,&led_Handle);
    1110:	20 e6       	ldi	r18, 0x60	; 96
    1112:	30 e0       	ldi	r19, 0x00	; 0
    1114:	89 ea       	ldi	r24, 0xA9	; 169
    1116:	98 e0       	ldi	r25, 0x08	; 8
    1118:	ed ef       	ldi	r30, 0xFD	; 253
    111a:	f3 e0       	ldi	r31, 0x03	; 3
    111c:	b9 01       	movw	r22, r18
    111e:	4c e3       	ldi	r20, 0x3C	; 60
    1120:	50 e0       	ldi	r21, 0x00	; 0
    1122:	20 e0       	ldi	r18, 0x00	; 0
    1124:	30 e0       	ldi	r19, 0x00	; 0
    1126:	01 e0       	ldi	r16, 0x01	; 1
    1128:	7f 01       	movw	r14, r30
    112a:	cc 24       	eor	r12, r12
    112c:	dd 24       	eor	r13, r13
    112e:	aa 24       	eor	r10, r10
    1130:	bb 24       	eor	r11, r11
    1132:	0e 94 41 10 	call	0x2082	; 0x2082 <xTaskGenericCreate>
    vTaskStartScheduler();
    1136:	0e 94 8b 12 	call	0x2516	; 0x2516 <vTaskStartScheduler>
	return 0;
    113a:	80 e0       	ldi	r24, 0x00	; 0
    113c:	90 e0       	ldi	r25, 0x00	; 0
}
    113e:	cf 91       	pop	r28
    1140:	df 91       	pop	r29
    1142:	0f 91       	pop	r16
    1144:	ff 90       	pop	r15
    1146:	ef 90       	pop	r14
    1148:	df 90       	pop	r13
    114a:	cf 90       	pop	r12
    114c:	bf 90       	pop	r11
    114e:	af 90       	pop	r10
    1150:	08 95       	ret

00001152 <led_blink>:

void led_blink(void * pv)
{
    1152:	df 93       	push	r29
    1154:	cf 93       	push	r28
    1156:	cd b7       	in	r28, 0x3d	; 61
    1158:	de b7       	in	r29, 0x3e	; 62
    115a:	2a 97       	sbiw	r28, 0x0a	; 10
    115c:	0f b6       	in	r0, 0x3f	; 63
    115e:	f8 94       	cli
    1160:	de bf       	out	0x3e, r29	; 62
    1162:	0f be       	out	0x3f, r0	; 63
    1164:	cd bf       	out	0x3d, r28	; 61
    1166:	9a 87       	std	Y+10, r25	; 0x0a
    1168:	89 87       	std	Y+9, r24	; 0x09
	portTickType lastcount;
	const portTickType priodicity =500;
    116a:	84 ef       	ldi	r24, 0xF4	; 244
    116c:	91 e0       	ldi	r25, 0x01	; 1
    116e:	a0 e0       	ldi	r26, 0x00	; 0
    1170:	b0 e0       	ldi	r27, 0x00	; 0
    1172:	89 83       	std	Y+1, r24	; 0x01
    1174:	9a 83       	std	Y+2, r25	; 0x02
    1176:	ab 83       	std	Y+3, r26	; 0x03
    1178:	bc 83       	std	Y+4, r27	; 0x04

	while(1)
	{
		TOGGLE_BIT(PORTB,0);
    117a:	a8 e3       	ldi	r26, 0x38	; 56
    117c:	b0 e0       	ldi	r27, 0x00	; 0
    117e:	e8 e3       	ldi	r30, 0x38	; 56
    1180:	f0 e0       	ldi	r31, 0x00	; 0
    1182:	90 81       	ld	r25, Z
    1184:	81 e0       	ldi	r24, 0x01	; 1
    1186:	89 27       	eor	r24, r25
    1188:	8c 93       	st	X, r24
		lastcount=xTaskGetTickCount();
    118a:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <xTaskGetTickCount>
    118e:	dc 01       	movw	r26, r24
    1190:	cb 01       	movw	r24, r22
    1192:	8d 83       	std	Y+5, r24	; 0x05
    1194:	9e 83       	std	Y+6, r25	; 0x06
    1196:	af 83       	std	Y+7, r26	; 0x07
    1198:	b8 87       	std	Y+8, r27	; 0x08
		vTaskDelayUntil(&lastcount,priodicity);
    119a:	ce 01       	movw	r24, r28
    119c:	05 96       	adiw	r24, 0x05	; 5
    119e:	29 81       	ldd	r18, Y+1	; 0x01
    11a0:	3a 81       	ldd	r19, Y+2	; 0x02
    11a2:	4b 81       	ldd	r20, Y+3	; 0x03
    11a4:	5c 81       	ldd	r21, Y+4	; 0x04
    11a6:	ba 01       	movw	r22, r20
    11a8:	a9 01       	movw	r20, r18
    11aa:	0e 94 94 11 	call	0x2328	; 0x2328 <vTaskDelayUntil>
    11ae:	e5 cf       	rjmp	.-54     	; 0x117a <led_blink+0x28>

000011b0 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    11b0:	df 93       	push	r29
    11b2:	cf 93       	push	r28
    11b4:	cd b7       	in	r28, 0x3d	; 61
    11b6:	de b7       	in	r29, 0x3e	; 62
    11b8:	28 97       	sbiw	r28, 0x08	; 8
    11ba:	0f b6       	in	r0, 0x3f	; 63
    11bc:	f8 94       	cli
    11be:	de bf       	out	0x3e, r29	; 62
    11c0:	0f be       	out	0x3f, r0	; 63
    11c2:	cd bf       	out	0x3d, r28	; 61
    11c4:	9c 83       	std	Y+4, r25	; 0x04
    11c6:	8b 83       	std	Y+3, r24	; 0x03
    11c8:	7e 83       	std	Y+6, r23	; 0x06
    11ca:	6d 83       	std	Y+5, r22	; 0x05
    11cc:	58 87       	std	Y+8, r21	; 0x08
    11ce:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    11d0:	eb 81       	ldd	r30, Y+3	; 0x03
    11d2:	fc 81       	ldd	r31, Y+4	; 0x04
    11d4:	81 e1       	ldi	r24, 0x11	; 17
    11d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    11d8:	8b 81       	ldd	r24, Y+3	; 0x03
    11da:	9c 81       	ldd	r25, Y+4	; 0x04
    11dc:	01 97       	sbiw	r24, 0x01	; 1
    11de:	9c 83       	std	Y+4, r25	; 0x04
    11e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    11e2:	eb 81       	ldd	r30, Y+3	; 0x03
    11e4:	fc 81       	ldd	r31, Y+4	; 0x04
    11e6:	82 e2       	ldi	r24, 0x22	; 34
    11e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    11ea:	8b 81       	ldd	r24, Y+3	; 0x03
    11ec:	9c 81       	ldd	r25, Y+4	; 0x04
    11ee:	01 97       	sbiw	r24, 0x01	; 1
    11f0:	9c 83       	std	Y+4, r25	; 0x04
    11f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    11f4:	eb 81       	ldd	r30, Y+3	; 0x03
    11f6:	fc 81       	ldd	r31, Y+4	; 0x04
    11f8:	83 e3       	ldi	r24, 0x33	; 51
    11fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    11fc:	8b 81       	ldd	r24, Y+3	; 0x03
    11fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1200:	01 97       	sbiw	r24, 0x01	; 1
    1202:	9c 83       	std	Y+4, r25	; 0x04
    1204:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    1206:	8d 81       	ldd	r24, Y+5	; 0x05
    1208:	9e 81       	ldd	r25, Y+6	; 0x06
    120a:	9a 83       	std	Y+2, r25	; 0x02
    120c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    120e:	89 81       	ldd	r24, Y+1	; 0x01
    1210:	eb 81       	ldd	r30, Y+3	; 0x03
    1212:	fc 81       	ldd	r31, Y+4	; 0x04
    1214:	80 83       	st	Z, r24
	pxTopOfStack--;
    1216:	8b 81       	ldd	r24, Y+3	; 0x03
    1218:	9c 81       	ldd	r25, Y+4	; 0x04
    121a:	01 97       	sbiw	r24, 0x01	; 1
    121c:	9c 83       	std	Y+4, r25	; 0x04
    121e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1220:	89 81       	ldd	r24, Y+1	; 0x01
    1222:	9a 81       	ldd	r25, Y+2	; 0x02
    1224:	89 2f       	mov	r24, r25
    1226:	99 27       	eor	r25, r25
    1228:	9a 83       	std	Y+2, r25	; 0x02
    122a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    122c:	89 81       	ldd	r24, Y+1	; 0x01
    122e:	eb 81       	ldd	r30, Y+3	; 0x03
    1230:	fc 81       	ldd	r31, Y+4	; 0x04
    1232:	80 83       	st	Z, r24
	pxTopOfStack--;
    1234:	8b 81       	ldd	r24, Y+3	; 0x03
    1236:	9c 81       	ldd	r25, Y+4	; 0x04
    1238:	01 97       	sbiw	r24, 0x01	; 1
    123a:	9c 83       	std	Y+4, r25	; 0x04
    123c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    123e:	eb 81       	ldd	r30, Y+3	; 0x03
    1240:	fc 81       	ldd	r31, Y+4	; 0x04
    1242:	10 82       	st	Z, r1
	pxTopOfStack--;
    1244:	8b 81       	ldd	r24, Y+3	; 0x03
    1246:	9c 81       	ldd	r25, Y+4	; 0x04
    1248:	01 97       	sbiw	r24, 0x01	; 1
    124a:	9c 83       	std	Y+4, r25	; 0x04
    124c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    124e:	eb 81       	ldd	r30, Y+3	; 0x03
    1250:	fc 81       	ldd	r31, Y+4	; 0x04
    1252:	80 e8       	ldi	r24, 0x80	; 128
    1254:	80 83       	st	Z, r24
	pxTopOfStack--;
    1256:	8b 81       	ldd	r24, Y+3	; 0x03
    1258:	9c 81       	ldd	r25, Y+4	; 0x04
    125a:	01 97       	sbiw	r24, 0x01	; 1
    125c:	9c 83       	std	Y+4, r25	; 0x04
    125e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1260:	eb 81       	ldd	r30, Y+3	; 0x03
    1262:	fc 81       	ldd	r31, Y+4	; 0x04
    1264:	10 82       	st	Z, r1
	pxTopOfStack--;
    1266:	8b 81       	ldd	r24, Y+3	; 0x03
    1268:	9c 81       	ldd	r25, Y+4	; 0x04
    126a:	01 97       	sbiw	r24, 0x01	; 1
    126c:	9c 83       	std	Y+4, r25	; 0x04
    126e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1270:	eb 81       	ldd	r30, Y+3	; 0x03
    1272:	fc 81       	ldd	r31, Y+4	; 0x04
    1274:	82 e0       	ldi	r24, 0x02	; 2
    1276:	80 83       	st	Z, r24
	pxTopOfStack--;
    1278:	8b 81       	ldd	r24, Y+3	; 0x03
    127a:	9c 81       	ldd	r25, Y+4	; 0x04
    127c:	01 97       	sbiw	r24, 0x01	; 1
    127e:	9c 83       	std	Y+4, r25	; 0x04
    1280:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1282:	eb 81       	ldd	r30, Y+3	; 0x03
    1284:	fc 81       	ldd	r31, Y+4	; 0x04
    1286:	83 e0       	ldi	r24, 0x03	; 3
    1288:	80 83       	st	Z, r24
	pxTopOfStack--;
    128a:	8b 81       	ldd	r24, Y+3	; 0x03
    128c:	9c 81       	ldd	r25, Y+4	; 0x04
    128e:	01 97       	sbiw	r24, 0x01	; 1
    1290:	9c 83       	std	Y+4, r25	; 0x04
    1292:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1294:	eb 81       	ldd	r30, Y+3	; 0x03
    1296:	fc 81       	ldd	r31, Y+4	; 0x04
    1298:	84 e0       	ldi	r24, 0x04	; 4
    129a:	80 83       	st	Z, r24
	pxTopOfStack--;
    129c:	8b 81       	ldd	r24, Y+3	; 0x03
    129e:	9c 81       	ldd	r25, Y+4	; 0x04
    12a0:	01 97       	sbiw	r24, 0x01	; 1
    12a2:	9c 83       	std	Y+4, r25	; 0x04
    12a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    12a6:	eb 81       	ldd	r30, Y+3	; 0x03
    12a8:	fc 81       	ldd	r31, Y+4	; 0x04
    12aa:	85 e0       	ldi	r24, 0x05	; 5
    12ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    12ae:	8b 81       	ldd	r24, Y+3	; 0x03
    12b0:	9c 81       	ldd	r25, Y+4	; 0x04
    12b2:	01 97       	sbiw	r24, 0x01	; 1
    12b4:	9c 83       	std	Y+4, r25	; 0x04
    12b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    12b8:	eb 81       	ldd	r30, Y+3	; 0x03
    12ba:	fc 81       	ldd	r31, Y+4	; 0x04
    12bc:	86 e0       	ldi	r24, 0x06	; 6
    12be:	80 83       	st	Z, r24
	pxTopOfStack--;
    12c0:	8b 81       	ldd	r24, Y+3	; 0x03
    12c2:	9c 81       	ldd	r25, Y+4	; 0x04
    12c4:	01 97       	sbiw	r24, 0x01	; 1
    12c6:	9c 83       	std	Y+4, r25	; 0x04
    12c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    12ca:	eb 81       	ldd	r30, Y+3	; 0x03
    12cc:	fc 81       	ldd	r31, Y+4	; 0x04
    12ce:	87 e0       	ldi	r24, 0x07	; 7
    12d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    12d2:	8b 81       	ldd	r24, Y+3	; 0x03
    12d4:	9c 81       	ldd	r25, Y+4	; 0x04
    12d6:	01 97       	sbiw	r24, 0x01	; 1
    12d8:	9c 83       	std	Y+4, r25	; 0x04
    12da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    12dc:	eb 81       	ldd	r30, Y+3	; 0x03
    12de:	fc 81       	ldd	r31, Y+4	; 0x04
    12e0:	88 e0       	ldi	r24, 0x08	; 8
    12e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    12e4:	8b 81       	ldd	r24, Y+3	; 0x03
    12e6:	9c 81       	ldd	r25, Y+4	; 0x04
    12e8:	01 97       	sbiw	r24, 0x01	; 1
    12ea:	9c 83       	std	Y+4, r25	; 0x04
    12ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    12ee:	eb 81       	ldd	r30, Y+3	; 0x03
    12f0:	fc 81       	ldd	r31, Y+4	; 0x04
    12f2:	89 e0       	ldi	r24, 0x09	; 9
    12f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    12f6:	8b 81       	ldd	r24, Y+3	; 0x03
    12f8:	9c 81       	ldd	r25, Y+4	; 0x04
    12fa:	01 97       	sbiw	r24, 0x01	; 1
    12fc:	9c 83       	std	Y+4, r25	; 0x04
    12fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1300:	eb 81       	ldd	r30, Y+3	; 0x03
    1302:	fc 81       	ldd	r31, Y+4	; 0x04
    1304:	80 e1       	ldi	r24, 0x10	; 16
    1306:	80 83       	st	Z, r24
	pxTopOfStack--;
    1308:	8b 81       	ldd	r24, Y+3	; 0x03
    130a:	9c 81       	ldd	r25, Y+4	; 0x04
    130c:	01 97       	sbiw	r24, 0x01	; 1
    130e:	9c 83       	std	Y+4, r25	; 0x04
    1310:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1312:	eb 81       	ldd	r30, Y+3	; 0x03
    1314:	fc 81       	ldd	r31, Y+4	; 0x04
    1316:	81 e1       	ldi	r24, 0x11	; 17
    1318:	80 83       	st	Z, r24
	pxTopOfStack--;
    131a:	8b 81       	ldd	r24, Y+3	; 0x03
    131c:	9c 81       	ldd	r25, Y+4	; 0x04
    131e:	01 97       	sbiw	r24, 0x01	; 1
    1320:	9c 83       	std	Y+4, r25	; 0x04
    1322:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1324:	eb 81       	ldd	r30, Y+3	; 0x03
    1326:	fc 81       	ldd	r31, Y+4	; 0x04
    1328:	82 e1       	ldi	r24, 0x12	; 18
    132a:	80 83       	st	Z, r24
	pxTopOfStack--;
    132c:	8b 81       	ldd	r24, Y+3	; 0x03
    132e:	9c 81       	ldd	r25, Y+4	; 0x04
    1330:	01 97       	sbiw	r24, 0x01	; 1
    1332:	9c 83       	std	Y+4, r25	; 0x04
    1334:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1336:	eb 81       	ldd	r30, Y+3	; 0x03
    1338:	fc 81       	ldd	r31, Y+4	; 0x04
    133a:	83 e1       	ldi	r24, 0x13	; 19
    133c:	80 83       	st	Z, r24
	pxTopOfStack--;
    133e:	8b 81       	ldd	r24, Y+3	; 0x03
    1340:	9c 81       	ldd	r25, Y+4	; 0x04
    1342:	01 97       	sbiw	r24, 0x01	; 1
    1344:	9c 83       	std	Y+4, r25	; 0x04
    1346:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1348:	eb 81       	ldd	r30, Y+3	; 0x03
    134a:	fc 81       	ldd	r31, Y+4	; 0x04
    134c:	84 e1       	ldi	r24, 0x14	; 20
    134e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1350:	8b 81       	ldd	r24, Y+3	; 0x03
    1352:	9c 81       	ldd	r25, Y+4	; 0x04
    1354:	01 97       	sbiw	r24, 0x01	; 1
    1356:	9c 83       	std	Y+4, r25	; 0x04
    1358:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    135a:	eb 81       	ldd	r30, Y+3	; 0x03
    135c:	fc 81       	ldd	r31, Y+4	; 0x04
    135e:	85 e1       	ldi	r24, 0x15	; 21
    1360:	80 83       	st	Z, r24
	pxTopOfStack--;
    1362:	8b 81       	ldd	r24, Y+3	; 0x03
    1364:	9c 81       	ldd	r25, Y+4	; 0x04
    1366:	01 97       	sbiw	r24, 0x01	; 1
    1368:	9c 83       	std	Y+4, r25	; 0x04
    136a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    136c:	eb 81       	ldd	r30, Y+3	; 0x03
    136e:	fc 81       	ldd	r31, Y+4	; 0x04
    1370:	86 e1       	ldi	r24, 0x16	; 22
    1372:	80 83       	st	Z, r24
	pxTopOfStack--;
    1374:	8b 81       	ldd	r24, Y+3	; 0x03
    1376:	9c 81       	ldd	r25, Y+4	; 0x04
    1378:	01 97       	sbiw	r24, 0x01	; 1
    137a:	9c 83       	std	Y+4, r25	; 0x04
    137c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    137e:	eb 81       	ldd	r30, Y+3	; 0x03
    1380:	fc 81       	ldd	r31, Y+4	; 0x04
    1382:	87 e1       	ldi	r24, 0x17	; 23
    1384:	80 83       	st	Z, r24
	pxTopOfStack--;
    1386:	8b 81       	ldd	r24, Y+3	; 0x03
    1388:	9c 81       	ldd	r25, Y+4	; 0x04
    138a:	01 97       	sbiw	r24, 0x01	; 1
    138c:	9c 83       	std	Y+4, r25	; 0x04
    138e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1390:	eb 81       	ldd	r30, Y+3	; 0x03
    1392:	fc 81       	ldd	r31, Y+4	; 0x04
    1394:	88 e1       	ldi	r24, 0x18	; 24
    1396:	80 83       	st	Z, r24
	pxTopOfStack--;
    1398:	8b 81       	ldd	r24, Y+3	; 0x03
    139a:	9c 81       	ldd	r25, Y+4	; 0x04
    139c:	01 97       	sbiw	r24, 0x01	; 1
    139e:	9c 83       	std	Y+4, r25	; 0x04
    13a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    13a2:	eb 81       	ldd	r30, Y+3	; 0x03
    13a4:	fc 81       	ldd	r31, Y+4	; 0x04
    13a6:	89 e1       	ldi	r24, 0x19	; 25
    13a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    13aa:	8b 81       	ldd	r24, Y+3	; 0x03
    13ac:	9c 81       	ldd	r25, Y+4	; 0x04
    13ae:	01 97       	sbiw	r24, 0x01	; 1
    13b0:	9c 83       	std	Y+4, r25	; 0x04
    13b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    13b4:	eb 81       	ldd	r30, Y+3	; 0x03
    13b6:	fc 81       	ldd	r31, Y+4	; 0x04
    13b8:	80 e2       	ldi	r24, 0x20	; 32
    13ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    13bc:	8b 81       	ldd	r24, Y+3	; 0x03
    13be:	9c 81       	ldd	r25, Y+4	; 0x04
    13c0:	01 97       	sbiw	r24, 0x01	; 1
    13c2:	9c 83       	std	Y+4, r25	; 0x04
    13c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    13c6:	eb 81       	ldd	r30, Y+3	; 0x03
    13c8:	fc 81       	ldd	r31, Y+4	; 0x04
    13ca:	81 e2       	ldi	r24, 0x21	; 33
    13cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    13ce:	8b 81       	ldd	r24, Y+3	; 0x03
    13d0:	9c 81       	ldd	r25, Y+4	; 0x04
    13d2:	01 97       	sbiw	r24, 0x01	; 1
    13d4:	9c 83       	std	Y+4, r25	; 0x04
    13d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    13d8:	eb 81       	ldd	r30, Y+3	; 0x03
    13da:	fc 81       	ldd	r31, Y+4	; 0x04
    13dc:	82 e2       	ldi	r24, 0x22	; 34
    13de:	80 83       	st	Z, r24
	pxTopOfStack--;
    13e0:	8b 81       	ldd	r24, Y+3	; 0x03
    13e2:	9c 81       	ldd	r25, Y+4	; 0x04
    13e4:	01 97       	sbiw	r24, 0x01	; 1
    13e6:	9c 83       	std	Y+4, r25	; 0x04
    13e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    13ea:	eb 81       	ldd	r30, Y+3	; 0x03
    13ec:	fc 81       	ldd	r31, Y+4	; 0x04
    13ee:	83 e2       	ldi	r24, 0x23	; 35
    13f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    13f2:	8b 81       	ldd	r24, Y+3	; 0x03
    13f4:	9c 81       	ldd	r25, Y+4	; 0x04
    13f6:	01 97       	sbiw	r24, 0x01	; 1
    13f8:	9c 83       	std	Y+4, r25	; 0x04
    13fa:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    13fc:	8f 81       	ldd	r24, Y+7	; 0x07
    13fe:	98 85       	ldd	r25, Y+8	; 0x08
    1400:	9a 83       	std	Y+2, r25	; 0x02
    1402:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1404:	89 81       	ldd	r24, Y+1	; 0x01
    1406:	eb 81       	ldd	r30, Y+3	; 0x03
    1408:	fc 81       	ldd	r31, Y+4	; 0x04
    140a:	80 83       	st	Z, r24
	pxTopOfStack--;
    140c:	8b 81       	ldd	r24, Y+3	; 0x03
    140e:	9c 81       	ldd	r25, Y+4	; 0x04
    1410:	01 97       	sbiw	r24, 0x01	; 1
    1412:	9c 83       	std	Y+4, r25	; 0x04
    1414:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1416:	89 81       	ldd	r24, Y+1	; 0x01
    1418:	9a 81       	ldd	r25, Y+2	; 0x02
    141a:	89 2f       	mov	r24, r25
    141c:	99 27       	eor	r25, r25
    141e:	9a 83       	std	Y+2, r25	; 0x02
    1420:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1422:	89 81       	ldd	r24, Y+1	; 0x01
    1424:	eb 81       	ldd	r30, Y+3	; 0x03
    1426:	fc 81       	ldd	r31, Y+4	; 0x04
    1428:	80 83       	st	Z, r24
	pxTopOfStack--;
    142a:	8b 81       	ldd	r24, Y+3	; 0x03
    142c:	9c 81       	ldd	r25, Y+4	; 0x04
    142e:	01 97       	sbiw	r24, 0x01	; 1
    1430:	9c 83       	std	Y+4, r25	; 0x04
    1432:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1434:	eb 81       	ldd	r30, Y+3	; 0x03
    1436:	fc 81       	ldd	r31, Y+4	; 0x04
    1438:	86 e2       	ldi	r24, 0x26	; 38
    143a:	80 83       	st	Z, r24
	pxTopOfStack--;
    143c:	8b 81       	ldd	r24, Y+3	; 0x03
    143e:	9c 81       	ldd	r25, Y+4	; 0x04
    1440:	01 97       	sbiw	r24, 0x01	; 1
    1442:	9c 83       	std	Y+4, r25	; 0x04
    1444:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1446:	eb 81       	ldd	r30, Y+3	; 0x03
    1448:	fc 81       	ldd	r31, Y+4	; 0x04
    144a:	87 e2       	ldi	r24, 0x27	; 39
    144c:	80 83       	st	Z, r24
	pxTopOfStack--;
    144e:	8b 81       	ldd	r24, Y+3	; 0x03
    1450:	9c 81       	ldd	r25, Y+4	; 0x04
    1452:	01 97       	sbiw	r24, 0x01	; 1
    1454:	9c 83       	std	Y+4, r25	; 0x04
    1456:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1458:	eb 81       	ldd	r30, Y+3	; 0x03
    145a:	fc 81       	ldd	r31, Y+4	; 0x04
    145c:	88 e2       	ldi	r24, 0x28	; 40
    145e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1460:	8b 81       	ldd	r24, Y+3	; 0x03
    1462:	9c 81       	ldd	r25, Y+4	; 0x04
    1464:	01 97       	sbiw	r24, 0x01	; 1
    1466:	9c 83       	std	Y+4, r25	; 0x04
    1468:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    146a:	eb 81       	ldd	r30, Y+3	; 0x03
    146c:	fc 81       	ldd	r31, Y+4	; 0x04
    146e:	89 e2       	ldi	r24, 0x29	; 41
    1470:	80 83       	st	Z, r24
	pxTopOfStack--;
    1472:	8b 81       	ldd	r24, Y+3	; 0x03
    1474:	9c 81       	ldd	r25, Y+4	; 0x04
    1476:	01 97       	sbiw	r24, 0x01	; 1
    1478:	9c 83       	std	Y+4, r25	; 0x04
    147a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    147c:	eb 81       	ldd	r30, Y+3	; 0x03
    147e:	fc 81       	ldd	r31, Y+4	; 0x04
    1480:	80 e3       	ldi	r24, 0x30	; 48
    1482:	80 83       	st	Z, r24
	pxTopOfStack--;
    1484:	8b 81       	ldd	r24, Y+3	; 0x03
    1486:	9c 81       	ldd	r25, Y+4	; 0x04
    1488:	01 97       	sbiw	r24, 0x01	; 1
    148a:	9c 83       	std	Y+4, r25	; 0x04
    148c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    148e:	eb 81       	ldd	r30, Y+3	; 0x03
    1490:	fc 81       	ldd	r31, Y+4	; 0x04
    1492:	81 e3       	ldi	r24, 0x31	; 49
    1494:	80 83       	st	Z, r24
	pxTopOfStack--;
    1496:	8b 81       	ldd	r24, Y+3	; 0x03
    1498:	9c 81       	ldd	r25, Y+4	; 0x04
    149a:	01 97       	sbiw	r24, 0x01	; 1
    149c:	9c 83       	std	Y+4, r25	; 0x04
    149e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    14a0:	8b 81       	ldd	r24, Y+3	; 0x03
    14a2:	9c 81       	ldd	r25, Y+4	; 0x04
}
    14a4:	28 96       	adiw	r28, 0x08	; 8
    14a6:	0f b6       	in	r0, 0x3f	; 63
    14a8:	f8 94       	cli
    14aa:	de bf       	out	0x3e, r29	; 62
    14ac:	0f be       	out	0x3f, r0	; 63
    14ae:	cd bf       	out	0x3d, r28	; 61
    14b0:	cf 91       	pop	r28
    14b2:	df 91       	pop	r29
    14b4:	08 95       	ret

000014b6 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    14b6:	df 93       	push	r29
    14b8:	cf 93       	push	r28
    14ba:	cd b7       	in	r28, 0x3d	; 61
    14bc:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    14be:	0e 94 4b 0b 	call	0x1696	; 0x1696 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    14c2:	a0 91 18 03 	lds	r26, 0x0318
    14c6:	b0 91 19 03 	lds	r27, 0x0319
    14ca:	cd 91       	ld	r28, X+
    14cc:	cd bf       	out	0x3d, r28	; 61
    14ce:	dd 91       	ld	r29, X+
    14d0:	de bf       	out	0x3e, r29	; 62
    14d2:	ff 91       	pop	r31
    14d4:	ef 91       	pop	r30
    14d6:	df 91       	pop	r29
    14d8:	cf 91       	pop	r28
    14da:	bf 91       	pop	r27
    14dc:	af 91       	pop	r26
    14de:	9f 91       	pop	r25
    14e0:	8f 91       	pop	r24
    14e2:	7f 91       	pop	r23
    14e4:	6f 91       	pop	r22
    14e6:	5f 91       	pop	r21
    14e8:	4f 91       	pop	r20
    14ea:	3f 91       	pop	r19
    14ec:	2f 91       	pop	r18
    14ee:	1f 91       	pop	r17
    14f0:	0f 91       	pop	r16
    14f2:	ff 90       	pop	r15
    14f4:	ef 90       	pop	r14
    14f6:	df 90       	pop	r13
    14f8:	cf 90       	pop	r12
    14fa:	bf 90       	pop	r11
    14fc:	af 90       	pop	r10
    14fe:	9f 90       	pop	r9
    1500:	8f 90       	pop	r8
    1502:	7f 90       	pop	r7
    1504:	6f 90       	pop	r6
    1506:	5f 90       	pop	r5
    1508:	4f 90       	pop	r4
    150a:	3f 90       	pop	r3
    150c:	2f 90       	pop	r2
    150e:	1f 90       	pop	r1
    1510:	0f 90       	pop	r0
    1512:	0f be       	out	0x3f, r0	; 63
    1514:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1516:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1518:	81 e0       	ldi	r24, 0x01	; 1
}
    151a:	cf 91       	pop	r28
    151c:	df 91       	pop	r29
    151e:	08 95       	ret

00001520 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1520:	df 93       	push	r29
    1522:	cf 93       	push	r28
    1524:	cd b7       	in	r28, 0x3d	; 61
    1526:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1528:	cf 91       	pop	r28
    152a:	df 91       	pop	r29
    152c:	08 95       	ret

0000152e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    152e:	0f 92       	push	r0
    1530:	0f b6       	in	r0, 0x3f	; 63
    1532:	f8 94       	cli
    1534:	0f 92       	push	r0
    1536:	1f 92       	push	r1
    1538:	11 24       	eor	r1, r1
    153a:	2f 92       	push	r2
    153c:	3f 92       	push	r3
    153e:	4f 92       	push	r4
    1540:	5f 92       	push	r5
    1542:	6f 92       	push	r6
    1544:	7f 92       	push	r7
    1546:	8f 92       	push	r8
    1548:	9f 92       	push	r9
    154a:	af 92       	push	r10
    154c:	bf 92       	push	r11
    154e:	cf 92       	push	r12
    1550:	df 92       	push	r13
    1552:	ef 92       	push	r14
    1554:	ff 92       	push	r15
    1556:	0f 93       	push	r16
    1558:	1f 93       	push	r17
    155a:	2f 93       	push	r18
    155c:	3f 93       	push	r19
    155e:	4f 93       	push	r20
    1560:	5f 93       	push	r21
    1562:	6f 93       	push	r22
    1564:	7f 93       	push	r23
    1566:	8f 93       	push	r24
    1568:	9f 93       	push	r25
    156a:	af 93       	push	r26
    156c:	bf 93       	push	r27
    156e:	cf 93       	push	r28
    1570:	df 93       	push	r29
    1572:	ef 93       	push	r30
    1574:	ff 93       	push	r31
    1576:	a0 91 18 03 	lds	r26, 0x0318
    157a:	b0 91 19 03 	lds	r27, 0x0319
    157e:	0d b6       	in	r0, 0x3d	; 61
    1580:	0d 92       	st	X+, r0
    1582:	0e b6       	in	r0, 0x3e	; 62
    1584:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1586:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    158a:	a0 91 18 03 	lds	r26, 0x0318
    158e:	b0 91 19 03 	lds	r27, 0x0319
    1592:	cd 91       	ld	r28, X+
    1594:	cd bf       	out	0x3d, r28	; 61
    1596:	dd 91       	ld	r29, X+
    1598:	de bf       	out	0x3e, r29	; 62
    159a:	ff 91       	pop	r31
    159c:	ef 91       	pop	r30
    159e:	df 91       	pop	r29
    15a0:	cf 91       	pop	r28
    15a2:	bf 91       	pop	r27
    15a4:	af 91       	pop	r26
    15a6:	9f 91       	pop	r25
    15a8:	8f 91       	pop	r24
    15aa:	7f 91       	pop	r23
    15ac:	6f 91       	pop	r22
    15ae:	5f 91       	pop	r21
    15b0:	4f 91       	pop	r20
    15b2:	3f 91       	pop	r19
    15b4:	2f 91       	pop	r18
    15b6:	1f 91       	pop	r17
    15b8:	0f 91       	pop	r16
    15ba:	ff 90       	pop	r15
    15bc:	ef 90       	pop	r14
    15be:	df 90       	pop	r13
    15c0:	cf 90       	pop	r12
    15c2:	bf 90       	pop	r11
    15c4:	af 90       	pop	r10
    15c6:	9f 90       	pop	r9
    15c8:	8f 90       	pop	r8
    15ca:	7f 90       	pop	r7
    15cc:	6f 90       	pop	r6
    15ce:	5f 90       	pop	r5
    15d0:	4f 90       	pop	r4
    15d2:	3f 90       	pop	r3
    15d4:	2f 90       	pop	r2
    15d6:	1f 90       	pop	r1
    15d8:	0f 90       	pop	r0
    15da:	0f be       	out	0x3f, r0	; 63
    15dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15de:	08 95       	ret

000015e0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    15e0:	0f 92       	push	r0
    15e2:	0f b6       	in	r0, 0x3f	; 63
    15e4:	f8 94       	cli
    15e6:	0f 92       	push	r0
    15e8:	1f 92       	push	r1
    15ea:	11 24       	eor	r1, r1
    15ec:	2f 92       	push	r2
    15ee:	3f 92       	push	r3
    15f0:	4f 92       	push	r4
    15f2:	5f 92       	push	r5
    15f4:	6f 92       	push	r6
    15f6:	7f 92       	push	r7
    15f8:	8f 92       	push	r8
    15fa:	9f 92       	push	r9
    15fc:	af 92       	push	r10
    15fe:	bf 92       	push	r11
    1600:	cf 92       	push	r12
    1602:	df 92       	push	r13
    1604:	ef 92       	push	r14
    1606:	ff 92       	push	r15
    1608:	0f 93       	push	r16
    160a:	1f 93       	push	r17
    160c:	2f 93       	push	r18
    160e:	3f 93       	push	r19
    1610:	4f 93       	push	r20
    1612:	5f 93       	push	r21
    1614:	6f 93       	push	r22
    1616:	7f 93       	push	r23
    1618:	8f 93       	push	r24
    161a:	9f 93       	push	r25
    161c:	af 93       	push	r26
    161e:	bf 93       	push	r27
    1620:	cf 93       	push	r28
    1622:	df 93       	push	r29
    1624:	ef 93       	push	r30
    1626:	ff 93       	push	r31
    1628:	a0 91 18 03 	lds	r26, 0x0318
    162c:	b0 91 19 03 	lds	r27, 0x0319
    1630:	0d b6       	in	r0, 0x3d	; 61
    1632:	0d 92       	st	X+, r0
    1634:	0e b6       	in	r0, 0x3e	; 62
    1636:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1638:	0e 94 ba 13 	call	0x2774	; 0x2774 <vTaskIncrementTick>
	vTaskSwitchContext();
    163c:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1640:	a0 91 18 03 	lds	r26, 0x0318
    1644:	b0 91 19 03 	lds	r27, 0x0319
    1648:	cd 91       	ld	r28, X+
    164a:	cd bf       	out	0x3d, r28	; 61
    164c:	dd 91       	ld	r29, X+
    164e:	de bf       	out	0x3e, r29	; 62
    1650:	ff 91       	pop	r31
    1652:	ef 91       	pop	r30
    1654:	df 91       	pop	r29
    1656:	cf 91       	pop	r28
    1658:	bf 91       	pop	r27
    165a:	af 91       	pop	r26
    165c:	9f 91       	pop	r25
    165e:	8f 91       	pop	r24
    1660:	7f 91       	pop	r23
    1662:	6f 91       	pop	r22
    1664:	5f 91       	pop	r21
    1666:	4f 91       	pop	r20
    1668:	3f 91       	pop	r19
    166a:	2f 91       	pop	r18
    166c:	1f 91       	pop	r17
    166e:	0f 91       	pop	r16
    1670:	ff 90       	pop	r15
    1672:	ef 90       	pop	r14
    1674:	df 90       	pop	r13
    1676:	cf 90       	pop	r12
    1678:	bf 90       	pop	r11
    167a:	af 90       	pop	r10
    167c:	9f 90       	pop	r9
    167e:	8f 90       	pop	r8
    1680:	7f 90       	pop	r7
    1682:	6f 90       	pop	r6
    1684:	5f 90       	pop	r5
    1686:	4f 90       	pop	r4
    1688:	3f 90       	pop	r3
    168a:	2f 90       	pop	r2
    168c:	1f 90       	pop	r1
    168e:	0f 90       	pop	r0
    1690:	0f be       	out	0x3f, r0	; 63
    1692:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1694:	08 95       	ret

00001696 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1696:	df 93       	push	r29
    1698:	cf 93       	push	r28
    169a:	00 d0       	rcall	.+0      	; 0x169c <prvSetupTimerInterrupt+0x6>
    169c:	00 d0       	rcall	.+0      	; 0x169e <prvSetupTimerInterrupt+0x8>
    169e:	00 d0       	rcall	.+0      	; 0x16a0 <prvSetupTimerInterrupt+0xa>
    16a0:	cd b7       	in	r28, 0x3d	; 61
    16a2:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    16a4:	80 e4       	ldi	r24, 0x40	; 64
    16a6:	9f e1       	ldi	r25, 0x1F	; 31
    16a8:	a0 e0       	ldi	r26, 0x00	; 0
    16aa:	b0 e0       	ldi	r27, 0x00	; 0
    16ac:	8b 83       	std	Y+3, r24	; 0x03
    16ae:	9c 83       	std	Y+4, r25	; 0x04
    16b0:	ad 83       	std	Y+5, r26	; 0x05
    16b2:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    16b4:	8b 81       	ldd	r24, Y+3	; 0x03
    16b6:	9c 81       	ldd	r25, Y+4	; 0x04
    16b8:	ad 81       	ldd	r26, Y+5	; 0x05
    16ba:	be 81       	ldd	r27, Y+6	; 0x06
    16bc:	68 94       	set
    16be:	15 f8       	bld	r1, 5
    16c0:	b6 95       	lsr	r27
    16c2:	a7 95       	ror	r26
    16c4:	97 95       	ror	r25
    16c6:	87 95       	ror	r24
    16c8:	16 94       	lsr	r1
    16ca:	d1 f7       	brne	.-12     	; 0x16c0 <prvSetupTimerInterrupt+0x2a>
    16cc:	8b 83       	std	Y+3, r24	; 0x03
    16ce:	9c 83       	std	Y+4, r25	; 0x04
    16d0:	ad 83       	std	Y+5, r26	; 0x05
    16d2:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    16d4:	8b 81       	ldd	r24, Y+3	; 0x03
    16d6:	9c 81       	ldd	r25, Y+4	; 0x04
    16d8:	ad 81       	ldd	r26, Y+5	; 0x05
    16da:	be 81       	ldd	r27, Y+6	; 0x06
    16dc:	01 97       	sbiw	r24, 0x01	; 1
    16de:	a1 09       	sbc	r26, r1
    16e0:	b1 09       	sbc	r27, r1
    16e2:	8b 83       	std	Y+3, r24	; 0x03
    16e4:	9c 83       	std	Y+4, r25	; 0x04
    16e6:	ad 83       	std	Y+5, r26	; 0x05
    16e8:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    16ea:	8b 81       	ldd	r24, Y+3	; 0x03
    16ec:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    16ee:	8b 81       	ldd	r24, Y+3	; 0x03
    16f0:	9c 81       	ldd	r25, Y+4	; 0x04
    16f2:	ad 81       	ldd	r26, Y+5	; 0x05
    16f4:	be 81       	ldd	r27, Y+6	; 0x06
    16f6:	89 2f       	mov	r24, r25
    16f8:	9a 2f       	mov	r25, r26
    16fa:	ab 2f       	mov	r26, r27
    16fc:	bb 27       	eor	r27, r27
    16fe:	8b 83       	std	Y+3, r24	; 0x03
    1700:	9c 83       	std	Y+4, r25	; 0x04
    1702:	ad 83       	std	Y+5, r26	; 0x05
    1704:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1706:	8b 81       	ldd	r24, Y+3	; 0x03
    1708:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    170a:	eb e4       	ldi	r30, 0x4B	; 75
    170c:	f0 e0       	ldi	r31, 0x00	; 0
    170e:	8a 81       	ldd	r24, Y+2	; 0x02
    1710:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1712:	ea e4       	ldi	r30, 0x4A	; 74
    1714:	f0 e0       	ldi	r31, 0x00	; 0
    1716:	89 81       	ldd	r24, Y+1	; 0x01
    1718:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    171a:	8b e0       	ldi	r24, 0x0B	; 11
    171c:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    171e:	ee e4       	ldi	r30, 0x4E	; 78
    1720:	f0 e0       	ldi	r31, 0x00	; 0
    1722:	89 81       	ldd	r24, Y+1	; 0x01
    1724:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1726:	e9 e5       	ldi	r30, 0x59	; 89
    1728:	f0 e0       	ldi	r31, 0x00	; 0
    172a:	80 81       	ld	r24, Z
    172c:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    172e:	89 81       	ldd	r24, Y+1	; 0x01
    1730:	80 61       	ori	r24, 0x10	; 16
    1732:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1734:	e9 e5       	ldi	r30, 0x59	; 89
    1736:	f0 e0       	ldi	r31, 0x00	; 0
    1738:	89 81       	ldd	r24, Y+1	; 0x01
    173a:	80 83       	st	Z, r24
}
    173c:	26 96       	adiw	r28, 0x06	; 6
    173e:	0f b6       	in	r0, 0x3f	; 63
    1740:	f8 94       	cli
    1742:	de bf       	out	0x3e, r29	; 62
    1744:	0f be       	out	0x3f, r0	; 63
    1746:	cd bf       	out	0x3d, r28	; 61
    1748:	cf 91       	pop	r28
    174a:	df 91       	pop	r29
    174c:	08 95       	ret

0000174e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    174e:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1752:	18 95       	reti

00001754 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1754:	df 93       	push	r29
    1756:	cf 93       	push	r28
    1758:	cd b7       	in	r28, 0x3d	; 61
    175a:	de b7       	in	r29, 0x3e	; 62
    175c:	28 97       	sbiw	r28, 0x08	; 8
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	de bf       	out	0x3e, r29	; 62
    1764:	0f be       	out	0x3f, r0	; 63
    1766:	cd bf       	out	0x3d, r28	; 61
    1768:	8f 83       	std	Y+7, r24	; 0x07
    176a:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    176c:	1a 82       	std	Y+2, r1	; 0x02
    176e:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1770:	8f 81       	ldd	r24, Y+7	; 0x07
    1772:	88 23       	and	r24, r24
    1774:	09 f4       	brne	.+2      	; 0x1778 <xQueueCreate+0x24>
    1776:	8c c0       	rjmp	.+280    	; 0x1890 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1778:	83 e2       	ldi	r24, 0x23	; 35
    177a:	90 e0       	ldi	r25, 0x00	; 0
    177c:	0e 94 b9 06 	call	0xd72	; 0xd72 <pvPortMalloc>
    1780:	9e 83       	std	Y+6, r25	; 0x06
    1782:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1784:	8d 81       	ldd	r24, Y+5	; 0x05
    1786:	9e 81       	ldd	r25, Y+6	; 0x06
    1788:	00 97       	sbiw	r24, 0x00	; 0
    178a:	09 f4       	brne	.+2      	; 0x178e <xQueueCreate+0x3a>
    178c:	81 c0       	rjmp	.+258    	; 0x1890 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    178e:	8f 81       	ldd	r24, Y+7	; 0x07
    1790:	28 2f       	mov	r18, r24
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	88 85       	ldd	r24, Y+8	; 0x08
    1796:	88 2f       	mov	r24, r24
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	ac 01       	movw	r20, r24
    179c:	24 9f       	mul	r18, r20
    179e:	c0 01       	movw	r24, r0
    17a0:	25 9f       	mul	r18, r21
    17a2:	90 0d       	add	r25, r0
    17a4:	34 9f       	mul	r19, r20
    17a6:	90 0d       	add	r25, r0
    17a8:	11 24       	eor	r1, r1
    17aa:	01 96       	adiw	r24, 0x01	; 1
    17ac:	9c 83       	std	Y+4, r25	; 0x04
    17ae:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    17b0:	8b 81       	ldd	r24, Y+3	; 0x03
    17b2:	9c 81       	ldd	r25, Y+4	; 0x04
    17b4:	0e 94 b9 06 	call	0xd72	; 0xd72 <pvPortMalloc>
    17b8:	ed 81       	ldd	r30, Y+5	; 0x05
    17ba:	fe 81       	ldd	r31, Y+6	; 0x06
    17bc:	91 83       	std	Z+1, r25	; 0x01
    17be:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    17c0:	ed 81       	ldd	r30, Y+5	; 0x05
    17c2:	fe 81       	ldd	r31, Y+6	; 0x06
    17c4:	80 81       	ld	r24, Z
    17c6:	91 81       	ldd	r25, Z+1	; 0x01
    17c8:	00 97       	sbiw	r24, 0x00	; 0
    17ca:	09 f4       	brne	.+2      	; 0x17ce <xQueueCreate+0x7a>
    17cc:	5d c0       	rjmp	.+186    	; 0x1888 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    17ce:	ed 81       	ldd	r30, Y+5	; 0x05
    17d0:	fe 81       	ldd	r31, Y+6	; 0x06
    17d2:	40 81       	ld	r20, Z
    17d4:	51 81       	ldd	r21, Z+1	; 0x01
    17d6:	8f 81       	ldd	r24, Y+7	; 0x07
    17d8:	28 2f       	mov	r18, r24
    17da:	30 e0       	ldi	r19, 0x00	; 0
    17dc:	88 85       	ldd	r24, Y+8	; 0x08
    17de:	88 2f       	mov	r24, r24
    17e0:	90 e0       	ldi	r25, 0x00	; 0
    17e2:	bc 01       	movw	r22, r24
    17e4:	26 9f       	mul	r18, r22
    17e6:	c0 01       	movw	r24, r0
    17e8:	27 9f       	mul	r18, r23
    17ea:	90 0d       	add	r25, r0
    17ec:	36 9f       	mul	r19, r22
    17ee:	90 0d       	add	r25, r0
    17f0:	11 24       	eor	r1, r1
    17f2:	84 0f       	add	r24, r20
    17f4:	95 1f       	adc	r25, r21
    17f6:	ed 81       	ldd	r30, Y+5	; 0x05
    17f8:	fe 81       	ldd	r31, Y+6	; 0x06
    17fa:	93 83       	std	Z+3, r25	; 0x03
    17fc:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    17fe:	ed 81       	ldd	r30, Y+5	; 0x05
    1800:	fe 81       	ldd	r31, Y+6	; 0x06
    1802:	16 8e       	std	Z+30, r1	; 0x1e
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1804:	ed 81       	ldd	r30, Y+5	; 0x05
    1806:	fe 81       	ldd	r31, Y+6	; 0x06
    1808:	80 81       	ld	r24, Z
    180a:	91 81       	ldd	r25, Z+1	; 0x01
    180c:	ed 81       	ldd	r30, Y+5	; 0x05
    180e:	fe 81       	ldd	r31, Y+6	; 0x06
    1810:	95 83       	std	Z+5, r25	; 0x05
    1812:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1814:	ed 81       	ldd	r30, Y+5	; 0x05
    1816:	fe 81       	ldd	r31, Y+6	; 0x06
    1818:	40 81       	ld	r20, Z
    181a:	51 81       	ldd	r21, Z+1	; 0x01
    181c:	8f 81       	ldd	r24, Y+7	; 0x07
    181e:	88 2f       	mov	r24, r24
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	9c 01       	movw	r18, r24
    1824:	21 50       	subi	r18, 0x01	; 1
    1826:	30 40       	sbci	r19, 0x00	; 0
    1828:	88 85       	ldd	r24, Y+8	; 0x08
    182a:	88 2f       	mov	r24, r24
    182c:	90 e0       	ldi	r25, 0x00	; 0
    182e:	bc 01       	movw	r22, r24
    1830:	26 9f       	mul	r18, r22
    1832:	c0 01       	movw	r24, r0
    1834:	27 9f       	mul	r18, r23
    1836:	90 0d       	add	r25, r0
    1838:	36 9f       	mul	r19, r22
    183a:	90 0d       	add	r25, r0
    183c:	11 24       	eor	r1, r1
    183e:	84 0f       	add	r24, r20
    1840:	95 1f       	adc	r25, r21
    1842:	ed 81       	ldd	r30, Y+5	; 0x05
    1844:	fe 81       	ldd	r31, Y+6	; 0x06
    1846:	97 83       	std	Z+7, r25	; 0x07
    1848:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    184a:	ed 81       	ldd	r30, Y+5	; 0x05
    184c:	fe 81       	ldd	r31, Y+6	; 0x06
    184e:	8f 81       	ldd	r24, Y+7	; 0x07
    1850:	87 8f       	std	Z+31, r24	; 0x1f
				pxNewQueue->uxItemSize = uxItemSize;
    1852:	ed 81       	ldd	r30, Y+5	; 0x05
    1854:	fe 81       	ldd	r31, Y+6	; 0x06
    1856:	88 85       	ldd	r24, Y+8	; 0x08
    1858:	80 a3       	std	Z+32, r24	; 0x20
				pxNewQueue->xRxLock = queueUNLOCKED;
    185a:	ed 81       	ldd	r30, Y+5	; 0x05
    185c:	fe 81       	ldd	r31, Y+6	; 0x06
    185e:	8f ef       	ldi	r24, 0xFF	; 255
    1860:	81 a3       	std	Z+33, r24	; 0x21
				pxNewQueue->xTxLock = queueUNLOCKED;
    1862:	ed 81       	ldd	r30, Y+5	; 0x05
    1864:	fe 81       	ldd	r31, Y+6	; 0x06
    1866:	8f ef       	ldi	r24, 0xFF	; 255
    1868:	82 a3       	std	Z+34, r24	; 0x22

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    186a:	8d 81       	ldd	r24, Y+5	; 0x05
    186c:	9e 81       	ldd	r25, Y+6	; 0x06
    186e:	08 96       	adiw	r24, 0x08	; 8
    1870:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1874:	8d 81       	ldd	r24, Y+5	; 0x05
    1876:	9e 81       	ldd	r25, Y+6	; 0x06
    1878:	43 96       	adiw	r24, 0x13	; 19
    187a:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    187e:	8d 81       	ldd	r24, Y+5	; 0x05
    1880:	9e 81       	ldd	r25, Y+6	; 0x06
    1882:	9a 83       	std	Y+2, r25	; 0x02
    1884:	89 83       	std	Y+1, r24	; 0x01
    1886:	04 c0       	rjmp	.+8      	; 0x1890 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1888:	8d 81       	ldd	r24, Y+5	; 0x05
    188a:	9e 81       	ldd	r25, Y+6	; 0x06
    188c:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1890:	89 81       	ldd	r24, Y+1	; 0x01
    1892:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1894:	28 96       	adiw	r28, 0x08	; 8
    1896:	0f b6       	in	r0, 0x3f	; 63
    1898:	f8 94       	cli
    189a:	de bf       	out	0x3e, r29	; 62
    189c:	0f be       	out	0x3f, r0	; 63
    189e:	cd bf       	out	0x3d, r28	; 61
    18a0:	cf 91       	pop	r28
    18a2:	df 91       	pop	r29
    18a4:	08 95       	ret

000018a6 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    18a6:	0f 93       	push	r16
    18a8:	df 93       	push	r29
    18aa:	cf 93       	push	r28
    18ac:	cd b7       	in	r28, 0x3d	; 61
    18ae:	de b7       	in	r29, 0x3e	; 62
    18b0:	60 97       	sbiw	r28, 0x10	; 16
    18b2:	0f b6       	in	r0, 0x3f	; 63
    18b4:	f8 94       	cli
    18b6:	de bf       	out	0x3e, r29	; 62
    18b8:	0f be       	out	0x3f, r0	; 63
    18ba:	cd bf       	out	0x3d, r28	; 61
    18bc:	98 87       	std	Y+8, r25	; 0x08
    18be:	8f 83       	std	Y+7, r24	; 0x07
    18c0:	7a 87       	std	Y+10, r23	; 0x0a
    18c2:	69 87       	std	Y+9, r22	; 0x09
    18c4:	2b 87       	std	Y+11, r18	; 0x0b
    18c6:	3c 87       	std	Y+12, r19	; 0x0c
    18c8:	4d 87       	std	Y+13, r20	; 0x0d
    18ca:	5e 87       	std	Y+14, r21	; 0x0e
    18cc:	0f 87       	std	Y+15, r16	; 0x0f
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    18ce:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18d0:	0f b6       	in	r0, 0x3f	; 63
    18d2:	f8 94       	cli
    18d4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    18d6:	ef 81       	ldd	r30, Y+7	; 0x07
    18d8:	f8 85       	ldd	r31, Y+8	; 0x08
    18da:	96 8d       	ldd	r25, Z+30	; 0x1e
    18dc:	ef 81       	ldd	r30, Y+7	; 0x07
    18de:	f8 85       	ldd	r31, Y+8	; 0x08
    18e0:	87 8d       	ldd	r24, Z+31	; 0x1f
    18e2:	98 17       	cp	r25, r24
    18e4:	d8 f4       	brcc	.+54     	; 0x191c <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    18e6:	8f 81       	ldd	r24, Y+7	; 0x07
    18e8:	98 85       	ldd	r25, Y+8	; 0x08
    18ea:	29 85       	ldd	r18, Y+9	; 0x09
    18ec:	3a 85       	ldd	r19, Y+10	; 0x0a
    18ee:	b9 01       	movw	r22, r18
    18f0:	4f 85       	ldd	r20, Y+15	; 0x0f
    18f2:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18f6:	ef 81       	ldd	r30, Y+7	; 0x07
    18f8:	f8 85       	ldd	r31, Y+8	; 0x08
    18fa:	83 89       	ldd	r24, Z+19	; 0x13
    18fc:	88 23       	and	r24, r24
    18fe:	49 f0       	breq	.+18     	; 0x1912 <xQueueGenericSend+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1900:	8f 81       	ldd	r24, Y+7	; 0x07
    1902:	98 85       	ldd	r25, Y+8	; 0x08
    1904:	43 96       	adiw	r24, 0x13	; 19
    1906:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskRemoveFromEventList>
    190a:	81 30       	cpi	r24, 0x01	; 1
    190c:	11 f4       	brne	.+4      	; 0x1912 <xQueueGenericSend+0x6c>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    190e:	0e 94 97 0a 	call	0x152e	; 0x152e <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1912:	0f 90       	pop	r0
    1914:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1916:	81 e0       	ldi	r24, 0x01	; 1
    1918:	88 8b       	std	Y+16, r24	; 0x10
    191a:	63 c0       	rjmp	.+198    	; 0x19e2 <xQueueGenericSend+0x13c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    191c:	8b 85       	ldd	r24, Y+11	; 0x0b
    191e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1920:	ad 85       	ldd	r26, Y+13	; 0x0d
    1922:	be 85       	ldd	r27, Y+14	; 0x0e
    1924:	00 97       	sbiw	r24, 0x00	; 0
    1926:	a1 05       	cpc	r26, r1
    1928:	b1 05       	cpc	r27, r1
    192a:	21 f4       	brne	.+8      	; 0x1934 <xQueueGenericSend+0x8e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    192c:	0f 90       	pop	r0
    192e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1930:	18 8a       	std	Y+16, r1	; 0x10
    1932:	57 c0       	rjmp	.+174    	; 0x19e2 <xQueueGenericSend+0x13c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1934:	89 81       	ldd	r24, Y+1	; 0x01
    1936:	88 23       	and	r24, r24
    1938:	31 f4       	brne	.+12     	; 0x1946 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    193a:	ce 01       	movw	r24, r28
    193c:	02 96       	adiw	r24, 0x02	; 2
    193e:	0e 94 f4 15 	call	0x2be8	; 0x2be8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1942:	81 e0       	ldi	r24, 0x01	; 1
    1944:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1946:	0f 90       	pop	r0
    1948:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    194a:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    194e:	0f b6       	in	r0, 0x3f	; 63
    1950:	f8 94       	cli
    1952:	0f 92       	push	r0
    1954:	ef 81       	ldd	r30, Y+7	; 0x07
    1956:	f8 85       	ldd	r31, Y+8	; 0x08
    1958:	81 a1       	ldd	r24, Z+33	; 0x21
    195a:	8f 3f       	cpi	r24, 0xFF	; 255
    195c:	19 f4       	brne	.+6      	; 0x1964 <xQueueGenericSend+0xbe>
    195e:	ef 81       	ldd	r30, Y+7	; 0x07
    1960:	f8 85       	ldd	r31, Y+8	; 0x08
    1962:	11 a2       	std	Z+33, r1	; 0x21
    1964:	ef 81       	ldd	r30, Y+7	; 0x07
    1966:	f8 85       	ldd	r31, Y+8	; 0x08
    1968:	82 a1       	ldd	r24, Z+34	; 0x22
    196a:	8f 3f       	cpi	r24, 0xFF	; 255
    196c:	19 f4       	brne	.+6      	; 0x1974 <xQueueGenericSend+0xce>
    196e:	ef 81       	ldd	r30, Y+7	; 0x07
    1970:	f8 85       	ldd	r31, Y+8	; 0x08
    1972:	12 a2       	std	Z+34, r1	; 0x22
    1974:	0f 90       	pop	r0
    1976:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1978:	ce 01       	movw	r24, r28
    197a:	02 96       	adiw	r24, 0x02	; 2
    197c:	9e 01       	movw	r18, r28
    197e:	25 5f       	subi	r18, 0xF5	; 245
    1980:	3f 4f       	sbci	r19, 0xFF	; 255
    1982:	b9 01       	movw	r22, r18
    1984:	0e 94 13 16 	call	0x2c26	; 0x2c26 <xTaskCheckForTimeOut>
    1988:	88 23       	and	r24, r24
    198a:	21 f5       	brne	.+72     	; 0x19d4 <xQueueGenericSend+0x12e>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    198c:	8f 81       	ldd	r24, Y+7	; 0x07
    198e:	98 85       	ldd	r25, Y+8	; 0x08
    1990:	0e 94 08 10 	call	0x2010	; 0x2010 <prvIsQueueFull>
    1994:	88 23       	and	r24, r24
    1996:	b9 f0       	breq	.+46     	; 0x19c6 <xQueueGenericSend+0x120>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1998:	8f 81       	ldd	r24, Y+7	; 0x07
    199a:	98 85       	ldd	r25, Y+8	; 0x08
    199c:	08 96       	adiw	r24, 0x08	; 8
    199e:	2b 85       	ldd	r18, Y+11	; 0x0b
    19a0:	3c 85       	ldd	r19, Y+12	; 0x0c
    19a2:	4d 85       	ldd	r20, Y+13	; 0x0d
    19a4:	5e 85       	ldd	r21, Y+14	; 0x0e
    19a6:	ba 01       	movw	r22, r20
    19a8:	a9 01       	movw	r20, r18
    19aa:	0e 94 40 15 	call	0x2a80	; 0x2a80 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    19ae:	8f 81       	ldd	r24, Y+7	; 0x07
    19b0:	98 85       	ldd	r25, Y+8	; 0x08
    19b2:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    19b6:	0e 94 de 12 	call	0x25bc	; 0x25bc <xTaskResumeAll>
    19ba:	88 23       	and	r24, r24
    19bc:	09 f0       	breq	.+2      	; 0x19c0 <xQueueGenericSend+0x11a>
    19be:	88 cf       	rjmp	.-240    	; 0x18d0 <xQueueGenericSend+0x2a>
				{
					portYIELD_WITHIN_API();
    19c0:	0e 94 97 0a 	call	0x152e	; 0x152e <vPortYield>
    19c4:	85 cf       	rjmp	.-246    	; 0x18d0 <xQueueGenericSend+0x2a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    19c6:	8f 81       	ldd	r24, Y+7	; 0x07
    19c8:	98 85       	ldd	r25, Y+8	; 0x08
    19ca:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19ce:	0e 94 de 12 	call	0x25bc	; 0x25bc <xTaskResumeAll>
    19d2:	7e cf       	rjmp	.-260    	; 0x18d0 <xQueueGenericSend+0x2a>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    19d4:	8f 81       	ldd	r24, Y+7	; 0x07
    19d6:	98 85       	ldd	r25, Y+8	; 0x08
    19d8:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19dc:	0e 94 de 12 	call	0x25bc	; 0x25bc <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    19e0:	18 8a       	std	Y+16, r1	; 0x10
    19e2:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    19e4:	60 96       	adiw	r28, 0x10	; 16
    19e6:	0f b6       	in	r0, 0x3f	; 63
    19e8:	f8 94       	cli
    19ea:	de bf       	out	0x3e, r29	; 62
    19ec:	0f be       	out	0x3f, r0	; 63
    19ee:	cd bf       	out	0x3d, r28	; 61
    19f0:	cf 91       	pop	r28
    19f2:	df 91       	pop	r29
    19f4:	0f 91       	pop	r16
    19f6:	08 95       	ret

000019f8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    19f8:	df 93       	push	r29
    19fa:	cf 93       	push	r28
    19fc:	cd b7       	in	r28, 0x3d	; 61
    19fe:	de b7       	in	r29, 0x3e	; 62
    1a00:	29 97       	sbiw	r28, 0x09	; 9
    1a02:	0f b6       	in	r0, 0x3f	; 63
    1a04:	f8 94       	cli
    1a06:	de bf       	out	0x3e, r29	; 62
    1a08:	0f be       	out	0x3f, r0	; 63
    1a0a:	cd bf       	out	0x3d, r28	; 61
    1a0c:	9c 83       	std	Y+4, r25	; 0x04
    1a0e:	8b 83       	std	Y+3, r24	; 0x03
    1a10:	7e 83       	std	Y+6, r23	; 0x06
    1a12:	6d 83       	std	Y+5, r22	; 0x05
    1a14:	58 87       	std	Y+8, r21	; 0x08
    1a16:	4f 83       	std	Y+7, r20	; 0x07
    1a18:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a1a:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a20:	96 8d       	ldd	r25, Z+30	; 0x1e
    1a22:	eb 81       	ldd	r30, Y+3	; 0x03
    1a24:	fc 81       	ldd	r31, Y+4	; 0x04
    1a26:	87 8d       	ldd	r24, Z+31	; 0x1f
    1a28:	98 17       	cp	r25, r24
    1a2a:	40 f5       	brcc	.+80     	; 0x1a7c <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a2e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a30:	2d 81       	ldd	r18, Y+5	; 0x05
    1a32:	3e 81       	ldd	r19, Y+6	; 0x06
    1a34:	b9 01       	movw	r22, r18
    1a36:	49 85       	ldd	r20, Y+9	; 0x09
    1a38:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1a3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a40:	82 a1       	ldd	r24, Z+34	; 0x22
    1a42:	8f 3f       	cpi	r24, 0xFF	; 255
    1a44:	89 f4       	brne	.+34     	; 0x1a68 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a46:	eb 81       	ldd	r30, Y+3	; 0x03
    1a48:	fc 81       	ldd	r31, Y+4	; 0x04
    1a4a:	83 89       	ldd	r24, Z+19	; 0x13
    1a4c:	88 23       	and	r24, r24
    1a4e:	99 f0       	breq	.+38     	; 0x1a76 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a50:	8b 81       	ldd	r24, Y+3	; 0x03
    1a52:	9c 81       	ldd	r25, Y+4	; 0x04
    1a54:	43 96       	adiw	r24, 0x13	; 19
    1a56:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskRemoveFromEventList>
    1a5a:	88 23       	and	r24, r24
    1a5c:	61 f0       	breq	.+24     	; 0x1a76 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1a5e:	ef 81       	ldd	r30, Y+7	; 0x07
    1a60:	f8 85       	ldd	r31, Y+8	; 0x08
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	80 83       	st	Z, r24
    1a66:	07 c0       	rjmp	.+14     	; 0x1a76 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1a68:	eb 81       	ldd	r30, Y+3	; 0x03
    1a6a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a6c:	82 a1       	ldd	r24, Z+34	; 0x22
    1a6e:	8f 5f       	subi	r24, 0xFF	; 255
    1a70:	eb 81       	ldd	r30, Y+3	; 0x03
    1a72:	fc 81       	ldd	r31, Y+4	; 0x04
    1a74:	82 a3       	std	Z+34, r24	; 0x22
			}

			xReturn = pdPASS;
    1a76:	81 e0       	ldi	r24, 0x01	; 1
    1a78:	8a 83       	std	Y+2, r24	; 0x02
    1a7a:	01 c0       	rjmp	.+2      	; 0x1a7e <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a7c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1a7e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1a80:	29 96       	adiw	r28, 0x09	; 9
    1a82:	0f b6       	in	r0, 0x3f	; 63
    1a84:	f8 94       	cli
    1a86:	de bf       	out	0x3e, r29	; 62
    1a88:	0f be       	out	0x3f, r0	; 63
    1a8a:	cd bf       	out	0x3d, r28	; 61
    1a8c:	cf 91       	pop	r28
    1a8e:	df 91       	pop	r29
    1a90:	08 95       	ret

00001a92 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1a92:	0f 93       	push	r16
    1a94:	df 93       	push	r29
    1a96:	cf 93       	push	r28
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
    1a9c:	62 97       	sbiw	r28, 0x12	; 18
    1a9e:	0f b6       	in	r0, 0x3f	; 63
    1aa0:	f8 94       	cli
    1aa2:	de bf       	out	0x3e, r29	; 62
    1aa4:	0f be       	out	0x3f, r0	; 63
    1aa6:	cd bf       	out	0x3d, r28	; 61
    1aa8:	9a 87       	std	Y+10, r25	; 0x0a
    1aaa:	89 87       	std	Y+9, r24	; 0x09
    1aac:	7c 87       	std	Y+12, r23	; 0x0c
    1aae:	6b 87       	std	Y+11, r22	; 0x0b
    1ab0:	2d 87       	std	Y+13, r18	; 0x0d
    1ab2:	3e 87       	std	Y+14, r19	; 0x0e
    1ab4:	4f 87       	std	Y+15, r20	; 0x0f
    1ab6:	58 8b       	std	Y+16, r21	; 0x10
    1ab8:	09 8b       	std	Y+17, r16	; 0x11
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1aba:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1ac2:	e9 85       	ldd	r30, Y+9	; 0x09
    1ac4:	fa 85       	ldd	r31, Y+10	; 0x0a
    1ac6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ac8:	88 23       	and	r24, r24
    1aca:	09 f4       	brne	.+2      	; 0x1ace <xQueueGenericReceive+0x3c>
    1acc:	3f c0       	rjmp	.+126    	; 0x1b4c <xQueueGenericReceive+0xba>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1ace:	e9 85       	ldd	r30, Y+9	; 0x09
    1ad0:	fa 85       	ldd	r31, Y+10	; 0x0a
    1ad2:	86 81       	ldd	r24, Z+6	; 0x06
    1ad4:	97 81       	ldd	r25, Z+7	; 0x07
    1ad6:	9a 83       	std	Y+2, r25	; 0x02
    1ad8:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ada:	89 85       	ldd	r24, Y+9	; 0x09
    1adc:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ade:	2b 85       	ldd	r18, Y+11	; 0x0b
    1ae0:	3c 85       	ldd	r19, Y+12	; 0x0c
    1ae2:	b9 01       	movw	r22, r18
    1ae4:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1ae8:	89 89       	ldd	r24, Y+17	; 0x11
    1aea:	88 23       	and	r24, r24
    1aec:	b1 f4       	brne	.+44     	; 0x1b1a <xQueueGenericReceive+0x88>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1aee:	e9 85       	ldd	r30, Y+9	; 0x09
    1af0:	fa 85       	ldd	r31, Y+10	; 0x0a
    1af2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1af4:	81 50       	subi	r24, 0x01	; 1
    1af6:	e9 85       	ldd	r30, Y+9	; 0x09
    1af8:	fa 85       	ldd	r31, Y+10	; 0x0a
    1afa:	86 8f       	std	Z+30, r24	; 0x1e
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1afc:	e9 85       	ldd	r30, Y+9	; 0x09
    1afe:	fa 85       	ldd	r31, Y+10	; 0x0a
    1b00:	80 85       	ldd	r24, Z+8	; 0x08
    1b02:	88 23       	and	r24, r24
    1b04:	f1 f0       	breq	.+60     	; 0x1b42 <xQueueGenericReceive+0xb0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1b06:	89 85       	ldd	r24, Y+9	; 0x09
    1b08:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b0a:	08 96       	adiw	r24, 0x08	; 8
    1b0c:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskRemoveFromEventList>
    1b10:	81 30       	cpi	r24, 0x01	; 1
    1b12:	b9 f4       	brne	.+46     	; 0x1b42 <xQueueGenericReceive+0xb0>
						{
							portYIELD_WITHIN_API();
    1b14:	0e 94 97 0a 	call	0x152e	; 0x152e <vPortYield>
    1b18:	14 c0       	rjmp	.+40     	; 0x1b42 <xQueueGenericReceive+0xb0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1b1a:	e9 85       	ldd	r30, Y+9	; 0x09
    1b1c:	fa 85       	ldd	r31, Y+10	; 0x0a
    1b1e:	89 81       	ldd	r24, Y+1	; 0x01
    1b20:	9a 81       	ldd	r25, Y+2	; 0x02
    1b22:	97 83       	std	Z+7, r25	; 0x07
    1b24:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b26:	e9 85       	ldd	r30, Y+9	; 0x09
    1b28:	fa 85       	ldd	r31, Y+10	; 0x0a
    1b2a:	83 89       	ldd	r24, Z+19	; 0x13
    1b2c:	88 23       	and	r24, r24
    1b2e:	49 f0       	breq	.+18     	; 0x1b42 <xQueueGenericReceive+0xb0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b30:	89 85       	ldd	r24, Y+9	; 0x09
    1b32:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b34:	43 96       	adiw	r24, 0x13	; 19
    1b36:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskRemoveFromEventList>
    1b3a:	88 23       	and	r24, r24
    1b3c:	11 f0       	breq	.+4      	; 0x1b42 <xQueueGenericReceive+0xb0>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1b3e:	0e 94 97 0a 	call	0x152e	; 0x152e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1b42:	0f 90       	pop	r0
    1b44:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b46:	81 e0       	ldi	r24, 0x01	; 1
    1b48:	8a 8b       	std	Y+18, r24	; 0x12
    1b4a:	63 c0       	rjmp	.+198    	; 0x1c12 <xQueueGenericReceive+0x180>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1b4c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b4e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b50:	af 85       	ldd	r26, Y+15	; 0x0f
    1b52:	b8 89       	ldd	r27, Y+16	; 0x10
    1b54:	00 97       	sbiw	r24, 0x00	; 0
    1b56:	a1 05       	cpc	r26, r1
    1b58:	b1 05       	cpc	r27, r1
    1b5a:	21 f4       	brne	.+8      	; 0x1b64 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b5c:	0f 90       	pop	r0
    1b5e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1b60:	1a 8a       	std	Y+18, r1	; 0x12
    1b62:	57 c0       	rjmp	.+174    	; 0x1c12 <xQueueGenericReceive+0x180>
				}
				else if( xEntryTimeSet == pdFALSE )
    1b64:	8b 81       	ldd	r24, Y+3	; 0x03
    1b66:	88 23       	and	r24, r24
    1b68:	31 f4       	brne	.+12     	; 0x1b76 <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1b6a:	ce 01       	movw	r24, r28
    1b6c:	04 96       	adiw	r24, 0x04	; 4
    1b6e:	0e 94 f4 15 	call	0x2be8	; 0x2be8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1b72:	81 e0       	ldi	r24, 0x01	; 1
    1b74:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1b76:	0f 90       	pop	r0
    1b78:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b7a:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b7e:	0f b6       	in	r0, 0x3f	; 63
    1b80:	f8 94       	cli
    1b82:	0f 92       	push	r0
    1b84:	e9 85       	ldd	r30, Y+9	; 0x09
    1b86:	fa 85       	ldd	r31, Y+10	; 0x0a
    1b88:	81 a1       	ldd	r24, Z+33	; 0x21
    1b8a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b8c:	19 f4       	brne	.+6      	; 0x1b94 <xQueueGenericReceive+0x102>
    1b8e:	e9 85       	ldd	r30, Y+9	; 0x09
    1b90:	fa 85       	ldd	r31, Y+10	; 0x0a
    1b92:	11 a2       	std	Z+33, r1	; 0x21
    1b94:	e9 85       	ldd	r30, Y+9	; 0x09
    1b96:	fa 85       	ldd	r31, Y+10	; 0x0a
    1b98:	82 a1       	ldd	r24, Z+34	; 0x22
    1b9a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b9c:	19 f4       	brne	.+6      	; 0x1ba4 <xQueueGenericReceive+0x112>
    1b9e:	e9 85       	ldd	r30, Y+9	; 0x09
    1ba0:	fa 85       	ldd	r31, Y+10	; 0x0a
    1ba2:	12 a2       	std	Z+34, r1	; 0x22
    1ba4:	0f 90       	pop	r0
    1ba6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ba8:	ce 01       	movw	r24, r28
    1baa:	04 96       	adiw	r24, 0x04	; 4
    1bac:	9e 01       	movw	r18, r28
    1bae:	23 5f       	subi	r18, 0xF3	; 243
    1bb0:	3f 4f       	sbci	r19, 0xFF	; 255
    1bb2:	b9 01       	movw	r22, r18
    1bb4:	0e 94 13 16 	call	0x2c26	; 0x2c26 <xTaskCheckForTimeOut>
    1bb8:	88 23       	and	r24, r24
    1bba:	21 f5       	brne	.+72     	; 0x1c04 <xQueueGenericReceive+0x172>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1bbc:	89 85       	ldd	r24, Y+9	; 0x09
    1bbe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bc0:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <prvIsQueueEmpty>
    1bc4:	88 23       	and	r24, r24
    1bc6:	b9 f0       	breq	.+46     	; 0x1bf6 <xQueueGenericReceive+0x164>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bc8:	89 85       	ldd	r24, Y+9	; 0x09
    1bca:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bcc:	43 96       	adiw	r24, 0x13	; 19
    1bce:	2d 85       	ldd	r18, Y+13	; 0x0d
    1bd0:	3e 85       	ldd	r19, Y+14	; 0x0e
    1bd2:	4f 85       	ldd	r20, Y+15	; 0x0f
    1bd4:	58 89       	ldd	r21, Y+16	; 0x10
    1bd6:	ba 01       	movw	r22, r20
    1bd8:	a9 01       	movw	r20, r18
    1bda:	0e 94 40 15 	call	0x2a80	; 0x2a80 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1bde:	89 85       	ldd	r24, Y+9	; 0x09
    1be0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1be2:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1be6:	0e 94 de 12 	call	0x25bc	; 0x25bc <xTaskResumeAll>
    1bea:	88 23       	and	r24, r24
    1bec:	09 f0       	breq	.+2      	; 0x1bf0 <xQueueGenericReceive+0x15e>
    1bee:	66 cf       	rjmp	.-308    	; 0x1abc <xQueueGenericReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1bf0:	0e 94 97 0a 	call	0x152e	; 0x152e <vPortYield>
    1bf4:	63 cf       	rjmp	.-314    	; 0x1abc <xQueueGenericReceive+0x2a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1bf6:	89 85       	ldd	r24, Y+9	; 0x09
    1bf8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bfa:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1bfe:	0e 94 de 12 	call	0x25bc	; 0x25bc <xTaskResumeAll>
    1c02:	5c cf       	rjmp	.-328    	; 0x1abc <xQueueGenericReceive+0x2a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1c04:	89 85       	ldd	r24, Y+9	; 0x09
    1c06:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c08:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c0c:	0e 94 de 12 	call	0x25bc	; 0x25bc <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1c10:	1a 8a       	std	Y+18, r1	; 0x12
    1c12:	8a 89       	ldd	r24, Y+18	; 0x12
		}
	}
}
    1c14:	62 96       	adiw	r28, 0x12	; 18
    1c16:	0f b6       	in	r0, 0x3f	; 63
    1c18:	f8 94       	cli
    1c1a:	de bf       	out	0x3e, r29	; 62
    1c1c:	0f be       	out	0x3f, r0	; 63
    1c1e:	cd bf       	out	0x3d, r28	; 61
    1c20:	cf 91       	pop	r28
    1c22:	df 91       	pop	r29
    1c24:	0f 91       	pop	r16
    1c26:	08 95       	ret

00001c28 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1c28:	df 93       	push	r29
    1c2a:	cf 93       	push	r28
    1c2c:	cd b7       	in	r28, 0x3d	; 61
    1c2e:	de b7       	in	r29, 0x3e	; 62
    1c30:	28 97       	sbiw	r28, 0x08	; 8
    1c32:	0f b6       	in	r0, 0x3f	; 63
    1c34:	f8 94       	cli
    1c36:	de bf       	out	0x3e, r29	; 62
    1c38:	0f be       	out	0x3f, r0	; 63
    1c3a:	cd bf       	out	0x3d, r28	; 61
    1c3c:	9c 83       	std	Y+4, r25	; 0x04
    1c3e:	8b 83       	std	Y+3, r24	; 0x03
    1c40:	7e 83       	std	Y+6, r23	; 0x06
    1c42:	6d 83       	std	Y+5, r22	; 0x05
    1c44:	58 87       	std	Y+8, r21	; 0x08
    1c46:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1c48:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1c4a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c4c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c4e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c50:	88 23       	and	r24, r24
    1c52:	71 f1       	breq	.+92     	; 0x1cb0 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c54:	8b 81       	ldd	r24, Y+3	; 0x03
    1c56:	9c 81       	ldd	r25, Y+4	; 0x04
    1c58:	2d 81       	ldd	r18, Y+5	; 0x05
    1c5a:	3e 81       	ldd	r19, Y+6	; 0x06
    1c5c:	b9 01       	movw	r22, r18
    1c5e:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1c62:	eb 81       	ldd	r30, Y+3	; 0x03
    1c64:	fc 81       	ldd	r31, Y+4	; 0x04
    1c66:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c68:	81 50       	subi	r24, 0x01	; 1
    1c6a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c6c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c6e:	86 8f       	std	Z+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1c70:	eb 81       	ldd	r30, Y+3	; 0x03
    1c72:	fc 81       	ldd	r31, Y+4	; 0x04
    1c74:	81 a1       	ldd	r24, Z+33	; 0x21
    1c76:	8f 3f       	cpi	r24, 0xFF	; 255
    1c78:	89 f4       	brne	.+34     	; 0x1c9c <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c7e:	80 85       	ldd	r24, Z+8	; 0x08
    1c80:	88 23       	and	r24, r24
    1c82:	99 f0       	breq	.+38     	; 0x1caa <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c84:	8b 81       	ldd	r24, Y+3	; 0x03
    1c86:	9c 81       	ldd	r25, Y+4	; 0x04
    1c88:	08 96       	adiw	r24, 0x08	; 8
    1c8a:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskRemoveFromEventList>
    1c8e:	88 23       	and	r24, r24
    1c90:	61 f0       	breq	.+24     	; 0x1caa <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1c92:	ef 81       	ldd	r30, Y+7	; 0x07
    1c94:	f8 85       	ldd	r31, Y+8	; 0x08
    1c96:	81 e0       	ldi	r24, 0x01	; 1
    1c98:	80 83       	st	Z, r24
    1c9a:	07 c0       	rjmp	.+14     	; 0x1caa <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca0:	81 a1       	ldd	r24, Z+33	; 0x21
    1ca2:	8f 5f       	subi	r24, 0xFF	; 255
    1ca4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ca6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca8:	81 a3       	std	Z+33, r24	; 0x21
			}

			xReturn = pdPASS;
    1caa:	81 e0       	ldi	r24, 0x01	; 1
    1cac:	8a 83       	std	Y+2, r24	; 0x02
    1cae:	01 c0       	rjmp	.+2      	; 0x1cb2 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1cb0:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1cb2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1cb4:	28 96       	adiw	r28, 0x08	; 8
    1cb6:	0f b6       	in	r0, 0x3f	; 63
    1cb8:	f8 94       	cli
    1cba:	de bf       	out	0x3e, r29	; 62
    1cbc:	0f be       	out	0x3f, r0	; 63
    1cbe:	cd bf       	out	0x3d, r28	; 61
    1cc0:	cf 91       	pop	r28
    1cc2:	df 91       	pop	r29
    1cc4:	08 95       	ret

00001cc6 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1cc6:	df 93       	push	r29
    1cc8:	cf 93       	push	r28
    1cca:	00 d0       	rcall	.+0      	; 0x1ccc <uxQueueMessagesWaiting+0x6>
    1ccc:	0f 92       	push	r0
    1cce:	cd b7       	in	r28, 0x3d	; 61
    1cd0:	de b7       	in	r29, 0x3e	; 62
    1cd2:	9b 83       	std	Y+3, r25	; 0x03
    1cd4:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1cd6:	0f b6       	in	r0, 0x3f	; 63
    1cd8:	f8 94       	cli
    1cda:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1cdc:	ea 81       	ldd	r30, Y+2	; 0x02
    1cde:	fb 81       	ldd	r31, Y+3	; 0x03
    1ce0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ce2:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1ce4:	0f 90       	pop	r0
    1ce6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1ce8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1cea:	0f 90       	pop	r0
    1cec:	0f 90       	pop	r0
    1cee:	0f 90       	pop	r0
    1cf0:	cf 91       	pop	r28
    1cf2:	df 91       	pop	r29
    1cf4:	08 95       	ret

00001cf6 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1cf6:	df 93       	push	r29
    1cf8:	cf 93       	push	r28
    1cfa:	00 d0       	rcall	.+0      	; 0x1cfc <uxQueueMessagesWaitingFromISR+0x6>
    1cfc:	0f 92       	push	r0
    1cfe:	cd b7       	in	r28, 0x3d	; 61
    1d00:	de b7       	in	r29, 0x3e	; 62
    1d02:	9b 83       	std	Y+3, r25	; 0x03
    1d04:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1d06:	ea 81       	ldd	r30, Y+2	; 0x02
    1d08:	fb 81       	ldd	r31, Y+3	; 0x03
    1d0a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d0c:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1d0e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d10:	0f 90       	pop	r0
    1d12:	0f 90       	pop	r0
    1d14:	0f 90       	pop	r0
    1d16:	cf 91       	pop	r28
    1d18:	df 91       	pop	r29
    1d1a:	08 95       	ret

00001d1c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1d1c:	df 93       	push	r29
    1d1e:	cf 93       	push	r28
    1d20:	00 d0       	rcall	.+0      	; 0x1d22 <vQueueDelete+0x6>
    1d22:	cd b7       	in	r28, 0x3d	; 61
    1d24:	de b7       	in	r29, 0x3e	; 62
    1d26:	9a 83       	std	Y+2, r25	; 0x02
    1d28:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1d2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d2e:	80 81       	ld	r24, Z
    1d30:	91 81       	ldd	r25, Z+1	; 0x01
    1d32:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortFree>
	vPortFree( pxQueue );
    1d36:	89 81       	ldd	r24, Y+1	; 0x01
    1d38:	9a 81       	ldd	r25, Y+2	; 0x02
    1d3a:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortFree>
}
    1d3e:	0f 90       	pop	r0
    1d40:	0f 90       	pop	r0
    1d42:	cf 91       	pop	r28
    1d44:	df 91       	pop	r29
    1d46:	08 95       	ret

00001d48 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1d48:	df 93       	push	r29
    1d4a:	cf 93       	push	r28
    1d4c:	00 d0       	rcall	.+0      	; 0x1d4e <prvCopyDataToQueue+0x6>
    1d4e:	00 d0       	rcall	.+0      	; 0x1d50 <prvCopyDataToQueue+0x8>
    1d50:	0f 92       	push	r0
    1d52:	cd b7       	in	r28, 0x3d	; 61
    1d54:	de b7       	in	r29, 0x3e	; 62
    1d56:	9a 83       	std	Y+2, r25	; 0x02
    1d58:	89 83       	std	Y+1, r24	; 0x01
    1d5a:	7c 83       	std	Y+4, r23	; 0x04
    1d5c:	6b 83       	std	Y+3, r22	; 0x03
    1d5e:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1d60:	e9 81       	ldd	r30, Y+1	; 0x01
    1d62:	fa 81       	ldd	r31, Y+2	; 0x02
    1d64:	80 a1       	ldd	r24, Z+32	; 0x20
    1d66:	88 23       	and	r24, r24
    1d68:	09 f4       	brne	.+2      	; 0x1d6c <prvCopyDataToQueue+0x24>
    1d6a:	74 c0       	rjmp	.+232    	; 0x1e54 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1d6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d6e:	88 23       	and	r24, r24
    1d70:	99 f5       	brne	.+102    	; 0x1dd8 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1d72:	e9 81       	ldd	r30, Y+1	; 0x01
    1d74:	fa 81       	ldd	r31, Y+2	; 0x02
    1d76:	64 81       	ldd	r22, Z+4	; 0x04
    1d78:	75 81       	ldd	r23, Z+5	; 0x05
    1d7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d7e:	80 a1       	ldd	r24, Z+32	; 0x20
    1d80:	48 2f       	mov	r20, r24
    1d82:	50 e0       	ldi	r21, 0x00	; 0
    1d84:	2b 81       	ldd	r18, Y+3	; 0x03
    1d86:	3c 81       	ldd	r19, Y+4	; 0x04
    1d88:	cb 01       	movw	r24, r22
    1d8a:	b9 01       	movw	r22, r18
    1d8c:	0e 94 63 18 	call	0x30c6	; 0x30c6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1d90:	e9 81       	ldd	r30, Y+1	; 0x01
    1d92:	fa 81       	ldd	r31, Y+2	; 0x02
    1d94:	24 81       	ldd	r18, Z+4	; 0x04
    1d96:	35 81       	ldd	r19, Z+5	; 0x05
    1d98:	e9 81       	ldd	r30, Y+1	; 0x01
    1d9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d9c:	80 a1       	ldd	r24, Z+32	; 0x20
    1d9e:	88 2f       	mov	r24, r24
    1da0:	90 e0       	ldi	r25, 0x00	; 0
    1da2:	82 0f       	add	r24, r18
    1da4:	93 1f       	adc	r25, r19
    1da6:	e9 81       	ldd	r30, Y+1	; 0x01
    1da8:	fa 81       	ldd	r31, Y+2	; 0x02
    1daa:	95 83       	std	Z+5, r25	; 0x05
    1dac:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1dae:	e9 81       	ldd	r30, Y+1	; 0x01
    1db0:	fa 81       	ldd	r31, Y+2	; 0x02
    1db2:	24 81       	ldd	r18, Z+4	; 0x04
    1db4:	35 81       	ldd	r19, Z+5	; 0x05
    1db6:	e9 81       	ldd	r30, Y+1	; 0x01
    1db8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dba:	82 81       	ldd	r24, Z+2	; 0x02
    1dbc:	93 81       	ldd	r25, Z+3	; 0x03
    1dbe:	28 17       	cp	r18, r24
    1dc0:	39 07       	cpc	r19, r25
    1dc2:	08 f4       	brcc	.+2      	; 0x1dc6 <prvCopyDataToQueue+0x7e>
    1dc4:	47 c0       	rjmp	.+142    	; 0x1e54 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1dc6:	e9 81       	ldd	r30, Y+1	; 0x01
    1dc8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dca:	80 81       	ld	r24, Z
    1dcc:	91 81       	ldd	r25, Z+1	; 0x01
    1dce:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd0:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd2:	95 83       	std	Z+5, r25	; 0x05
    1dd4:	84 83       	std	Z+4, r24	; 0x04
    1dd6:	3e c0       	rjmp	.+124    	; 0x1e54 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1dd8:	e9 81       	ldd	r30, Y+1	; 0x01
    1dda:	fa 81       	ldd	r31, Y+2	; 0x02
    1ddc:	66 81       	ldd	r22, Z+6	; 0x06
    1dde:	77 81       	ldd	r23, Z+7	; 0x07
    1de0:	e9 81       	ldd	r30, Y+1	; 0x01
    1de2:	fa 81       	ldd	r31, Y+2	; 0x02
    1de4:	80 a1       	ldd	r24, Z+32	; 0x20
    1de6:	48 2f       	mov	r20, r24
    1de8:	50 e0       	ldi	r21, 0x00	; 0
    1dea:	2b 81       	ldd	r18, Y+3	; 0x03
    1dec:	3c 81       	ldd	r19, Y+4	; 0x04
    1dee:	cb 01       	movw	r24, r22
    1df0:	b9 01       	movw	r22, r18
    1df2:	0e 94 63 18 	call	0x30c6	; 0x30c6 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1df6:	e9 81       	ldd	r30, Y+1	; 0x01
    1df8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dfa:	26 81       	ldd	r18, Z+6	; 0x06
    1dfc:	37 81       	ldd	r19, Z+7	; 0x07
    1dfe:	e9 81       	ldd	r30, Y+1	; 0x01
    1e00:	fa 81       	ldd	r31, Y+2	; 0x02
    1e02:	80 a1       	ldd	r24, Z+32	; 0x20
    1e04:	88 2f       	mov	r24, r24
    1e06:	90 e0       	ldi	r25, 0x00	; 0
    1e08:	90 95       	com	r25
    1e0a:	81 95       	neg	r24
    1e0c:	9f 4f       	sbci	r25, 0xFF	; 255
    1e0e:	82 0f       	add	r24, r18
    1e10:	93 1f       	adc	r25, r19
    1e12:	e9 81       	ldd	r30, Y+1	; 0x01
    1e14:	fa 81       	ldd	r31, Y+2	; 0x02
    1e16:	97 83       	std	Z+7, r25	; 0x07
    1e18:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e1e:	26 81       	ldd	r18, Z+6	; 0x06
    1e20:	37 81       	ldd	r19, Z+7	; 0x07
    1e22:	e9 81       	ldd	r30, Y+1	; 0x01
    1e24:	fa 81       	ldd	r31, Y+2	; 0x02
    1e26:	80 81       	ld	r24, Z
    1e28:	91 81       	ldd	r25, Z+1	; 0x01
    1e2a:	28 17       	cp	r18, r24
    1e2c:	39 07       	cpc	r19, r25
    1e2e:	90 f4       	brcc	.+36     	; 0x1e54 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1e30:	e9 81       	ldd	r30, Y+1	; 0x01
    1e32:	fa 81       	ldd	r31, Y+2	; 0x02
    1e34:	22 81       	ldd	r18, Z+2	; 0x02
    1e36:	33 81       	ldd	r19, Z+3	; 0x03
    1e38:	e9 81       	ldd	r30, Y+1	; 0x01
    1e3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e3c:	80 a1       	ldd	r24, Z+32	; 0x20
    1e3e:	88 2f       	mov	r24, r24
    1e40:	90 e0       	ldi	r25, 0x00	; 0
    1e42:	90 95       	com	r25
    1e44:	81 95       	neg	r24
    1e46:	9f 4f       	sbci	r25, 0xFF	; 255
    1e48:	82 0f       	add	r24, r18
    1e4a:	93 1f       	adc	r25, r19
    1e4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e50:	97 83       	std	Z+7, r25	; 0x07
    1e52:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1e54:	e9 81       	ldd	r30, Y+1	; 0x01
    1e56:	fa 81       	ldd	r31, Y+2	; 0x02
    1e58:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e5a:	8f 5f       	subi	r24, 0xFF	; 255
    1e5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e60:	86 8f       	std	Z+30, r24	; 0x1e
}
    1e62:	0f 90       	pop	r0
    1e64:	0f 90       	pop	r0
    1e66:	0f 90       	pop	r0
    1e68:	0f 90       	pop	r0
    1e6a:	0f 90       	pop	r0
    1e6c:	cf 91       	pop	r28
    1e6e:	df 91       	pop	r29
    1e70:	08 95       	ret

00001e72 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1e72:	df 93       	push	r29
    1e74:	cf 93       	push	r28
    1e76:	00 d0       	rcall	.+0      	; 0x1e78 <prvCopyDataFromQueue+0x6>
    1e78:	00 d0       	rcall	.+0      	; 0x1e7a <prvCopyDataFromQueue+0x8>
    1e7a:	cd b7       	in	r28, 0x3d	; 61
    1e7c:	de b7       	in	r29, 0x3e	; 62
    1e7e:	9a 83       	std	Y+2, r25	; 0x02
    1e80:	89 83       	std	Y+1, r24	; 0x01
    1e82:	7c 83       	std	Y+4, r23	; 0x04
    1e84:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1e86:	e9 81       	ldd	r30, Y+1	; 0x01
    1e88:	fa 81       	ldd	r31, Y+2	; 0x02
    1e8a:	80 81       	ld	r24, Z
    1e8c:	91 81       	ldd	r25, Z+1	; 0x01
    1e8e:	00 97       	sbiw	r24, 0x00	; 0
    1e90:	89 f1       	breq	.+98     	; 0x1ef4 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1e92:	e9 81       	ldd	r30, Y+1	; 0x01
    1e94:	fa 81       	ldd	r31, Y+2	; 0x02
    1e96:	26 81       	ldd	r18, Z+6	; 0x06
    1e98:	37 81       	ldd	r19, Z+7	; 0x07
    1e9a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e9c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e9e:	80 a1       	ldd	r24, Z+32	; 0x20
    1ea0:	88 2f       	mov	r24, r24
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	82 0f       	add	r24, r18
    1ea6:	93 1f       	adc	r25, r19
    1ea8:	e9 81       	ldd	r30, Y+1	; 0x01
    1eaa:	fa 81       	ldd	r31, Y+2	; 0x02
    1eac:	97 83       	std	Z+7, r25	; 0x07
    1eae:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1eb0:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb2:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb4:	26 81       	ldd	r18, Z+6	; 0x06
    1eb6:	37 81       	ldd	r19, Z+7	; 0x07
    1eb8:	e9 81       	ldd	r30, Y+1	; 0x01
    1eba:	fa 81       	ldd	r31, Y+2	; 0x02
    1ebc:	82 81       	ldd	r24, Z+2	; 0x02
    1ebe:	93 81       	ldd	r25, Z+3	; 0x03
    1ec0:	28 17       	cp	r18, r24
    1ec2:	39 07       	cpc	r19, r25
    1ec4:	40 f0       	brcs	.+16     	; 0x1ed6 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1ec6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eca:	80 81       	ld	r24, Z
    1ecc:	91 81       	ldd	r25, Z+1	; 0x01
    1ece:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed2:	97 83       	std	Z+7, r25	; 0x07
    1ed4:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1ed6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eda:	46 81       	ldd	r20, Z+6	; 0x06
    1edc:	57 81       	ldd	r21, Z+7	; 0x07
    1ede:	e9 81       	ldd	r30, Y+1	; 0x01
    1ee0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ee2:	80 a1       	ldd	r24, Z+32	; 0x20
    1ee4:	28 2f       	mov	r18, r24
    1ee6:	30 e0       	ldi	r19, 0x00	; 0
    1ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eea:	9c 81       	ldd	r25, Y+4	; 0x04
    1eec:	ba 01       	movw	r22, r20
    1eee:	a9 01       	movw	r20, r18
    1ef0:	0e 94 63 18 	call	0x30c6	; 0x30c6 <memcpy>
	}
}
    1ef4:	0f 90       	pop	r0
    1ef6:	0f 90       	pop	r0
    1ef8:	0f 90       	pop	r0
    1efa:	0f 90       	pop	r0
    1efc:	cf 91       	pop	r28
    1efe:	df 91       	pop	r29
    1f00:	08 95       	ret

00001f02 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1f02:	df 93       	push	r29
    1f04:	cf 93       	push	r28
    1f06:	00 d0       	rcall	.+0      	; 0x1f08 <prvUnlockQueue+0x6>
    1f08:	cd b7       	in	r28, 0x3d	; 61
    1f0a:	de b7       	in	r29, 0x3e	; 62
    1f0c:	9a 83       	std	Y+2, r25	; 0x02
    1f0e:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	f8 94       	cli
    1f14:	0f 92       	push	r0
    1f16:	15 c0       	rjmp	.+42     	; 0x1f42 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f18:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f1c:	83 89       	ldd	r24, Z+19	; 0x13
    1f1e:	88 23       	and	r24, r24
    1f20:	a9 f0       	breq	.+42     	; 0x1f4c <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f22:	89 81       	ldd	r24, Y+1	; 0x01
    1f24:	9a 81       	ldd	r25, Y+2	; 0x02
    1f26:	43 96       	adiw	r24, 0x13	; 19
    1f28:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskRemoveFromEventList>
    1f2c:	88 23       	and	r24, r24
    1f2e:	11 f0       	breq	.+4      	; 0x1f34 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1f30:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1f34:	e9 81       	ldd	r30, Y+1	; 0x01
    1f36:	fa 81       	ldd	r31, Y+2	; 0x02
    1f38:	82 a1       	ldd	r24, Z+34	; 0x22
    1f3a:	81 50       	subi	r24, 0x01	; 1
    1f3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f40:	82 a3       	std	Z+34, r24	; 0x22
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1f42:	e9 81       	ldd	r30, Y+1	; 0x01
    1f44:	fa 81       	ldd	r31, Y+2	; 0x02
    1f46:	82 a1       	ldd	r24, Z+34	; 0x22
    1f48:	18 16       	cp	r1, r24
    1f4a:	34 f3       	brlt	.-52     	; 0x1f18 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f50:	8f ef       	ldi	r24, 0xFF	; 255
    1f52:	82 a3       	std	Z+34, r24	; 0x22
	}
	taskEXIT_CRITICAL();
    1f54:	0f 90       	pop	r0
    1f56:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1f58:	0f b6       	in	r0, 0x3f	; 63
    1f5a:	f8 94       	cli
    1f5c:	0f 92       	push	r0
    1f5e:	15 c0       	rjmp	.+42     	; 0x1f8a <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f60:	e9 81       	ldd	r30, Y+1	; 0x01
    1f62:	fa 81       	ldd	r31, Y+2	; 0x02
    1f64:	80 85       	ldd	r24, Z+8	; 0x08
    1f66:	88 23       	and	r24, r24
    1f68:	a9 f0       	breq	.+42     	; 0x1f94 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f6a:	89 81       	ldd	r24, Y+1	; 0x01
    1f6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f6e:	08 96       	adiw	r24, 0x08	; 8
    1f70:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskRemoveFromEventList>
    1f74:	88 23       	and	r24, r24
    1f76:	11 f0       	breq	.+4      	; 0x1f7c <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    1f78:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f80:	81 a1       	ldd	r24, Z+33	; 0x21
    1f82:	81 50       	subi	r24, 0x01	; 1
    1f84:	e9 81       	ldd	r30, Y+1	; 0x01
    1f86:	fa 81       	ldd	r31, Y+2	; 0x02
    1f88:	81 a3       	std	Z+33, r24	; 0x21
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1f8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f8e:	81 a1       	ldd	r24, Z+33	; 0x21
    1f90:	18 16       	cp	r1, r24
    1f92:	34 f3       	brlt	.-52     	; 0x1f60 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1f94:	e9 81       	ldd	r30, Y+1	; 0x01
    1f96:	fa 81       	ldd	r31, Y+2	; 0x02
    1f98:	8f ef       	ldi	r24, 0xFF	; 255
    1f9a:	81 a3       	std	Z+33, r24	; 0x21
	}
	taskEXIT_CRITICAL();
    1f9c:	0f 90       	pop	r0
    1f9e:	0f be       	out	0x3f, r0	; 63
}
    1fa0:	0f 90       	pop	r0
    1fa2:	0f 90       	pop	r0
    1fa4:	cf 91       	pop	r28
    1fa6:	df 91       	pop	r29
    1fa8:	08 95       	ret

00001faa <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1faa:	df 93       	push	r29
    1fac:	cf 93       	push	r28
    1fae:	00 d0       	rcall	.+0      	; 0x1fb0 <prvIsQueueEmpty+0x6>
    1fb0:	0f 92       	push	r0
    1fb2:	cd b7       	in	r28, 0x3d	; 61
    1fb4:	de b7       	in	r29, 0x3e	; 62
    1fb6:	9b 83       	std	Y+3, r25	; 0x03
    1fb8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1fba:	0f b6       	in	r0, 0x3f	; 63
    1fbc:	f8 94       	cli
    1fbe:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1fc0:	ea 81       	ldd	r30, Y+2	; 0x02
    1fc2:	fb 81       	ldd	r31, Y+3	; 0x03
    1fc4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fc6:	19 82       	std	Y+1, r1	; 0x01
    1fc8:	88 23       	and	r24, r24
    1fca:	11 f4       	brne	.+4      	; 0x1fd0 <prvIsQueueEmpty+0x26>
    1fcc:	81 e0       	ldi	r24, 0x01	; 1
    1fce:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1fd0:	0f 90       	pop	r0
    1fd2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1fd4:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fd6:	0f 90       	pop	r0
    1fd8:	0f 90       	pop	r0
    1fda:	0f 90       	pop	r0
    1fdc:	cf 91       	pop	r28
    1fde:	df 91       	pop	r29
    1fe0:	08 95       	ret

00001fe2 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1fe2:	df 93       	push	r29
    1fe4:	cf 93       	push	r28
    1fe6:	00 d0       	rcall	.+0      	; 0x1fe8 <xQueueIsQueueEmptyFromISR+0x6>
    1fe8:	0f 92       	push	r0
    1fea:	cd b7       	in	r28, 0x3d	; 61
    1fec:	de b7       	in	r29, 0x3e	; 62
    1fee:	9b 83       	std	Y+3, r25	; 0x03
    1ff0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1ff2:	ea 81       	ldd	r30, Y+2	; 0x02
    1ff4:	fb 81       	ldd	r31, Y+3	; 0x03
    1ff6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ff8:	19 82       	std	Y+1, r1	; 0x01
    1ffa:	88 23       	and	r24, r24
    1ffc:	11 f4       	brne	.+4      	; 0x2002 <xQueueIsQueueEmptyFromISR+0x20>
    1ffe:	81 e0       	ldi	r24, 0x01	; 1
    2000:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2002:	89 81       	ldd	r24, Y+1	; 0x01
}
    2004:	0f 90       	pop	r0
    2006:	0f 90       	pop	r0
    2008:	0f 90       	pop	r0
    200a:	cf 91       	pop	r28
    200c:	df 91       	pop	r29
    200e:	08 95       	ret

00002010 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    2010:	df 93       	push	r29
    2012:	cf 93       	push	r28
    2014:	00 d0       	rcall	.+0      	; 0x2016 <prvIsQueueFull+0x6>
    2016:	0f 92       	push	r0
    2018:	cd b7       	in	r28, 0x3d	; 61
    201a:	de b7       	in	r29, 0x3e	; 62
    201c:	9b 83       	std	Y+3, r25	; 0x03
    201e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2020:	0f b6       	in	r0, 0x3f	; 63
    2022:	f8 94       	cli
    2024:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2026:	ea 81       	ldd	r30, Y+2	; 0x02
    2028:	fb 81       	ldd	r31, Y+3	; 0x03
    202a:	96 8d       	ldd	r25, Z+30	; 0x1e
    202c:	ea 81       	ldd	r30, Y+2	; 0x02
    202e:	fb 81       	ldd	r31, Y+3	; 0x03
    2030:	87 8d       	ldd	r24, Z+31	; 0x1f
    2032:	19 82       	std	Y+1, r1	; 0x01
    2034:	98 17       	cp	r25, r24
    2036:	11 f4       	brne	.+4      	; 0x203c <prvIsQueueFull+0x2c>
    2038:	81 e0       	ldi	r24, 0x01	; 1
    203a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    203c:	0f 90       	pop	r0
    203e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2040:	89 81       	ldd	r24, Y+1	; 0x01
}
    2042:	0f 90       	pop	r0
    2044:	0f 90       	pop	r0
    2046:	0f 90       	pop	r0
    2048:	cf 91       	pop	r28
    204a:	df 91       	pop	r29
    204c:	08 95       	ret

0000204e <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    204e:	df 93       	push	r29
    2050:	cf 93       	push	r28
    2052:	00 d0       	rcall	.+0      	; 0x2054 <xQueueIsQueueFullFromISR+0x6>
    2054:	0f 92       	push	r0
    2056:	cd b7       	in	r28, 0x3d	; 61
    2058:	de b7       	in	r29, 0x3e	; 62
    205a:	9b 83       	std	Y+3, r25	; 0x03
    205c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    205e:	ea 81       	ldd	r30, Y+2	; 0x02
    2060:	fb 81       	ldd	r31, Y+3	; 0x03
    2062:	96 8d       	ldd	r25, Z+30	; 0x1e
    2064:	ea 81       	ldd	r30, Y+2	; 0x02
    2066:	fb 81       	ldd	r31, Y+3	; 0x03
    2068:	87 8d       	ldd	r24, Z+31	; 0x1f
    206a:	19 82       	std	Y+1, r1	; 0x01
    206c:	98 17       	cp	r25, r24
    206e:	11 f4       	brne	.+4      	; 0x2074 <xQueueIsQueueFullFromISR+0x26>
    2070:	81 e0       	ldi	r24, 0x01	; 1
    2072:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2074:	89 81       	ldd	r24, Y+1	; 0x01
}
    2076:	0f 90       	pop	r0
    2078:	0f 90       	pop	r0
    207a:	0f 90       	pop	r0
    207c:	cf 91       	pop	r28
    207e:	df 91       	pop	r29
    2080:	08 95       	ret

00002082 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2082:	af 92       	push	r10
    2084:	bf 92       	push	r11
    2086:	cf 92       	push	r12
    2088:	df 92       	push	r13
    208a:	ef 92       	push	r14
    208c:	ff 92       	push	r15
    208e:	0f 93       	push	r16
    2090:	1f 93       	push	r17
    2092:	df 93       	push	r29
    2094:	cf 93       	push	r28
    2096:	cd b7       	in	r28, 0x3d	; 61
    2098:	de b7       	in	r29, 0x3e	; 62
    209a:	64 97       	sbiw	r28, 0x14	; 20
    209c:	0f b6       	in	r0, 0x3f	; 63
    209e:	f8 94       	cli
    20a0:	de bf       	out	0x3e, r29	; 62
    20a2:	0f be       	out	0x3f, r0	; 63
    20a4:	cd bf       	out	0x3d, r28	; 61
    20a6:	9f 83       	std	Y+7, r25	; 0x07
    20a8:	8e 83       	std	Y+6, r24	; 0x06
    20aa:	79 87       	std	Y+9, r23	; 0x09
    20ac:	68 87       	std	Y+8, r22	; 0x08
    20ae:	5b 87       	std	Y+11, r21	; 0x0b
    20b0:	4a 87       	std	Y+10, r20	; 0x0a
    20b2:	3d 87       	std	Y+13, r19	; 0x0d
    20b4:	2c 87       	std	Y+12, r18	; 0x0c
    20b6:	0e 87       	std	Y+14, r16	; 0x0e
    20b8:	f8 8a       	std	Y+16, r15	; 0x10
    20ba:	ef 86       	std	Y+15, r14	; 0x0f
    20bc:	da 8a       	std	Y+18, r13	; 0x12
    20be:	c9 8a       	std	Y+17, r12	; 0x11
    20c0:	bc 8a       	std	Y+20, r11	; 0x14
    20c2:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    20c4:	8a 85       	ldd	r24, Y+10	; 0x0a
    20c6:	9b 85       	ldd	r25, Y+11	; 0x0b
    20c8:	29 89       	ldd	r18, Y+17	; 0x11
    20ca:	3a 89       	ldd	r19, Y+18	; 0x12
    20cc:	b9 01       	movw	r22, r18
    20ce:	0e 94 fd 17 	call	0x2ffa	; 0x2ffa <prvAllocateTCBAndStack>
    20d2:	9c 83       	std	Y+4, r25	; 0x04
    20d4:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    20d6:	8b 81       	ldd	r24, Y+3	; 0x03
    20d8:	9c 81       	ldd	r25, Y+4	; 0x04
    20da:	00 97       	sbiw	r24, 0x00	; 0
    20dc:	09 f4       	brne	.+2      	; 0x20e0 <xTaskGenericCreate+0x5e>
    20de:	9c c0       	rjmp	.+312    	; 0x2218 <xTaskGenericCreate+0x196>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    20e0:	eb 81       	ldd	r30, Y+3	; 0x03
    20e2:	fc 81       	ldd	r31, Y+4	; 0x04
    20e4:	23 8d       	ldd	r18, Z+27	; 0x1b
    20e6:	34 8d       	ldd	r19, Z+28	; 0x1c
    20e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    20ea:	9b 85       	ldd	r25, Y+11	; 0x0b
    20ec:	01 97       	sbiw	r24, 0x01	; 1
    20ee:	82 0f       	add	r24, r18
    20f0:	93 1f       	adc	r25, r19
    20f2:	9a 83       	std	Y+2, r25	; 0x02
    20f4:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    20f6:	8b 81       	ldd	r24, Y+3	; 0x03
    20f8:	9c 81       	ldd	r25, Y+4	; 0x04
    20fa:	28 85       	ldd	r18, Y+8	; 0x08
    20fc:	39 85       	ldd	r19, Y+9	; 0x09
    20fe:	eb 89       	ldd	r30, Y+19	; 0x13
    2100:	fc 89       	ldd	r31, Y+20	; 0x14
    2102:	aa 85       	ldd	r26, Y+10	; 0x0a
    2104:	bb 85       	ldd	r27, Y+11	; 0x0b
    2106:	b9 01       	movw	r22, r18
    2108:	4e 85       	ldd	r20, Y+14	; 0x0e
    210a:	9f 01       	movw	r18, r30
    210c:	8d 01       	movw	r16, r26
    210e:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2112:	89 81       	ldd	r24, Y+1	; 0x01
    2114:	9a 81       	ldd	r25, Y+2	; 0x02
    2116:	2e 81       	ldd	r18, Y+6	; 0x06
    2118:	3f 81       	ldd	r19, Y+7	; 0x07
    211a:	4c 85       	ldd	r20, Y+12	; 0x0c
    211c:	5d 85       	ldd	r21, Y+13	; 0x0d
    211e:	b9 01       	movw	r22, r18
    2120:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <pxPortInitialiseStack>
    2124:	eb 81       	ldd	r30, Y+3	; 0x03
    2126:	fc 81       	ldd	r31, Y+4	; 0x04
    2128:	91 83       	std	Z+1, r25	; 0x01
    212a:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    212c:	8f 85       	ldd	r24, Y+15	; 0x0f
    212e:	98 89       	ldd	r25, Y+16	; 0x10
    2130:	00 97       	sbiw	r24, 0x00	; 0
    2132:	31 f0       	breq	.+12     	; 0x2140 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2134:	ef 85       	ldd	r30, Y+15	; 0x0f
    2136:	f8 89       	ldd	r31, Y+16	; 0x10
    2138:	8b 81       	ldd	r24, Y+3	; 0x03
    213a:	9c 81       	ldd	r25, Y+4	; 0x04
    213c:	91 83       	std	Z+1, r25	; 0x01
    213e:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    2140:	0f b6       	in	r0, 0x3f	; 63
    2142:	f8 94       	cli
    2144:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2146:	80 91 1b 03 	lds	r24, 0x031B
    214a:	8f 5f       	subi	r24, 0xFF	; 255
    214c:	80 93 1b 03 	sts	0x031B, r24
			if( pxCurrentTCB == NULL )
    2150:	80 91 18 03 	lds	r24, 0x0318
    2154:	90 91 19 03 	lds	r25, 0x0319
    2158:	00 97       	sbiw	r24, 0x00	; 0
    215a:	69 f4       	brne	.+26     	; 0x2176 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    215c:	8b 81       	ldd	r24, Y+3	; 0x03
    215e:	9c 81       	ldd	r25, Y+4	; 0x04
    2160:	90 93 19 03 	sts	0x0319, r25
    2164:	80 93 18 03 	sts	0x0318, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2168:	80 91 1b 03 	lds	r24, 0x031B
    216c:	81 30       	cpi	r24, 0x01	; 1
    216e:	a9 f4       	brne	.+42     	; 0x219a <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    2170:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <prvInitialiseTaskLists>
    2174:	12 c0       	rjmp	.+36     	; 0x219a <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2176:	80 91 22 03 	lds	r24, 0x0322
    217a:	88 23       	and	r24, r24
    217c:	71 f4       	brne	.+28     	; 0x219a <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    217e:	e0 91 18 03 	lds	r30, 0x0318
    2182:	f0 91 19 03 	lds	r31, 0x0319
    2186:	92 8d       	ldd	r25, Z+26	; 0x1a
    2188:	8e 85       	ldd	r24, Y+14	; 0x0e
    218a:	89 17       	cp	r24, r25
    218c:	30 f0       	brcs	.+12     	; 0x219a <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    218e:	8b 81       	ldd	r24, Y+3	; 0x03
    2190:	9c 81       	ldd	r25, Y+4	; 0x04
    2192:	90 93 19 03 	sts	0x0319, r25
    2196:	80 93 18 03 	sts	0x0318, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    219a:	eb 81       	ldd	r30, Y+3	; 0x03
    219c:	fc 81       	ldd	r31, Y+4	; 0x04
    219e:	92 8d       	ldd	r25, Z+26	; 0x1a
    21a0:	80 91 20 03 	lds	r24, 0x0320
    21a4:	89 17       	cp	r24, r25
    21a6:	28 f4       	brcc	.+10     	; 0x21b2 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    21a8:	eb 81       	ldd	r30, Y+3	; 0x03
    21aa:	fc 81       	ldd	r31, Y+4	; 0x04
    21ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    21ae:	80 93 20 03 	sts	0x0320, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    21b2:	80 91 27 03 	lds	r24, 0x0327
    21b6:	8f 5f       	subi	r24, 0xFF	; 255
    21b8:	80 93 27 03 	sts	0x0327, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    21bc:	eb 81       	ldd	r30, Y+3	; 0x03
    21be:	fc 81       	ldd	r31, Y+4	; 0x04
    21c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    21c2:	80 91 21 03 	lds	r24, 0x0321
    21c6:	89 17       	cp	r24, r25
    21c8:	28 f4       	brcc	.+10     	; 0x21d4 <xTaskGenericCreate+0x152>
    21ca:	eb 81       	ldd	r30, Y+3	; 0x03
    21cc:	fc 81       	ldd	r31, Y+4	; 0x04
    21ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    21d0:	80 93 21 03 	sts	0x0321, r24
    21d4:	eb 81       	ldd	r30, Y+3	; 0x03
    21d6:	fc 81       	ldd	r31, Y+4	; 0x04
    21d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    21da:	48 2f       	mov	r20, r24
    21dc:	50 e0       	ldi	r21, 0x00	; 0
    21de:	ca 01       	movw	r24, r20
    21e0:	88 0f       	add	r24, r24
    21e2:	99 1f       	adc	r25, r25
    21e4:	9c 01       	movw	r18, r24
    21e6:	22 0f       	add	r18, r18
    21e8:	33 1f       	adc	r19, r19
    21ea:	22 0f       	add	r18, r18
    21ec:	33 1f       	adc	r19, r19
    21ee:	82 0f       	add	r24, r18
    21f0:	93 1f       	adc	r25, r19
    21f2:	84 0f       	add	r24, r20
    21f4:	95 1f       	adc	r25, r21
    21f6:	ac 01       	movw	r20, r24
    21f8:	48 5d       	subi	r20, 0xD8	; 216
    21fa:	5c 4f       	sbci	r21, 0xFC	; 252
    21fc:	8b 81       	ldd	r24, Y+3	; 0x03
    21fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2200:	9c 01       	movw	r18, r24
    2202:	2e 5f       	subi	r18, 0xFE	; 254
    2204:	3f 4f       	sbci	r19, 0xFF	; 255
    2206:	ca 01       	movw	r24, r20
    2208:	b9 01       	movw	r22, r18
    220a:	0e 94 63 07 	call	0xec6	; 0xec6 <vListInsertEnd>

			xReturn = pdPASS;
    220e:	81 e0       	ldi	r24, 0x01	; 1
    2210:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2212:	0f 90       	pop	r0
    2214:	0f be       	out	0x3f, r0	; 63
    2216:	02 c0       	rjmp	.+4      	; 0x221c <xTaskGenericCreate+0x19a>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2218:	8f ef       	ldi	r24, 0xFF	; 255
    221a:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    221c:	8d 81       	ldd	r24, Y+5	; 0x05
    221e:	81 30       	cpi	r24, 0x01	; 1
    2220:	71 f4       	brne	.+28     	; 0x223e <xTaskGenericCreate+0x1bc>
	{
		if( xSchedulerRunning != pdFALSE )
    2222:	80 91 22 03 	lds	r24, 0x0322
    2226:	88 23       	and	r24, r24
    2228:	51 f0       	breq	.+20     	; 0x223e <xTaskGenericCreate+0x1bc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    222a:	e0 91 18 03 	lds	r30, 0x0318
    222e:	f0 91 19 03 	lds	r31, 0x0319
    2232:	92 8d       	ldd	r25, Z+26	; 0x1a
    2234:	8e 85       	ldd	r24, Y+14	; 0x0e
    2236:	98 17       	cp	r25, r24
    2238:	10 f4       	brcc	.+4      	; 0x223e <xTaskGenericCreate+0x1bc>
			{
				portYIELD_WITHIN_API();
    223a:	0e 94 97 0a 	call	0x152e	; 0x152e <vPortYield>
			}
		}
	}

	return xReturn;
    223e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2240:	64 96       	adiw	r28, 0x14	; 20
    2242:	0f b6       	in	r0, 0x3f	; 63
    2244:	f8 94       	cli
    2246:	de bf       	out	0x3e, r29	; 62
    2248:	0f be       	out	0x3f, r0	; 63
    224a:	cd bf       	out	0x3d, r28	; 61
    224c:	cf 91       	pop	r28
    224e:	df 91       	pop	r29
    2250:	1f 91       	pop	r17
    2252:	0f 91       	pop	r16
    2254:	ff 90       	pop	r15
    2256:	ef 90       	pop	r14
    2258:	df 90       	pop	r13
    225a:	cf 90       	pop	r12
    225c:	bf 90       	pop	r11
    225e:	af 90       	pop	r10
    2260:	08 95       	ret

00002262 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2262:	df 93       	push	r29
    2264:	cf 93       	push	r28
    2266:	00 d0       	rcall	.+0      	; 0x2268 <vTaskDelete+0x6>
    2268:	00 d0       	rcall	.+0      	; 0x226a <vTaskDelete+0x8>
    226a:	00 d0       	rcall	.+0      	; 0x226c <vTaskDelete+0xa>
    226c:	cd b7       	in	r28, 0x3d	; 61
    226e:	de b7       	in	r29, 0x3e	; 62
    2270:	9c 83       	std	Y+4, r25	; 0x04
    2272:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2274:	0f b6       	in	r0, 0x3f	; 63
    2276:	f8 94       	cli
    2278:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    227a:	20 91 18 03 	lds	r18, 0x0318
    227e:	30 91 19 03 	lds	r19, 0x0319
    2282:	8b 81       	ldd	r24, Y+3	; 0x03
    2284:	9c 81       	ldd	r25, Y+4	; 0x04
    2286:	82 17       	cp	r24, r18
    2288:	93 07       	cpc	r25, r19
    228a:	11 f4       	brne	.+4      	; 0x2290 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    228c:	1c 82       	std	Y+4, r1	; 0x04
    228e:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2290:	8b 81       	ldd	r24, Y+3	; 0x03
    2292:	9c 81       	ldd	r25, Y+4	; 0x04
    2294:	00 97       	sbiw	r24, 0x00	; 0
    2296:	39 f4       	brne	.+14     	; 0x22a6 <vTaskDelete+0x44>
    2298:	80 91 18 03 	lds	r24, 0x0318
    229c:	90 91 19 03 	lds	r25, 0x0319
    22a0:	9e 83       	std	Y+6, r25	; 0x06
    22a2:	8d 83       	std	Y+5, r24	; 0x05
    22a4:	04 c0       	rjmp	.+8      	; 0x22ae <vTaskDelete+0x4c>
    22a6:	8b 81       	ldd	r24, Y+3	; 0x03
    22a8:	9c 81       	ldd	r25, Y+4	; 0x04
    22aa:	9e 83       	std	Y+6, r25	; 0x06
    22ac:	8d 83       	std	Y+5, r24	; 0x05
    22ae:	8d 81       	ldd	r24, Y+5	; 0x05
    22b0:	9e 81       	ldd	r25, Y+6	; 0x06
    22b2:	9a 83       	std	Y+2, r25	; 0x02
    22b4:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    22b6:	89 81       	ldd	r24, Y+1	; 0x01
    22b8:	9a 81       	ldd	r25, Y+2	; 0x02
    22ba:	02 96       	adiw	r24, 0x02	; 2
    22bc:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    22c0:	e9 81       	ldd	r30, Y+1	; 0x01
    22c2:	fa 81       	ldd	r31, Y+2	; 0x02
    22c4:	80 8d       	ldd	r24, Z+24	; 0x18
    22c6:	91 8d       	ldd	r25, Z+25	; 0x19
    22c8:	00 97       	sbiw	r24, 0x00	; 0
    22ca:	29 f0       	breq	.+10     	; 0x22d6 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    22cc:	89 81       	ldd	r24, Y+1	; 0x01
    22ce:	9a 81       	ldd	r25, Y+2	; 0x02
    22d0:	0e 96       	adiw	r24, 0x0e	; 14
    22d2:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    22d6:	89 81       	ldd	r24, Y+1	; 0x01
    22d8:	9a 81       	ldd	r25, Y+2	; 0x02
    22da:	9c 01       	movw	r18, r24
    22dc:	2e 5f       	subi	r18, 0xFE	; 254
    22de:	3f 4f       	sbci	r19, 0xFF	; 255
    22e0:	82 ef       	ldi	r24, 0xF2	; 242
    22e2:	93 e0       	ldi	r25, 0x03	; 3
    22e4:	b9 01       	movw	r22, r18
    22e6:	0e 94 63 07 	call	0xec6	; 0xec6 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    22ea:	80 91 1a 03 	lds	r24, 0x031A
    22ee:	8f 5f       	subi	r24, 0xFF	; 255
    22f0:	80 93 1a 03 	sts	0x031A, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    22f4:	80 91 27 03 	lds	r24, 0x0327
    22f8:	8f 5f       	subi	r24, 0xFF	; 255
    22fa:	80 93 27 03 	sts	0x0327, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    22fe:	0f 90       	pop	r0
    2300:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2302:	80 91 22 03 	lds	r24, 0x0322
    2306:	88 23       	and	r24, r24
    2308:	31 f0       	breq	.+12     	; 0x2316 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    230a:	8b 81       	ldd	r24, Y+3	; 0x03
    230c:	9c 81       	ldd	r25, Y+4	; 0x04
    230e:	00 97       	sbiw	r24, 0x00	; 0
    2310:	11 f4       	brne	.+4      	; 0x2316 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    2312:	0e 94 97 0a 	call	0x152e	; 0x152e <vPortYield>
			}
		}
	}
    2316:	26 96       	adiw	r28, 0x06	; 6
    2318:	0f b6       	in	r0, 0x3f	; 63
    231a:	f8 94       	cli
    231c:	de bf       	out	0x3e, r29	; 62
    231e:	0f be       	out	0x3f, r0	; 63
    2320:	cd bf       	out	0x3d, r28	; 61
    2322:	cf 91       	pop	r28
    2324:	df 91       	pop	r29
    2326:	08 95       	ret

00002328 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2328:	df 93       	push	r29
    232a:	cf 93       	push	r28
    232c:	cd b7       	in	r28, 0x3d	; 61
    232e:	de b7       	in	r29, 0x3e	; 62
    2330:	2c 97       	sbiw	r28, 0x0c	; 12
    2332:	0f b6       	in	r0, 0x3f	; 63
    2334:	f8 94       	cli
    2336:	de bf       	out	0x3e, r29	; 62
    2338:	0f be       	out	0x3f, r0	; 63
    233a:	cd bf       	out	0x3d, r28	; 61
    233c:	98 87       	std	Y+8, r25	; 0x08
    233e:	8f 83       	std	Y+7, r24	; 0x07
    2340:	49 87       	std	Y+9, r20	; 0x09
    2342:	5a 87       	std	Y+10, r21	; 0x0a
    2344:	6b 87       	std	Y+11, r22	; 0x0b
    2346:	7c 87       	std	Y+12, r23	; 0x0c
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    2348:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    234a:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    234e:	ef 81       	ldd	r30, Y+7	; 0x07
    2350:	f8 85       	ldd	r31, Y+8	; 0x08
    2352:	20 81       	ld	r18, Z
    2354:	31 81       	ldd	r19, Z+1	; 0x01
    2356:	42 81       	ldd	r20, Z+2	; 0x02
    2358:	53 81       	ldd	r21, Z+3	; 0x03
    235a:	89 85       	ldd	r24, Y+9	; 0x09
    235c:	9a 85       	ldd	r25, Y+10	; 0x0a
    235e:	ab 85       	ldd	r26, Y+11	; 0x0b
    2360:	bc 85       	ldd	r27, Y+12	; 0x0c
    2362:	82 0f       	add	r24, r18
    2364:	93 1f       	adc	r25, r19
    2366:	a4 1f       	adc	r26, r20
    2368:	b5 1f       	adc	r27, r21
    236a:	8b 83       	std	Y+3, r24	; 0x03
    236c:	9c 83       	std	Y+4, r25	; 0x04
    236e:	ad 83       	std	Y+5, r26	; 0x05
    2370:	be 83       	std	Y+6, r27	; 0x06

			if( xTickCount < *pxPreviousWakeTime )
    2372:	ef 81       	ldd	r30, Y+7	; 0x07
    2374:	f8 85       	ldd	r31, Y+8	; 0x08
    2376:	20 81       	ld	r18, Z
    2378:	31 81       	ldd	r19, Z+1	; 0x01
    237a:	42 81       	ldd	r20, Z+2	; 0x02
    237c:	53 81       	ldd	r21, Z+3	; 0x03
    237e:	80 91 1c 03 	lds	r24, 0x031C
    2382:	90 91 1d 03 	lds	r25, 0x031D
    2386:	a0 91 1e 03 	lds	r26, 0x031E
    238a:	b0 91 1f 03 	lds	r27, 0x031F
    238e:	82 17       	cp	r24, r18
    2390:	93 07       	cpc	r25, r19
    2392:	a4 07       	cpc	r26, r20
    2394:	b5 07       	cpc	r27, r21
    2396:	18 f5       	brcc	.+70     	; 0x23de <vTaskDelayUntil+0xb6>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2398:	ef 81       	ldd	r30, Y+7	; 0x07
    239a:	f8 85       	ldd	r31, Y+8	; 0x08
    239c:	20 81       	ld	r18, Z
    239e:	31 81       	ldd	r19, Z+1	; 0x01
    23a0:	42 81       	ldd	r20, Z+2	; 0x02
    23a2:	53 81       	ldd	r21, Z+3	; 0x03
    23a4:	8b 81       	ldd	r24, Y+3	; 0x03
    23a6:	9c 81       	ldd	r25, Y+4	; 0x04
    23a8:	ad 81       	ldd	r26, Y+5	; 0x05
    23aa:	be 81       	ldd	r27, Y+6	; 0x06
    23ac:	82 17       	cp	r24, r18
    23ae:	93 07       	cpc	r25, r19
    23b0:	a4 07       	cpc	r26, r20
    23b2:	b5 07       	cpc	r27, r21
    23b4:	b0 f5       	brcc	.+108    	; 0x2422 <vTaskDelayUntil+0xfa>
    23b6:	20 91 1c 03 	lds	r18, 0x031C
    23ba:	30 91 1d 03 	lds	r19, 0x031D
    23be:	40 91 1e 03 	lds	r20, 0x031E
    23c2:	50 91 1f 03 	lds	r21, 0x031F
    23c6:	8b 81       	ldd	r24, Y+3	; 0x03
    23c8:	9c 81       	ldd	r25, Y+4	; 0x04
    23ca:	ad 81       	ldd	r26, Y+5	; 0x05
    23cc:	be 81       	ldd	r27, Y+6	; 0x06
    23ce:	28 17       	cp	r18, r24
    23d0:	39 07       	cpc	r19, r25
    23d2:	4a 07       	cpc	r20, r26
    23d4:	5b 07       	cpc	r21, r27
    23d6:	28 f5       	brcc	.+74     	; 0x2422 <vTaskDelayUntil+0xfa>
				{
					xShouldDelay = pdTRUE;
    23d8:	81 e0       	ldi	r24, 0x01	; 1
    23da:	89 83       	std	Y+1, r24	; 0x01
    23dc:	22 c0       	rjmp	.+68     	; 0x2422 <vTaskDelayUntil+0xfa>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    23de:	ef 81       	ldd	r30, Y+7	; 0x07
    23e0:	f8 85       	ldd	r31, Y+8	; 0x08
    23e2:	20 81       	ld	r18, Z
    23e4:	31 81       	ldd	r19, Z+1	; 0x01
    23e6:	42 81       	ldd	r20, Z+2	; 0x02
    23e8:	53 81       	ldd	r21, Z+3	; 0x03
    23ea:	8b 81       	ldd	r24, Y+3	; 0x03
    23ec:	9c 81       	ldd	r25, Y+4	; 0x04
    23ee:	ad 81       	ldd	r26, Y+5	; 0x05
    23f0:	be 81       	ldd	r27, Y+6	; 0x06
    23f2:	82 17       	cp	r24, r18
    23f4:	93 07       	cpc	r25, r19
    23f6:	a4 07       	cpc	r26, r20
    23f8:	b5 07       	cpc	r27, r21
    23fa:	88 f0       	brcs	.+34     	; 0x241e <vTaskDelayUntil+0xf6>
    23fc:	20 91 1c 03 	lds	r18, 0x031C
    2400:	30 91 1d 03 	lds	r19, 0x031D
    2404:	40 91 1e 03 	lds	r20, 0x031E
    2408:	50 91 1f 03 	lds	r21, 0x031F
    240c:	8b 81       	ldd	r24, Y+3	; 0x03
    240e:	9c 81       	ldd	r25, Y+4	; 0x04
    2410:	ad 81       	ldd	r26, Y+5	; 0x05
    2412:	be 81       	ldd	r27, Y+6	; 0x06
    2414:	28 17       	cp	r18, r24
    2416:	39 07       	cpc	r19, r25
    2418:	4a 07       	cpc	r20, r26
    241a:	5b 07       	cpc	r21, r27
    241c:	10 f4       	brcc	.+4      	; 0x2422 <vTaskDelayUntil+0xfa>
				{
					xShouldDelay = pdTRUE;
    241e:	81 e0       	ldi	r24, 0x01	; 1
    2420:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2422:	ef 81       	ldd	r30, Y+7	; 0x07
    2424:	f8 85       	ldd	r31, Y+8	; 0x08
    2426:	8b 81       	ldd	r24, Y+3	; 0x03
    2428:	9c 81       	ldd	r25, Y+4	; 0x04
    242a:	ad 81       	ldd	r26, Y+5	; 0x05
    242c:	be 81       	ldd	r27, Y+6	; 0x06
    242e:	80 83       	st	Z, r24
    2430:	91 83       	std	Z+1, r25	; 0x01
    2432:	a2 83       	std	Z+2, r26	; 0x02
    2434:	b3 83       	std	Z+3, r27	; 0x03

			if( xShouldDelay != pdFALSE )
    2436:	89 81       	ldd	r24, Y+1	; 0x01
    2438:	88 23       	and	r24, r24
    243a:	79 f0       	breq	.+30     	; 0x245a <vTaskDelayUntil+0x132>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    243c:	80 91 18 03 	lds	r24, 0x0318
    2440:	90 91 19 03 	lds	r25, 0x0319
    2444:	02 96       	adiw	r24, 0x02	; 2
    2446:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    244a:	8b 81       	ldd	r24, Y+3	; 0x03
    244c:	9c 81       	ldd	r25, Y+4	; 0x04
    244e:	ad 81       	ldd	r26, Y+5	; 0x05
    2450:	be 81       	ldd	r27, Y+6	; 0x06
    2452:	bc 01       	movw	r22, r24
    2454:	cd 01       	movw	r24, r26
    2456:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    245a:	0e 94 de 12 	call	0x25bc	; 0x25bc <xTaskResumeAll>
    245e:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2460:	8a 81       	ldd	r24, Y+2	; 0x02
    2462:	88 23       	and	r24, r24
    2464:	11 f4       	brne	.+4      	; 0x246a <vTaskDelayUntil+0x142>
		{
			portYIELD_WITHIN_API();
    2466:	0e 94 97 0a 	call	0x152e	; 0x152e <vPortYield>
		}
	}
    246a:	2c 96       	adiw	r28, 0x0c	; 12
    246c:	0f b6       	in	r0, 0x3f	; 63
    246e:	f8 94       	cli
    2470:	de bf       	out	0x3e, r29	; 62
    2472:	0f be       	out	0x3f, r0	; 63
    2474:	cd bf       	out	0x3d, r28	; 61
    2476:	cf 91       	pop	r28
    2478:	df 91       	pop	r29
    247a:	08 95       	ret

0000247c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    247c:	df 93       	push	r29
    247e:	cf 93       	push	r28
    2480:	cd b7       	in	r28, 0x3d	; 61
    2482:	de b7       	in	r29, 0x3e	; 62
    2484:	29 97       	sbiw	r28, 0x09	; 9
    2486:	0f b6       	in	r0, 0x3f	; 63
    2488:	f8 94       	cli
    248a:	de bf       	out	0x3e, r29	; 62
    248c:	0f be       	out	0x3f, r0	; 63
    248e:	cd bf       	out	0x3d, r28	; 61
    2490:	6e 83       	std	Y+6, r22	; 0x06
    2492:	7f 83       	std	Y+7, r23	; 0x07
    2494:	88 87       	std	Y+8, r24	; 0x08
    2496:	99 87       	std	Y+9, r25	; 0x09
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2498:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    249a:	8e 81       	ldd	r24, Y+6	; 0x06
    249c:	9f 81       	ldd	r25, Y+7	; 0x07
    249e:	a8 85       	ldd	r26, Y+8	; 0x08
    24a0:	b9 85       	ldd	r27, Y+9	; 0x09
    24a2:	00 97       	sbiw	r24, 0x00	; 0
    24a4:	a1 05       	cpc	r26, r1
    24a6:	b1 05       	cpc	r27, r1
    24a8:	41 f1       	breq	.+80     	; 0x24fa <vTaskDelay+0x7e>
		{
			vTaskSuspendAll();
    24aa:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    24ae:	20 91 1c 03 	lds	r18, 0x031C
    24b2:	30 91 1d 03 	lds	r19, 0x031D
    24b6:	40 91 1e 03 	lds	r20, 0x031E
    24ba:	50 91 1f 03 	lds	r21, 0x031F
    24be:	8e 81       	ldd	r24, Y+6	; 0x06
    24c0:	9f 81       	ldd	r25, Y+7	; 0x07
    24c2:	a8 85       	ldd	r26, Y+8	; 0x08
    24c4:	b9 85       	ldd	r27, Y+9	; 0x09
    24c6:	82 0f       	add	r24, r18
    24c8:	93 1f       	adc	r25, r19
    24ca:	a4 1f       	adc	r26, r20
    24cc:	b5 1f       	adc	r27, r21
    24ce:	8a 83       	std	Y+2, r24	; 0x02
    24d0:	9b 83       	std	Y+3, r25	; 0x03
    24d2:	ac 83       	std	Y+4, r26	; 0x04
    24d4:	bd 83       	std	Y+5, r27	; 0x05

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24d6:	80 91 18 03 	lds	r24, 0x0318
    24da:	90 91 19 03 	lds	r25, 0x0319
    24de:	02 96       	adiw	r24, 0x02	; 2
    24e0:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    24e4:	8a 81       	ldd	r24, Y+2	; 0x02
    24e6:	9b 81       	ldd	r25, Y+3	; 0x03
    24e8:	ac 81       	ldd	r26, Y+4	; 0x04
    24ea:	bd 81       	ldd	r27, Y+5	; 0x05
    24ec:	bc 01       	movw	r22, r24
    24ee:	cd 01       	movw	r24, r26
    24f0:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    24f4:	0e 94 de 12 	call	0x25bc	; 0x25bc <xTaskResumeAll>
    24f8:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24fa:	89 81       	ldd	r24, Y+1	; 0x01
    24fc:	88 23       	and	r24, r24
    24fe:	11 f4       	brne	.+4      	; 0x2504 <vTaskDelay+0x88>
		{
			portYIELD_WITHIN_API();
    2500:	0e 94 97 0a 	call	0x152e	; 0x152e <vPortYield>
		}
	}
    2504:	29 96       	adiw	r28, 0x09	; 9
    2506:	0f b6       	in	r0, 0x3f	; 63
    2508:	f8 94       	cli
    250a:	de bf       	out	0x3e, r29	; 62
    250c:	0f be       	out	0x3f, r0	; 63
    250e:	cd bf       	out	0x3d, r28	; 61
    2510:	cf 91       	pop	r28
    2512:	df 91       	pop	r29
    2514:	08 95       	ret

00002516 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2516:	af 92       	push	r10
    2518:	bf 92       	push	r11
    251a:	cf 92       	push	r12
    251c:	df 92       	push	r13
    251e:	ef 92       	push	r14
    2520:	ff 92       	push	r15
    2522:	0f 93       	push	r16
    2524:	df 93       	push	r29
    2526:	cf 93       	push	r28
    2528:	0f 92       	push	r0
    252a:	cd b7       	in	r28, 0x3d	; 61
    252c:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    252e:	2a e6       	ldi	r18, 0x6A	; 106
    2530:	30 e0       	ldi	r19, 0x00	; 0
    2532:	8e ea       	ldi	r24, 0xAE	; 174
    2534:	96 e1       	ldi	r25, 0x16	; 22
    2536:	b9 01       	movw	r22, r18
    2538:	45 e5       	ldi	r20, 0x55	; 85
    253a:	50 e0       	ldi	r21, 0x00	; 0
    253c:	20 e0       	ldi	r18, 0x00	; 0
    253e:	30 e0       	ldi	r19, 0x00	; 0
    2540:	00 e0       	ldi	r16, 0x00	; 0
    2542:	ee 24       	eor	r14, r14
    2544:	ff 24       	eor	r15, r15
    2546:	cc 24       	eor	r12, r12
    2548:	dd 24       	eor	r13, r13
    254a:	aa 24       	eor	r10, r10
    254c:	bb 24       	eor	r11, r11
    254e:	0e 94 41 10 	call	0x2082	; 0x2082 <xTaskGenericCreate>
    2552:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2554:	89 81       	ldd	r24, Y+1	; 0x01
    2556:	81 30       	cpi	r24, 0x01	; 1
    2558:	71 f4       	brne	.+28     	; 0x2576 <vTaskStartScheduler+0x60>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    255a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    255c:	81 e0       	ldi	r24, 0x01	; 1
    255e:	80 93 22 03 	sts	0x0322, r24
		xTickCount = ( portTickType ) 0U;
    2562:	10 92 1c 03 	sts	0x031C, r1
    2566:	10 92 1d 03 	sts	0x031D, r1
    256a:	10 92 1e 03 	sts	0x031E, r1
    256e:	10 92 1f 03 	sts	0x031F, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2572:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2576:	0f 90       	pop	r0
    2578:	cf 91       	pop	r28
    257a:	df 91       	pop	r29
    257c:	0f 91       	pop	r16
    257e:	ff 90       	pop	r15
    2580:	ef 90       	pop	r14
    2582:	df 90       	pop	r13
    2584:	cf 90       	pop	r12
    2586:	bf 90       	pop	r11
    2588:	af 90       	pop	r10
    258a:	08 95       	ret

0000258c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    258c:	df 93       	push	r29
    258e:	cf 93       	push	r28
    2590:	cd b7       	in	r28, 0x3d	; 61
    2592:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2594:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2596:	10 92 22 03 	sts	0x0322, r1
	vPortEndScheduler();
    259a:	0e 94 90 0a 	call	0x1520	; 0x1520 <vPortEndScheduler>
}
    259e:	cf 91       	pop	r28
    25a0:	df 91       	pop	r29
    25a2:	08 95       	ret

000025a4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    25a4:	df 93       	push	r29
    25a6:	cf 93       	push	r28
    25a8:	cd b7       	in	r28, 0x3d	; 61
    25aa:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    25ac:	80 91 23 03 	lds	r24, 0x0323
    25b0:	8f 5f       	subi	r24, 0xFF	; 255
    25b2:	80 93 23 03 	sts	0x0323, r24
}
    25b6:	cf 91       	pop	r28
    25b8:	df 91       	pop	r29
    25ba:	08 95       	ret

000025bc <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    25bc:	df 93       	push	r29
    25be:	cf 93       	push	r28
    25c0:	00 d0       	rcall	.+0      	; 0x25c2 <xTaskResumeAll+0x6>
    25c2:	00 d0       	rcall	.+0      	; 0x25c4 <xTaskResumeAll+0x8>
    25c4:	cd b7       	in	r28, 0x3d	; 61
    25c6:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    25c8:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    25ca:	0f b6       	in	r0, 0x3f	; 63
    25cc:	f8 94       	cli
    25ce:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    25d0:	80 91 23 03 	lds	r24, 0x0323
    25d4:	81 50       	subi	r24, 0x01	; 1
    25d6:	80 93 23 03 	sts	0x0323, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    25da:	80 91 23 03 	lds	r24, 0x0323
    25de:	88 23       	and	r24, r24
    25e0:	09 f0       	breq	.+2      	; 0x25e4 <xTaskResumeAll+0x28>
    25e2:	6f c0       	rjmp	.+222    	; 0x26c2 <xTaskResumeAll+0x106>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    25e4:	80 91 1b 03 	lds	r24, 0x031B
    25e8:	88 23       	and	r24, r24
    25ea:	09 f4       	brne	.+2      	; 0x25ee <xTaskResumeAll+0x32>
    25ec:	6a c0       	rjmp	.+212    	; 0x26c2 <xTaskResumeAll+0x106>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    25ee:	19 82       	std	Y+1, r1	; 0x01
    25f0:	44 c0       	rjmp	.+136    	; 0x267a <xTaskResumeAll+0xbe>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    25f2:	e0 91 ee 03 	lds	r30, 0x03EE
    25f6:	f0 91 ef 03 	lds	r31, 0x03EF
    25fa:	80 85       	ldd	r24, Z+8	; 0x08
    25fc:	91 85       	ldd	r25, Z+9	; 0x09
    25fe:	9c 83       	std	Y+4, r25	; 0x04
    2600:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2602:	8b 81       	ldd	r24, Y+3	; 0x03
    2604:	9c 81       	ldd	r25, Y+4	; 0x04
    2606:	0e 96       	adiw	r24, 0x0e	; 14
    2608:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    260c:	8b 81       	ldd	r24, Y+3	; 0x03
    260e:	9c 81       	ldd	r25, Y+4	; 0x04
    2610:	02 96       	adiw	r24, 0x02	; 2
    2612:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2616:	eb 81       	ldd	r30, Y+3	; 0x03
    2618:	fc 81       	ldd	r31, Y+4	; 0x04
    261a:	92 8d       	ldd	r25, Z+26	; 0x1a
    261c:	80 91 21 03 	lds	r24, 0x0321
    2620:	89 17       	cp	r24, r25
    2622:	28 f4       	brcc	.+10     	; 0x262e <xTaskResumeAll+0x72>
    2624:	eb 81       	ldd	r30, Y+3	; 0x03
    2626:	fc 81       	ldd	r31, Y+4	; 0x04
    2628:	82 8d       	ldd	r24, Z+26	; 0x1a
    262a:	80 93 21 03 	sts	0x0321, r24
    262e:	eb 81       	ldd	r30, Y+3	; 0x03
    2630:	fc 81       	ldd	r31, Y+4	; 0x04
    2632:	82 8d       	ldd	r24, Z+26	; 0x1a
    2634:	48 2f       	mov	r20, r24
    2636:	50 e0       	ldi	r21, 0x00	; 0
    2638:	ca 01       	movw	r24, r20
    263a:	88 0f       	add	r24, r24
    263c:	99 1f       	adc	r25, r25
    263e:	9c 01       	movw	r18, r24
    2640:	22 0f       	add	r18, r18
    2642:	33 1f       	adc	r19, r19
    2644:	22 0f       	add	r18, r18
    2646:	33 1f       	adc	r19, r19
    2648:	82 0f       	add	r24, r18
    264a:	93 1f       	adc	r25, r19
    264c:	84 0f       	add	r24, r20
    264e:	95 1f       	adc	r25, r21
    2650:	88 5d       	subi	r24, 0xD8	; 216
    2652:	9c 4f       	sbci	r25, 0xFC	; 252
    2654:	2b 81       	ldd	r18, Y+3	; 0x03
    2656:	3c 81       	ldd	r19, Y+4	; 0x04
    2658:	2e 5f       	subi	r18, 0xFE	; 254
    265a:	3f 4f       	sbci	r19, 0xFF	; 255
    265c:	b9 01       	movw	r22, r18
    265e:	0e 94 63 07 	call	0xec6	; 0xec6 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2662:	eb 81       	ldd	r30, Y+3	; 0x03
    2664:	fc 81       	ldd	r31, Y+4	; 0x04
    2666:	92 8d       	ldd	r25, Z+26	; 0x1a
    2668:	e0 91 18 03 	lds	r30, 0x0318
    266c:	f0 91 19 03 	lds	r31, 0x0319
    2670:	82 8d       	ldd	r24, Z+26	; 0x1a
    2672:	98 17       	cp	r25, r24
    2674:	10 f0       	brcs	.+4      	; 0x267a <xTaskResumeAll+0xbe>
					{
						xYieldRequired = pdTRUE;
    2676:	81 e0       	ldi	r24, 0x01	; 1
    2678:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    267a:	80 91 e7 03 	lds	r24, 0x03E7
    267e:	88 23       	and	r24, r24
    2680:	09 f0       	breq	.+2      	; 0x2684 <xTaskResumeAll+0xc8>
    2682:	b7 cf       	rjmp	.-146    	; 0x25f2 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2684:	80 91 24 03 	lds	r24, 0x0324
    2688:	88 23       	and	r24, r24
    268a:	71 f0       	breq	.+28     	; 0x26a8 <xTaskResumeAll+0xec>
    268c:	07 c0       	rjmp	.+14     	; 0x269c <xTaskResumeAll+0xe0>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    268e:	0e 94 ba 13 	call	0x2774	; 0x2774 <vTaskIncrementTick>
						--uxMissedTicks;
    2692:	80 91 24 03 	lds	r24, 0x0324
    2696:	81 50       	subi	r24, 0x01	; 1
    2698:	80 93 24 03 	sts	0x0324, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    269c:	80 91 24 03 	lds	r24, 0x0324
    26a0:	88 23       	and	r24, r24
    26a2:	a9 f7       	brne	.-22     	; 0x268e <xTaskResumeAll+0xd2>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    26a4:	81 e0       	ldi	r24, 0x01	; 1
    26a6:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    26a8:	89 81       	ldd	r24, Y+1	; 0x01
    26aa:	81 30       	cpi	r24, 0x01	; 1
    26ac:	21 f0       	breq	.+8      	; 0x26b6 <xTaskResumeAll+0xfa>
    26ae:	80 91 25 03 	lds	r24, 0x0325
    26b2:	81 30       	cpi	r24, 0x01	; 1
    26b4:	31 f4       	brne	.+12     	; 0x26c2 <xTaskResumeAll+0x106>
				{
					xAlreadyYielded = pdTRUE;
    26b6:	81 e0       	ldi	r24, 0x01	; 1
    26b8:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    26ba:	10 92 25 03 	sts	0x0325, r1
					portYIELD_WITHIN_API();
    26be:	0e 94 97 0a 	call	0x152e	; 0x152e <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    26c2:	0f 90       	pop	r0
    26c4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    26c6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    26c8:	0f 90       	pop	r0
    26ca:	0f 90       	pop	r0
    26cc:	0f 90       	pop	r0
    26ce:	0f 90       	pop	r0
    26d0:	cf 91       	pop	r28
    26d2:	df 91       	pop	r29
    26d4:	08 95       	ret

000026d6 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    26d6:	df 93       	push	r29
    26d8:	cf 93       	push	r28
    26da:	00 d0       	rcall	.+0      	; 0x26dc <xTaskGetTickCount+0x6>
    26dc:	00 d0       	rcall	.+0      	; 0x26de <xTaskGetTickCount+0x8>
    26de:	cd b7       	in	r28, 0x3d	; 61
    26e0:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    26e2:	0f b6       	in	r0, 0x3f	; 63
    26e4:	f8 94       	cli
    26e6:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    26e8:	80 91 1c 03 	lds	r24, 0x031C
    26ec:	90 91 1d 03 	lds	r25, 0x031D
    26f0:	a0 91 1e 03 	lds	r26, 0x031E
    26f4:	b0 91 1f 03 	lds	r27, 0x031F
    26f8:	89 83       	std	Y+1, r24	; 0x01
    26fa:	9a 83       	std	Y+2, r25	; 0x02
    26fc:	ab 83       	std	Y+3, r26	; 0x03
    26fe:	bc 83       	std	Y+4, r27	; 0x04
	}
	taskEXIT_CRITICAL();
    2700:	0f 90       	pop	r0
    2702:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2704:	89 81       	ldd	r24, Y+1	; 0x01
    2706:	9a 81       	ldd	r25, Y+2	; 0x02
    2708:	ab 81       	ldd	r26, Y+3	; 0x03
    270a:	bc 81       	ldd	r27, Y+4	; 0x04
}
    270c:	bc 01       	movw	r22, r24
    270e:	cd 01       	movw	r24, r26
    2710:	0f 90       	pop	r0
    2712:	0f 90       	pop	r0
    2714:	0f 90       	pop	r0
    2716:	0f 90       	pop	r0
    2718:	cf 91       	pop	r28
    271a:	df 91       	pop	r29
    271c:	08 95       	ret

0000271e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    271e:	df 93       	push	r29
    2720:	cf 93       	push	r28
    2722:	00 d0       	rcall	.+0      	; 0x2724 <xTaskGetTickCountFromISR+0x6>
    2724:	00 d0       	rcall	.+0      	; 0x2726 <xTaskGetTickCountFromISR+0x8>
    2726:	0f 92       	push	r0
    2728:	cd b7       	in	r28, 0x3d	; 61
    272a:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    272c:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    272e:	80 91 1c 03 	lds	r24, 0x031C
    2732:	90 91 1d 03 	lds	r25, 0x031D
    2736:	a0 91 1e 03 	lds	r26, 0x031E
    273a:	b0 91 1f 03 	lds	r27, 0x031F
    273e:	8a 83       	std	Y+2, r24	; 0x02
    2740:	9b 83       	std	Y+3, r25	; 0x03
    2742:	ac 83       	std	Y+4, r26	; 0x04
    2744:	bd 83       	std	Y+5, r27	; 0x05
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2746:	8a 81       	ldd	r24, Y+2	; 0x02
    2748:	9b 81       	ldd	r25, Y+3	; 0x03
    274a:	ac 81       	ldd	r26, Y+4	; 0x04
    274c:	bd 81       	ldd	r27, Y+5	; 0x05
}
    274e:	bc 01       	movw	r22, r24
    2750:	cd 01       	movw	r24, r26
    2752:	0f 90       	pop	r0
    2754:	0f 90       	pop	r0
    2756:	0f 90       	pop	r0
    2758:	0f 90       	pop	r0
    275a:	0f 90       	pop	r0
    275c:	cf 91       	pop	r28
    275e:	df 91       	pop	r29
    2760:	08 95       	ret

00002762 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2762:	df 93       	push	r29
    2764:	cf 93       	push	r28
    2766:	cd b7       	in	r28, 0x3d	; 61
    2768:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    276a:	80 91 1b 03 	lds	r24, 0x031B
}
    276e:	cf 91       	pop	r28
    2770:	df 91       	pop	r29
    2772:	08 95       	ret

00002774 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2774:	df 93       	push	r29
    2776:	cf 93       	push	r28
    2778:	cd b7       	in	r28, 0x3d	; 61
    277a:	de b7       	in	r29, 0x3e	; 62
    277c:	28 97       	sbiw	r28, 0x08	; 8
    277e:	0f b6       	in	r0, 0x3f	; 63
    2780:	f8 94       	cli
    2782:	de bf       	out	0x3e, r29	; 62
    2784:	0f be       	out	0x3f, r0	; 63
    2786:	cd bf       	out	0x3d, r28	; 61
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2788:	80 91 23 03 	lds	r24, 0x0323
    278c:	88 23       	and	r24, r24
    278e:	09 f0       	breq	.+2      	; 0x2792 <vTaskIncrementTick+0x1e>
    2790:	fd c0       	rjmp	.+506    	; 0x298c <vTaskIncrementTick+0x218>
	{
		++xTickCount;
    2792:	80 91 1c 03 	lds	r24, 0x031C
    2796:	90 91 1d 03 	lds	r25, 0x031D
    279a:	a0 91 1e 03 	lds	r26, 0x031E
    279e:	b0 91 1f 03 	lds	r27, 0x031F
    27a2:	01 96       	adiw	r24, 0x01	; 1
    27a4:	a1 1d       	adc	r26, r1
    27a6:	b1 1d       	adc	r27, r1
    27a8:	80 93 1c 03 	sts	0x031C, r24
    27ac:	90 93 1d 03 	sts	0x031D, r25
    27b0:	a0 93 1e 03 	sts	0x031E, r26
    27b4:	b0 93 1f 03 	sts	0x031F, r27
		if( xTickCount == ( portTickType ) 0U )
    27b8:	80 91 1c 03 	lds	r24, 0x031C
    27bc:	90 91 1d 03 	lds	r25, 0x031D
    27c0:	a0 91 1e 03 	lds	r26, 0x031E
    27c4:	b0 91 1f 03 	lds	r27, 0x031F
    27c8:	00 97       	sbiw	r24, 0x00	; 0
    27ca:	a1 05       	cpc	r26, r1
    27cc:	b1 05       	cpc	r27, r1
    27ce:	09 f0       	breq	.+2      	; 0x27d2 <vTaskIncrementTick+0x5e>
    27d0:	46 c0       	rjmp	.+140    	; 0x285e <vTaskIncrementTick+0xea>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    27d2:	80 91 e3 03 	lds	r24, 0x03E3
    27d6:	90 91 e4 03 	lds	r25, 0x03E4
    27da:	9e 83       	std	Y+6, r25	; 0x06
    27dc:	8d 83       	std	Y+5, r24	; 0x05
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    27de:	80 91 e5 03 	lds	r24, 0x03E5
    27e2:	90 91 e6 03 	lds	r25, 0x03E6
    27e6:	90 93 e4 03 	sts	0x03E4, r25
    27ea:	80 93 e3 03 	sts	0x03E3, r24
			pxOverflowDelayedTaskList = pxTemp;
    27ee:	8d 81       	ldd	r24, Y+5	; 0x05
    27f0:	9e 81       	ldd	r25, Y+6	; 0x06
    27f2:	90 93 e6 03 	sts	0x03E6, r25
    27f6:	80 93 e5 03 	sts	0x03E5, r24
			xNumOfOverflows++;
    27fa:	80 91 26 03 	lds	r24, 0x0326
    27fe:	8f 5f       	subi	r24, 0xFF	; 255
    2800:	80 93 26 03 	sts	0x0326, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2804:	e0 91 e3 03 	lds	r30, 0x03E3
    2808:	f0 91 e4 03 	lds	r31, 0x03E4
    280c:	80 81       	ld	r24, Z
    280e:	88 23       	and	r24, r24
    2810:	69 f4       	brne	.+26     	; 0x282c <vTaskIncrementTick+0xb8>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2812:	8f ef       	ldi	r24, 0xFF	; 255
    2814:	9f ef       	ldi	r25, 0xFF	; 255
    2816:	af ef       	ldi	r26, 0xFF	; 255
    2818:	bf ef       	ldi	r27, 0xFF	; 255
    281a:	80 93 6f 00 	sts	0x006F, r24
    281e:	90 93 70 00 	sts	0x0070, r25
    2822:	a0 93 71 00 	sts	0x0071, r26
    2826:	b0 93 72 00 	sts	0x0072, r27
    282a:	19 c0       	rjmp	.+50     	; 0x285e <vTaskIncrementTick+0xea>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    282c:	e0 91 e3 03 	lds	r30, 0x03E3
    2830:	f0 91 e4 03 	lds	r31, 0x03E4
    2834:	07 80       	ldd	r0, Z+7	; 0x07
    2836:	f0 85       	ldd	r31, Z+8	; 0x08
    2838:	e0 2d       	mov	r30, r0
    283a:	80 85       	ldd	r24, Z+8	; 0x08
    283c:	91 85       	ldd	r25, Z+9	; 0x09
    283e:	98 87       	std	Y+8, r25	; 0x08
    2840:	8f 83       	std	Y+7, r24	; 0x07
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2842:	ef 81       	ldd	r30, Y+7	; 0x07
    2844:	f8 85       	ldd	r31, Y+8	; 0x08
    2846:	82 81       	ldd	r24, Z+2	; 0x02
    2848:	93 81       	ldd	r25, Z+3	; 0x03
    284a:	a4 81       	ldd	r26, Z+4	; 0x04
    284c:	b5 81       	ldd	r27, Z+5	; 0x05
    284e:	80 93 6f 00 	sts	0x006F, r24
    2852:	90 93 70 00 	sts	0x0070, r25
    2856:	a0 93 71 00 	sts	0x0071, r26
    285a:	b0 93 72 00 	sts	0x0072, r27
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    285e:	20 91 1c 03 	lds	r18, 0x031C
    2862:	30 91 1d 03 	lds	r19, 0x031D
    2866:	40 91 1e 03 	lds	r20, 0x031E
    286a:	50 91 1f 03 	lds	r21, 0x031F
    286e:	80 91 6f 00 	lds	r24, 0x006F
    2872:	90 91 70 00 	lds	r25, 0x0070
    2876:	a0 91 71 00 	lds	r26, 0x0071
    287a:	b0 91 72 00 	lds	r27, 0x0072
    287e:	28 17       	cp	r18, r24
    2880:	39 07       	cpc	r19, r25
    2882:	4a 07       	cpc	r20, r26
    2884:	5b 07       	cpc	r21, r27
    2886:	08 f4       	brcc	.+2      	; 0x288a <vTaskIncrementTick+0x116>
    2888:	86 c0       	rjmp	.+268    	; 0x2996 <vTaskIncrementTick+0x222>
    288a:	e0 91 e3 03 	lds	r30, 0x03E3
    288e:	f0 91 e4 03 	lds	r31, 0x03E4
    2892:	80 81       	ld	r24, Z
    2894:	88 23       	and	r24, r24
    2896:	69 f4       	brne	.+26     	; 0x28b2 <vTaskIncrementTick+0x13e>
    2898:	8f ef       	ldi	r24, 0xFF	; 255
    289a:	9f ef       	ldi	r25, 0xFF	; 255
    289c:	af ef       	ldi	r26, 0xFF	; 255
    289e:	bf ef       	ldi	r27, 0xFF	; 255
    28a0:	80 93 6f 00 	sts	0x006F, r24
    28a4:	90 93 70 00 	sts	0x0070, r25
    28a8:	a0 93 71 00 	sts	0x0071, r26
    28ac:	b0 93 72 00 	sts	0x0072, r27
    28b0:	72 c0       	rjmp	.+228    	; 0x2996 <vTaskIncrementTick+0x222>
    28b2:	e0 91 e3 03 	lds	r30, 0x03E3
    28b6:	f0 91 e4 03 	lds	r31, 0x03E4
    28ba:	07 80       	ldd	r0, Z+7	; 0x07
    28bc:	f0 85       	ldd	r31, Z+8	; 0x08
    28be:	e0 2d       	mov	r30, r0
    28c0:	80 85       	ldd	r24, Z+8	; 0x08
    28c2:	91 85       	ldd	r25, Z+9	; 0x09
    28c4:	98 87       	std	Y+8, r25	; 0x08
    28c6:	8f 83       	std	Y+7, r24	; 0x07
    28c8:	ef 81       	ldd	r30, Y+7	; 0x07
    28ca:	f8 85       	ldd	r31, Y+8	; 0x08
    28cc:	82 81       	ldd	r24, Z+2	; 0x02
    28ce:	93 81       	ldd	r25, Z+3	; 0x03
    28d0:	a4 81       	ldd	r26, Z+4	; 0x04
    28d2:	b5 81       	ldd	r27, Z+5	; 0x05
    28d4:	89 83       	std	Y+1, r24	; 0x01
    28d6:	9a 83       	std	Y+2, r25	; 0x02
    28d8:	ab 83       	std	Y+3, r26	; 0x03
    28da:	bc 83       	std	Y+4, r27	; 0x04
    28dc:	20 91 1c 03 	lds	r18, 0x031C
    28e0:	30 91 1d 03 	lds	r19, 0x031D
    28e4:	40 91 1e 03 	lds	r20, 0x031E
    28e8:	50 91 1f 03 	lds	r21, 0x031F
    28ec:	89 81       	ldd	r24, Y+1	; 0x01
    28ee:	9a 81       	ldd	r25, Y+2	; 0x02
    28f0:	ab 81       	ldd	r26, Y+3	; 0x03
    28f2:	bc 81       	ldd	r27, Y+4	; 0x04
    28f4:	28 17       	cp	r18, r24
    28f6:	39 07       	cpc	r19, r25
    28f8:	4a 07       	cpc	r20, r26
    28fa:	5b 07       	cpc	r21, r27
    28fc:	68 f4       	brcc	.+26     	; 0x2918 <vTaskIncrementTick+0x1a4>
    28fe:	89 81       	ldd	r24, Y+1	; 0x01
    2900:	9a 81       	ldd	r25, Y+2	; 0x02
    2902:	ab 81       	ldd	r26, Y+3	; 0x03
    2904:	bc 81       	ldd	r27, Y+4	; 0x04
    2906:	80 93 6f 00 	sts	0x006F, r24
    290a:	90 93 70 00 	sts	0x0070, r25
    290e:	a0 93 71 00 	sts	0x0071, r26
    2912:	b0 93 72 00 	sts	0x0072, r27
    2916:	3f c0       	rjmp	.+126    	; 0x2996 <vTaskIncrementTick+0x222>
    2918:	8f 81       	ldd	r24, Y+7	; 0x07
    291a:	98 85       	ldd	r25, Y+8	; 0x08
    291c:	02 96       	adiw	r24, 0x02	; 2
    291e:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
    2922:	ef 81       	ldd	r30, Y+7	; 0x07
    2924:	f8 85       	ldd	r31, Y+8	; 0x08
    2926:	80 8d       	ldd	r24, Z+24	; 0x18
    2928:	91 8d       	ldd	r25, Z+25	; 0x19
    292a:	00 97       	sbiw	r24, 0x00	; 0
    292c:	29 f0       	breq	.+10     	; 0x2938 <vTaskIncrementTick+0x1c4>
    292e:	8f 81       	ldd	r24, Y+7	; 0x07
    2930:	98 85       	ldd	r25, Y+8	; 0x08
    2932:	0e 96       	adiw	r24, 0x0e	; 14
    2934:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
    2938:	ef 81       	ldd	r30, Y+7	; 0x07
    293a:	f8 85       	ldd	r31, Y+8	; 0x08
    293c:	92 8d       	ldd	r25, Z+26	; 0x1a
    293e:	80 91 21 03 	lds	r24, 0x0321
    2942:	89 17       	cp	r24, r25
    2944:	28 f4       	brcc	.+10     	; 0x2950 <vTaskIncrementTick+0x1dc>
    2946:	ef 81       	ldd	r30, Y+7	; 0x07
    2948:	f8 85       	ldd	r31, Y+8	; 0x08
    294a:	82 8d       	ldd	r24, Z+26	; 0x1a
    294c:	80 93 21 03 	sts	0x0321, r24
    2950:	ef 81       	ldd	r30, Y+7	; 0x07
    2952:	f8 85       	ldd	r31, Y+8	; 0x08
    2954:	82 8d       	ldd	r24, Z+26	; 0x1a
    2956:	48 2f       	mov	r20, r24
    2958:	50 e0       	ldi	r21, 0x00	; 0
    295a:	ca 01       	movw	r24, r20
    295c:	88 0f       	add	r24, r24
    295e:	99 1f       	adc	r25, r25
    2960:	9c 01       	movw	r18, r24
    2962:	22 0f       	add	r18, r18
    2964:	33 1f       	adc	r19, r19
    2966:	22 0f       	add	r18, r18
    2968:	33 1f       	adc	r19, r19
    296a:	82 0f       	add	r24, r18
    296c:	93 1f       	adc	r25, r19
    296e:	84 0f       	add	r24, r20
    2970:	95 1f       	adc	r25, r21
    2972:	ac 01       	movw	r20, r24
    2974:	48 5d       	subi	r20, 0xD8	; 216
    2976:	5c 4f       	sbci	r21, 0xFC	; 252
    2978:	8f 81       	ldd	r24, Y+7	; 0x07
    297a:	98 85       	ldd	r25, Y+8	; 0x08
    297c:	9c 01       	movw	r18, r24
    297e:	2e 5f       	subi	r18, 0xFE	; 254
    2980:	3f 4f       	sbci	r19, 0xFF	; 255
    2982:	ca 01       	movw	r24, r20
    2984:	b9 01       	movw	r22, r18
    2986:	0e 94 63 07 	call	0xec6	; 0xec6 <vListInsertEnd>
    298a:	7f cf       	rjmp	.-258    	; 0x288a <vTaskIncrementTick+0x116>
	}
	else
	{
		++uxMissedTicks;
    298c:	80 91 24 03 	lds	r24, 0x0324
    2990:	8f 5f       	subi	r24, 0xFF	; 255
    2992:	80 93 24 03 	sts	0x0324, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2996:	28 96       	adiw	r28, 0x08	; 8
    2998:	0f b6       	in	r0, 0x3f	; 63
    299a:	f8 94       	cli
    299c:	de bf       	out	0x3e, r29	; 62
    299e:	0f be       	out	0x3f, r0	; 63
    29a0:	cd bf       	out	0x3d, r28	; 61
    29a2:	cf 91       	pop	r28
    29a4:	df 91       	pop	r29
    29a6:	08 95       	ret

000029a8 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    29a8:	df 93       	push	r29
    29aa:	cf 93       	push	r28
    29ac:	00 d0       	rcall	.+0      	; 0x29ae <vTaskSwitchContext+0x6>
    29ae:	cd b7       	in	r28, 0x3d	; 61
    29b0:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    29b2:	80 91 23 03 	lds	r24, 0x0323
    29b6:	88 23       	and	r24, r24
    29b8:	49 f0       	breq	.+18     	; 0x29cc <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    29ba:	81 e0       	ldi	r24, 0x01	; 1
    29bc:	80 93 25 03 	sts	0x0325, r24
    29c0:	5a c0       	rjmp	.+180    	; 0x2a76 <vTaskSwitchContext+0xce>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    29c2:	80 91 21 03 	lds	r24, 0x0321
    29c6:	81 50       	subi	r24, 0x01	; 1
    29c8:	80 93 21 03 	sts	0x0321, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    29cc:	80 91 21 03 	lds	r24, 0x0321
    29d0:	48 2f       	mov	r20, r24
    29d2:	50 e0       	ldi	r21, 0x00	; 0
    29d4:	ca 01       	movw	r24, r20
    29d6:	88 0f       	add	r24, r24
    29d8:	99 1f       	adc	r25, r25
    29da:	9c 01       	movw	r18, r24
    29dc:	22 0f       	add	r18, r18
    29de:	33 1f       	adc	r19, r19
    29e0:	22 0f       	add	r18, r18
    29e2:	33 1f       	adc	r19, r19
    29e4:	82 0f       	add	r24, r18
    29e6:	93 1f       	adc	r25, r19
    29e8:	84 0f       	add	r24, r20
    29ea:	95 1f       	adc	r25, r21
    29ec:	fc 01       	movw	r30, r24
    29ee:	e8 5d       	subi	r30, 0xD8	; 216
    29f0:	fc 4f       	sbci	r31, 0xFC	; 252
    29f2:	80 81       	ld	r24, Z
    29f4:	88 23       	and	r24, r24
    29f6:	29 f3       	breq	.-54     	; 0x29c2 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    29f8:	80 91 21 03 	lds	r24, 0x0321
    29fc:	48 2f       	mov	r20, r24
    29fe:	50 e0       	ldi	r21, 0x00	; 0
    2a00:	ca 01       	movw	r24, r20
    2a02:	88 0f       	add	r24, r24
    2a04:	99 1f       	adc	r25, r25
    2a06:	9c 01       	movw	r18, r24
    2a08:	22 0f       	add	r18, r18
    2a0a:	33 1f       	adc	r19, r19
    2a0c:	22 0f       	add	r18, r18
    2a0e:	33 1f       	adc	r19, r19
    2a10:	82 0f       	add	r24, r18
    2a12:	93 1f       	adc	r25, r19
    2a14:	84 0f       	add	r24, r20
    2a16:	95 1f       	adc	r25, r21
    2a18:	88 5d       	subi	r24, 0xD8	; 216
    2a1a:	9c 4f       	sbci	r25, 0xFC	; 252
    2a1c:	9a 83       	std	Y+2, r25	; 0x02
    2a1e:	89 83       	std	Y+1, r24	; 0x01
    2a20:	e9 81       	ldd	r30, Y+1	; 0x01
    2a22:	fa 81       	ldd	r31, Y+2	; 0x02
    2a24:	01 80       	ldd	r0, Z+1	; 0x01
    2a26:	f2 81       	ldd	r31, Z+2	; 0x02
    2a28:	e0 2d       	mov	r30, r0
    2a2a:	84 81       	ldd	r24, Z+4	; 0x04
    2a2c:	95 81       	ldd	r25, Z+5	; 0x05
    2a2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a30:	fa 81       	ldd	r31, Y+2	; 0x02
    2a32:	92 83       	std	Z+2, r25	; 0x02
    2a34:	81 83       	std	Z+1, r24	; 0x01
    2a36:	e9 81       	ldd	r30, Y+1	; 0x01
    2a38:	fa 81       	ldd	r31, Y+2	; 0x02
    2a3a:	21 81       	ldd	r18, Z+1	; 0x01
    2a3c:	32 81       	ldd	r19, Z+2	; 0x02
    2a3e:	89 81       	ldd	r24, Y+1	; 0x01
    2a40:	9a 81       	ldd	r25, Y+2	; 0x02
    2a42:	03 96       	adiw	r24, 0x03	; 3
    2a44:	28 17       	cp	r18, r24
    2a46:	39 07       	cpc	r19, r25
    2a48:	59 f4       	brne	.+22     	; 0x2a60 <vTaskSwitchContext+0xb8>
    2a4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a4e:	01 80       	ldd	r0, Z+1	; 0x01
    2a50:	f2 81       	ldd	r31, Z+2	; 0x02
    2a52:	e0 2d       	mov	r30, r0
    2a54:	84 81       	ldd	r24, Z+4	; 0x04
    2a56:	95 81       	ldd	r25, Z+5	; 0x05
    2a58:	e9 81       	ldd	r30, Y+1	; 0x01
    2a5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a5c:	92 83       	std	Z+2, r25	; 0x02
    2a5e:	81 83       	std	Z+1, r24	; 0x01
    2a60:	e9 81       	ldd	r30, Y+1	; 0x01
    2a62:	fa 81       	ldd	r31, Y+2	; 0x02
    2a64:	01 80       	ldd	r0, Z+1	; 0x01
    2a66:	f2 81       	ldd	r31, Z+2	; 0x02
    2a68:	e0 2d       	mov	r30, r0
    2a6a:	80 85       	ldd	r24, Z+8	; 0x08
    2a6c:	91 85       	ldd	r25, Z+9	; 0x09
    2a6e:	90 93 19 03 	sts	0x0319, r25
    2a72:	80 93 18 03 	sts	0x0318, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2a76:	0f 90       	pop	r0
    2a78:	0f 90       	pop	r0
    2a7a:	cf 91       	pop	r28
    2a7c:	df 91       	pop	r29
    2a7e:	08 95       	ret

00002a80 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2a80:	df 93       	push	r29
    2a82:	cf 93       	push	r28
    2a84:	cd b7       	in	r28, 0x3d	; 61
    2a86:	de b7       	in	r29, 0x3e	; 62
    2a88:	2a 97       	sbiw	r28, 0x0a	; 10
    2a8a:	0f b6       	in	r0, 0x3f	; 63
    2a8c:	f8 94       	cli
    2a8e:	de bf       	out	0x3e, r29	; 62
    2a90:	0f be       	out	0x3f, r0	; 63
    2a92:	cd bf       	out	0x3d, r28	; 61
    2a94:	9e 83       	std	Y+6, r25	; 0x06
    2a96:	8d 83       	std	Y+5, r24	; 0x05
    2a98:	4f 83       	std	Y+7, r20	; 0x07
    2a9a:	58 87       	std	Y+8, r21	; 0x08
    2a9c:	69 87       	std	Y+9, r22	; 0x09
    2a9e:	7a 87       	std	Y+10, r23	; 0x0a
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2aa0:	4d 81       	ldd	r20, Y+5	; 0x05
    2aa2:	5e 81       	ldd	r21, Y+6	; 0x06
    2aa4:	80 91 18 03 	lds	r24, 0x0318
    2aa8:	90 91 19 03 	lds	r25, 0x0319
    2aac:	9c 01       	movw	r18, r24
    2aae:	22 5f       	subi	r18, 0xF2	; 242
    2ab0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ab2:	ca 01       	movw	r24, r20
    2ab4:	b9 01       	movw	r22, r18
    2ab6:	0e 94 af 07 	call	0xf5e	; 0xf5e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2aba:	80 91 18 03 	lds	r24, 0x0318
    2abe:	90 91 19 03 	lds	r25, 0x0319
    2ac2:	02 96       	adiw	r24, 0x02	; 2
    2ac4:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2ac8:	20 91 1c 03 	lds	r18, 0x031C
    2acc:	30 91 1d 03 	lds	r19, 0x031D
    2ad0:	40 91 1e 03 	lds	r20, 0x031E
    2ad4:	50 91 1f 03 	lds	r21, 0x031F
    2ad8:	8f 81       	ldd	r24, Y+7	; 0x07
    2ada:	98 85       	ldd	r25, Y+8	; 0x08
    2adc:	a9 85       	ldd	r26, Y+9	; 0x09
    2ade:	ba 85       	ldd	r27, Y+10	; 0x0a
    2ae0:	82 0f       	add	r24, r18
    2ae2:	93 1f       	adc	r25, r19
    2ae4:	a4 1f       	adc	r26, r20
    2ae6:	b5 1f       	adc	r27, r21
    2ae8:	89 83       	std	Y+1, r24	; 0x01
    2aea:	9a 83       	std	Y+2, r25	; 0x02
    2aec:	ab 83       	std	Y+3, r26	; 0x03
    2aee:	bc 83       	std	Y+4, r27	; 0x04
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2af0:	89 81       	ldd	r24, Y+1	; 0x01
    2af2:	9a 81       	ldd	r25, Y+2	; 0x02
    2af4:	ab 81       	ldd	r26, Y+3	; 0x03
    2af6:	bc 81       	ldd	r27, Y+4	; 0x04
    2af8:	bc 01       	movw	r22, r24
    2afa:	cd 01       	movw	r24, r26
    2afc:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2b00:	2a 96       	adiw	r28, 0x0a	; 10
    2b02:	0f b6       	in	r0, 0x3f	; 63
    2b04:	f8 94       	cli
    2b06:	de bf       	out	0x3e, r29	; 62
    2b08:	0f be       	out	0x3f, r0	; 63
    2b0a:	cd bf       	out	0x3d, r28	; 61
    2b0c:	cf 91       	pop	r28
    2b0e:	df 91       	pop	r29
    2b10:	08 95       	ret

00002b12 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2b12:	df 93       	push	r29
    2b14:	cf 93       	push	r28
    2b16:	00 d0       	rcall	.+0      	; 0x2b18 <xTaskRemoveFromEventList+0x6>
    2b18:	00 d0       	rcall	.+0      	; 0x2b1a <xTaskRemoveFromEventList+0x8>
    2b1a:	0f 92       	push	r0
    2b1c:	cd b7       	in	r28, 0x3d	; 61
    2b1e:	de b7       	in	r29, 0x3e	; 62
    2b20:	9d 83       	std	Y+5, r25	; 0x05
    2b22:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2b24:	ec 81       	ldd	r30, Y+4	; 0x04
    2b26:	fd 81       	ldd	r31, Y+5	; 0x05
    2b28:	07 80       	ldd	r0, Z+7	; 0x07
    2b2a:	f0 85       	ldd	r31, Z+8	; 0x08
    2b2c:	e0 2d       	mov	r30, r0
    2b2e:	80 85       	ldd	r24, Z+8	; 0x08
    2b30:	91 85       	ldd	r25, Z+9	; 0x09
    2b32:	9b 83       	std	Y+3, r25	; 0x03
    2b34:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2b36:	8a 81       	ldd	r24, Y+2	; 0x02
    2b38:	9b 81       	ldd	r25, Y+3	; 0x03
    2b3a:	0e 96       	adiw	r24, 0x0e	; 14
    2b3c:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2b40:	80 91 23 03 	lds	r24, 0x0323
    2b44:	88 23       	and	r24, r24
    2b46:	79 f5       	brne	.+94     	; 0x2ba6 <xTaskRemoveFromEventList+0x94>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2b48:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b4c:	02 96       	adiw	r24, 0x02	; 2
    2b4e:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2b52:	ea 81       	ldd	r30, Y+2	; 0x02
    2b54:	fb 81       	ldd	r31, Y+3	; 0x03
    2b56:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b58:	80 91 21 03 	lds	r24, 0x0321
    2b5c:	89 17       	cp	r24, r25
    2b5e:	28 f4       	brcc	.+10     	; 0x2b6a <xTaskRemoveFromEventList+0x58>
    2b60:	ea 81       	ldd	r30, Y+2	; 0x02
    2b62:	fb 81       	ldd	r31, Y+3	; 0x03
    2b64:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b66:	80 93 21 03 	sts	0x0321, r24
    2b6a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b6c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b70:	48 2f       	mov	r20, r24
    2b72:	50 e0       	ldi	r21, 0x00	; 0
    2b74:	ca 01       	movw	r24, r20
    2b76:	88 0f       	add	r24, r24
    2b78:	99 1f       	adc	r25, r25
    2b7a:	9c 01       	movw	r18, r24
    2b7c:	22 0f       	add	r18, r18
    2b7e:	33 1f       	adc	r19, r19
    2b80:	22 0f       	add	r18, r18
    2b82:	33 1f       	adc	r19, r19
    2b84:	82 0f       	add	r24, r18
    2b86:	93 1f       	adc	r25, r19
    2b88:	84 0f       	add	r24, r20
    2b8a:	95 1f       	adc	r25, r21
    2b8c:	ac 01       	movw	r20, r24
    2b8e:	48 5d       	subi	r20, 0xD8	; 216
    2b90:	5c 4f       	sbci	r21, 0xFC	; 252
    2b92:	8a 81       	ldd	r24, Y+2	; 0x02
    2b94:	9b 81       	ldd	r25, Y+3	; 0x03
    2b96:	9c 01       	movw	r18, r24
    2b98:	2e 5f       	subi	r18, 0xFE	; 254
    2b9a:	3f 4f       	sbci	r19, 0xFF	; 255
    2b9c:	ca 01       	movw	r24, r20
    2b9e:	b9 01       	movw	r22, r18
    2ba0:	0e 94 63 07 	call	0xec6	; 0xec6 <vListInsertEnd>
    2ba4:	0a c0       	rjmp	.+20     	; 0x2bba <xTaskRemoveFromEventList+0xa8>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2ba6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ba8:	9b 81       	ldd	r25, Y+3	; 0x03
    2baa:	9c 01       	movw	r18, r24
    2bac:	22 5f       	subi	r18, 0xF2	; 242
    2bae:	3f 4f       	sbci	r19, 0xFF	; 255
    2bb0:	87 ee       	ldi	r24, 0xE7	; 231
    2bb2:	93 e0       	ldi	r25, 0x03	; 3
    2bb4:	b9 01       	movw	r22, r18
    2bb6:	0e 94 63 07 	call	0xec6	; 0xec6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2bba:	ea 81       	ldd	r30, Y+2	; 0x02
    2bbc:	fb 81       	ldd	r31, Y+3	; 0x03
    2bbe:	92 8d       	ldd	r25, Z+26	; 0x1a
    2bc0:	e0 91 18 03 	lds	r30, 0x0318
    2bc4:	f0 91 19 03 	lds	r31, 0x0319
    2bc8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bca:	98 17       	cp	r25, r24
    2bcc:	18 f0       	brcs	.+6      	; 0x2bd4 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2bce:	81 e0       	ldi	r24, 0x01	; 1
    2bd0:	89 83       	std	Y+1, r24	; 0x01
    2bd2:	01 c0       	rjmp	.+2      	; 0x2bd6 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    2bd4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2bd6:	89 81       	ldd	r24, Y+1	; 0x01
}
    2bd8:	0f 90       	pop	r0
    2bda:	0f 90       	pop	r0
    2bdc:	0f 90       	pop	r0
    2bde:	0f 90       	pop	r0
    2be0:	0f 90       	pop	r0
    2be2:	cf 91       	pop	r28
    2be4:	df 91       	pop	r29
    2be6:	08 95       	ret

00002be8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2be8:	df 93       	push	r29
    2bea:	cf 93       	push	r28
    2bec:	00 d0       	rcall	.+0      	; 0x2bee <vTaskSetTimeOutState+0x6>
    2bee:	cd b7       	in	r28, 0x3d	; 61
    2bf0:	de b7       	in	r29, 0x3e	; 62
    2bf2:	9a 83       	std	Y+2, r25	; 0x02
    2bf4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2bf6:	80 91 26 03 	lds	r24, 0x0326
    2bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    2bfe:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2c00:	80 91 1c 03 	lds	r24, 0x031C
    2c04:	90 91 1d 03 	lds	r25, 0x031D
    2c08:	a0 91 1e 03 	lds	r26, 0x031E
    2c0c:	b0 91 1f 03 	lds	r27, 0x031F
    2c10:	e9 81       	ldd	r30, Y+1	; 0x01
    2c12:	fa 81       	ldd	r31, Y+2	; 0x02
    2c14:	81 83       	std	Z+1, r24	; 0x01
    2c16:	92 83       	std	Z+2, r25	; 0x02
    2c18:	a3 83       	std	Z+3, r26	; 0x03
    2c1a:	b4 83       	std	Z+4, r27	; 0x04
}
    2c1c:	0f 90       	pop	r0
    2c1e:	0f 90       	pop	r0
    2c20:	cf 91       	pop	r28
    2c22:	df 91       	pop	r29
    2c24:	08 95       	ret

00002c26 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2c26:	af 92       	push	r10
    2c28:	bf 92       	push	r11
    2c2a:	cf 92       	push	r12
    2c2c:	df 92       	push	r13
    2c2e:	ef 92       	push	r14
    2c30:	ff 92       	push	r15
    2c32:	0f 93       	push	r16
    2c34:	1f 93       	push	r17
    2c36:	df 93       	push	r29
    2c38:	cf 93       	push	r28
    2c3a:	00 d0       	rcall	.+0      	; 0x2c3c <xTaskCheckForTimeOut+0x16>
    2c3c:	00 d0       	rcall	.+0      	; 0x2c3e <xTaskCheckForTimeOut+0x18>
    2c3e:	0f 92       	push	r0
    2c40:	cd b7       	in	r28, 0x3d	; 61
    2c42:	de b7       	in	r29, 0x3e	; 62
    2c44:	9b 83       	std	Y+3, r25	; 0x03
    2c46:	8a 83       	std	Y+2, r24	; 0x02
    2c48:	7d 83       	std	Y+5, r23	; 0x05
    2c4a:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2c4c:	0f b6       	in	r0, 0x3f	; 63
    2c4e:	f8 94       	cli
    2c50:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2c52:	ea 81       	ldd	r30, Y+2	; 0x02
    2c54:	fb 81       	ldd	r31, Y+3	; 0x03
    2c56:	90 81       	ld	r25, Z
    2c58:	80 91 26 03 	lds	r24, 0x0326
    2c5c:	98 17       	cp	r25, r24
    2c5e:	b1 f0       	breq	.+44     	; 0x2c8c <xTaskCheckForTimeOut+0x66>
    2c60:	ea 81       	ldd	r30, Y+2	; 0x02
    2c62:	fb 81       	ldd	r31, Y+3	; 0x03
    2c64:	21 81       	ldd	r18, Z+1	; 0x01
    2c66:	32 81       	ldd	r19, Z+2	; 0x02
    2c68:	43 81       	ldd	r20, Z+3	; 0x03
    2c6a:	54 81       	ldd	r21, Z+4	; 0x04
    2c6c:	80 91 1c 03 	lds	r24, 0x031C
    2c70:	90 91 1d 03 	lds	r25, 0x031D
    2c74:	a0 91 1e 03 	lds	r26, 0x031E
    2c78:	b0 91 1f 03 	lds	r27, 0x031F
    2c7c:	82 17       	cp	r24, r18
    2c7e:	93 07       	cpc	r25, r19
    2c80:	a4 07       	cpc	r26, r20
    2c82:	b5 07       	cpc	r27, r21
    2c84:	18 f0       	brcs	.+6      	; 0x2c8c <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2c86:	81 e0       	ldi	r24, 0x01	; 1
    2c88:	89 83       	std	Y+1, r24	; 0x01
    2c8a:	4b c0       	rjmp	.+150    	; 0x2d22 <xTaskCheckForTimeOut+0xfc>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2c8c:	20 91 1c 03 	lds	r18, 0x031C
    2c90:	30 91 1d 03 	lds	r19, 0x031D
    2c94:	40 91 1e 03 	lds	r20, 0x031E
    2c98:	50 91 1f 03 	lds	r21, 0x031F
    2c9c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c9e:	fb 81       	ldd	r31, Y+3	; 0x03
    2ca0:	81 81       	ldd	r24, Z+1	; 0x01
    2ca2:	92 81       	ldd	r25, Z+2	; 0x02
    2ca4:	a3 81       	ldd	r26, Z+3	; 0x03
    2ca6:	b4 81       	ldd	r27, Z+4	; 0x04
    2ca8:	28 1b       	sub	r18, r24
    2caa:	39 0b       	sbc	r19, r25
    2cac:	4a 0b       	sbc	r20, r26
    2cae:	5b 0b       	sbc	r21, r27
    2cb0:	ec 81       	ldd	r30, Y+4	; 0x04
    2cb2:	fd 81       	ldd	r31, Y+5	; 0x05
    2cb4:	80 81       	ld	r24, Z
    2cb6:	91 81       	ldd	r25, Z+1	; 0x01
    2cb8:	a2 81       	ldd	r26, Z+2	; 0x02
    2cba:	b3 81       	ldd	r27, Z+3	; 0x03
    2cbc:	28 17       	cp	r18, r24
    2cbe:	39 07       	cpc	r19, r25
    2cc0:	4a 07       	cpc	r20, r26
    2cc2:	5b 07       	cpc	r21, r27
    2cc4:	60 f5       	brcc	.+88     	; 0x2d1e <xTaskCheckForTimeOut+0xf8>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2cc6:	ec 81       	ldd	r30, Y+4	; 0x04
    2cc8:	fd 81       	ldd	r31, Y+5	; 0x05
    2cca:	e0 80       	ld	r14, Z
    2ccc:	f1 80       	ldd	r15, Z+1	; 0x01
    2cce:	02 81       	ldd	r16, Z+2	; 0x02
    2cd0:	13 81       	ldd	r17, Z+3	; 0x03
    2cd2:	ea 81       	ldd	r30, Y+2	; 0x02
    2cd4:	fb 81       	ldd	r31, Y+3	; 0x03
    2cd6:	21 81       	ldd	r18, Z+1	; 0x01
    2cd8:	32 81       	ldd	r19, Z+2	; 0x02
    2cda:	43 81       	ldd	r20, Z+3	; 0x03
    2cdc:	54 81       	ldd	r21, Z+4	; 0x04
    2cde:	80 91 1c 03 	lds	r24, 0x031C
    2ce2:	90 91 1d 03 	lds	r25, 0x031D
    2ce6:	a0 91 1e 03 	lds	r26, 0x031E
    2cea:	b0 91 1f 03 	lds	r27, 0x031F
    2cee:	59 01       	movw	r10, r18
    2cf0:	6a 01       	movw	r12, r20
    2cf2:	a8 1a       	sub	r10, r24
    2cf4:	b9 0a       	sbc	r11, r25
    2cf6:	ca 0a       	sbc	r12, r26
    2cf8:	db 0a       	sbc	r13, r27
    2cfa:	d6 01       	movw	r26, r12
    2cfc:	c5 01       	movw	r24, r10
    2cfe:	8e 0d       	add	r24, r14
    2d00:	9f 1d       	adc	r25, r15
    2d02:	a0 1f       	adc	r26, r16
    2d04:	b1 1f       	adc	r27, r17
    2d06:	ec 81       	ldd	r30, Y+4	; 0x04
    2d08:	fd 81       	ldd	r31, Y+5	; 0x05
    2d0a:	80 83       	st	Z, r24
    2d0c:	91 83       	std	Z+1, r25	; 0x01
    2d0e:	a2 83       	std	Z+2, r26	; 0x02
    2d10:	b3 83       	std	Z+3, r27	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2d12:	8a 81       	ldd	r24, Y+2	; 0x02
    2d14:	9b 81       	ldd	r25, Y+3	; 0x03
    2d16:	0e 94 f4 15 	call	0x2be8	; 0x2be8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2d1a:	19 82       	std	Y+1, r1	; 0x01
    2d1c:	02 c0       	rjmp	.+4      	; 0x2d22 <xTaskCheckForTimeOut+0xfc>
		}
		else
		{
			xReturn = pdTRUE;
    2d1e:	81 e0       	ldi	r24, 0x01	; 1
    2d20:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2d22:	0f 90       	pop	r0
    2d24:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2d26:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d28:	0f 90       	pop	r0
    2d2a:	0f 90       	pop	r0
    2d2c:	0f 90       	pop	r0
    2d2e:	0f 90       	pop	r0
    2d30:	0f 90       	pop	r0
    2d32:	cf 91       	pop	r28
    2d34:	df 91       	pop	r29
    2d36:	1f 91       	pop	r17
    2d38:	0f 91       	pop	r16
    2d3a:	ff 90       	pop	r15
    2d3c:	ef 90       	pop	r14
    2d3e:	df 90       	pop	r13
    2d40:	cf 90       	pop	r12
    2d42:	bf 90       	pop	r11
    2d44:	af 90       	pop	r10
    2d46:	08 95       	ret

00002d48 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2d48:	df 93       	push	r29
    2d4a:	cf 93       	push	r28
    2d4c:	cd b7       	in	r28, 0x3d	; 61
    2d4e:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2d50:	81 e0       	ldi	r24, 0x01	; 1
    2d52:	80 93 25 03 	sts	0x0325, r24
}
    2d56:	cf 91       	pop	r28
    2d58:	df 91       	pop	r29
    2d5a:	08 95       	ret

00002d5c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2d5c:	df 93       	push	r29
    2d5e:	cf 93       	push	r28
    2d60:	00 d0       	rcall	.+0      	; 0x2d62 <prvIdleTask+0x6>
    2d62:	cd b7       	in	r28, 0x3d	; 61
    2d64:	de b7       	in	r29, 0x3e	; 62
    2d66:	9a 83       	std	Y+2, r25	; 0x02
    2d68:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2d6a:	0e 94 57 17 	call	0x2eae	; 0x2eae <prvCheckTasksWaitingTermination>
    2d6e:	fd cf       	rjmp	.-6      	; 0x2d6a <prvIdleTask+0xe>

00002d70 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2d70:	0f 93       	push	r16
    2d72:	1f 93       	push	r17
    2d74:	df 93       	push	r29
    2d76:	cf 93       	push	r28
    2d78:	cd b7       	in	r28, 0x3d	; 61
    2d7a:	de b7       	in	r29, 0x3e	; 62
    2d7c:	29 97       	sbiw	r28, 0x09	; 9
    2d7e:	0f b6       	in	r0, 0x3f	; 63
    2d80:	f8 94       	cli
    2d82:	de bf       	out	0x3e, r29	; 62
    2d84:	0f be       	out	0x3f, r0	; 63
    2d86:	cd bf       	out	0x3d, r28	; 61
    2d88:	9a 83       	std	Y+2, r25	; 0x02
    2d8a:	89 83       	std	Y+1, r24	; 0x01
    2d8c:	7c 83       	std	Y+4, r23	; 0x04
    2d8e:	6b 83       	std	Y+3, r22	; 0x03
    2d90:	4d 83       	std	Y+5, r20	; 0x05
    2d92:	3f 83       	std	Y+7, r19	; 0x07
    2d94:	2e 83       	std	Y+6, r18	; 0x06
    2d96:	19 87       	std	Y+9, r17	; 0x09
    2d98:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2d9a:	89 81       	ldd	r24, Y+1	; 0x01
    2d9c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d9e:	4d 96       	adiw	r24, 0x1d	; 29
    2da0:	2b 81       	ldd	r18, Y+3	; 0x03
    2da2:	3c 81       	ldd	r19, Y+4	; 0x04
    2da4:	b9 01       	movw	r22, r18
    2da6:	40 e1       	ldi	r20, 0x10	; 16
    2da8:	50 e0       	ldi	r21, 0x00	; 0
    2daa:	0e 94 73 18 	call	0x30e6	; 0x30e6 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2dae:	e9 81       	ldd	r30, Y+1	; 0x01
    2db0:	fa 81       	ldd	r31, Y+2	; 0x02
    2db2:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2db4:	8d 81       	ldd	r24, Y+5	; 0x05
    2db6:	8f 30       	cpi	r24, 0x0F	; 15
    2db8:	10 f0       	brcs	.+4      	; 0x2dbe <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2dba:	8e e0       	ldi	r24, 0x0E	; 14
    2dbc:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2dbe:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc0:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc2:	8d 81       	ldd	r24, Y+5	; 0x05
    2dc4:	82 8f       	std	Z+26, r24	; 0x1a
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2dc6:	89 81       	ldd	r24, Y+1	; 0x01
    2dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    2dca:	02 96       	adiw	r24, 0x02	; 2
    2dcc:	0e 94 53 07 	call	0xea6	; 0xea6 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2dd0:	89 81       	ldd	r24, Y+1	; 0x01
    2dd2:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd4:	0e 96       	adiw	r24, 0x0e	; 14
    2dd6:	0e 94 53 07 	call	0xea6	; 0xea6 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2dda:	e9 81       	ldd	r30, Y+1	; 0x01
    2ddc:	fa 81       	ldd	r31, Y+2	; 0x02
    2dde:	89 81       	ldd	r24, Y+1	; 0x01
    2de0:	9a 81       	ldd	r25, Y+2	; 0x02
    2de2:	93 87       	std	Z+11, r25	; 0x0b
    2de4:	82 87       	std	Z+10, r24	; 0x0a

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2de6:	8d 81       	ldd	r24, Y+5	; 0x05
    2de8:	28 2f       	mov	r18, r24
    2dea:	30 e0       	ldi	r19, 0x00	; 0
    2dec:	40 e0       	ldi	r20, 0x00	; 0
    2dee:	50 e0       	ldi	r21, 0x00	; 0
    2df0:	8f e0       	ldi	r24, 0x0F	; 15
    2df2:	90 e0       	ldi	r25, 0x00	; 0
    2df4:	a0 e0       	ldi	r26, 0x00	; 0
    2df6:	b0 e0       	ldi	r27, 0x00	; 0
    2df8:	82 1b       	sub	r24, r18
    2dfa:	93 0b       	sbc	r25, r19
    2dfc:	a4 0b       	sbc	r26, r20
    2dfe:	b5 0b       	sbc	r27, r21
    2e00:	e9 81       	ldd	r30, Y+1	; 0x01
    2e02:	fa 81       	ldd	r31, Y+2	; 0x02
    2e04:	86 87       	std	Z+14, r24	; 0x0e
    2e06:	97 87       	std	Z+15, r25	; 0x0f
    2e08:	a0 8b       	std	Z+16, r26	; 0x10
    2e0a:	b1 8b       	std	Z+17, r27	; 0x11
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    2e10:	89 81       	ldd	r24, Y+1	; 0x01
    2e12:	9a 81       	ldd	r25, Y+2	; 0x02
    2e14:	97 8b       	std	Z+23, r25	; 0x17
    2e16:	86 8b       	std	Z+22, r24	; 0x16
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2e18:	29 96       	adiw	r28, 0x09	; 9
    2e1a:	0f b6       	in	r0, 0x3f	; 63
    2e1c:	f8 94       	cli
    2e1e:	de bf       	out	0x3e, r29	; 62
    2e20:	0f be       	out	0x3f, r0	; 63
    2e22:	cd bf       	out	0x3d, r28	; 61
    2e24:	cf 91       	pop	r28
    2e26:	df 91       	pop	r29
    2e28:	1f 91       	pop	r17
    2e2a:	0f 91       	pop	r16
    2e2c:	08 95       	ret

00002e2e <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2e2e:	df 93       	push	r29
    2e30:	cf 93       	push	r28
    2e32:	0f 92       	push	r0
    2e34:	cd b7       	in	r28, 0x3d	; 61
    2e36:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2e38:	19 82       	std	Y+1, r1	; 0x01
    2e3a:	16 c0       	rjmp	.+44     	; 0x2e68 <prvInitialiseTaskLists+0x3a>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2e3c:	89 81       	ldd	r24, Y+1	; 0x01
    2e3e:	48 2f       	mov	r20, r24
    2e40:	50 e0       	ldi	r21, 0x00	; 0
    2e42:	ca 01       	movw	r24, r20
    2e44:	88 0f       	add	r24, r24
    2e46:	99 1f       	adc	r25, r25
    2e48:	9c 01       	movw	r18, r24
    2e4a:	22 0f       	add	r18, r18
    2e4c:	33 1f       	adc	r19, r19
    2e4e:	22 0f       	add	r18, r18
    2e50:	33 1f       	adc	r19, r19
    2e52:	82 0f       	add	r24, r18
    2e54:	93 1f       	adc	r25, r19
    2e56:	84 0f       	add	r24, r20
    2e58:	95 1f       	adc	r25, r21
    2e5a:	88 5d       	subi	r24, 0xD8	; 216
    2e5c:	9c 4f       	sbci	r25, 0xFC	; 252
    2e5e:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2e62:	89 81       	ldd	r24, Y+1	; 0x01
    2e64:	8f 5f       	subi	r24, 0xFF	; 255
    2e66:	89 83       	std	Y+1, r24	; 0x01
    2e68:	89 81       	ldd	r24, Y+1	; 0x01
    2e6a:	8f 30       	cpi	r24, 0x0F	; 15
    2e6c:	38 f3       	brcs	.-50     	; 0x2e3c <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2e6e:	8d ec       	ldi	r24, 0xCD	; 205
    2e70:	93 e0       	ldi	r25, 0x03	; 3
    2e72:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2e76:	88 ed       	ldi	r24, 0xD8	; 216
    2e78:	93 e0       	ldi	r25, 0x03	; 3
    2e7a:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2e7e:	87 ee       	ldi	r24, 0xE7	; 231
    2e80:	93 e0       	ldi	r25, 0x03	; 3
    2e82:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2e86:	82 ef       	ldi	r24, 0xF2	; 242
    2e88:	93 e0       	ldi	r25, 0x03	; 3
    2e8a:	0e 94 25 07 	call	0xe4a	; 0xe4a <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2e8e:	8d ec       	ldi	r24, 0xCD	; 205
    2e90:	93 e0       	ldi	r25, 0x03	; 3
    2e92:	90 93 e4 03 	sts	0x03E4, r25
    2e96:	80 93 e3 03 	sts	0x03E3, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2e9a:	88 ed       	ldi	r24, 0xD8	; 216
    2e9c:	93 e0       	ldi	r25, 0x03	; 3
    2e9e:	90 93 e6 03 	sts	0x03E6, r25
    2ea2:	80 93 e5 03 	sts	0x03E5, r24
}
    2ea6:	0f 90       	pop	r0
    2ea8:	cf 91       	pop	r28
    2eaa:	df 91       	pop	r29
    2eac:	08 95       	ret

00002eae <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2eae:	df 93       	push	r29
    2eb0:	cf 93       	push	r28
    2eb2:	00 d0       	rcall	.+0      	; 0x2eb4 <prvCheckTasksWaitingTermination+0x6>
    2eb4:	0f 92       	push	r0
    2eb6:	cd b7       	in	r28, 0x3d	; 61
    2eb8:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2eba:	80 91 1a 03 	lds	r24, 0x031A
    2ebe:	88 23       	and	r24, r24
    2ec0:	71 f1       	breq	.+92     	; 0x2f1e <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2ec2:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2ec6:	80 91 f2 03 	lds	r24, 0x03F2
    2eca:	1b 82       	std	Y+3, r1	; 0x03
    2ecc:	88 23       	and	r24, r24
    2ece:	11 f4       	brne	.+4      	; 0x2ed4 <prvCheckTasksWaitingTermination+0x26>
    2ed0:	81 e0       	ldi	r24, 0x01	; 1
    2ed2:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2ed4:	0e 94 de 12 	call	0x25bc	; 0x25bc <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eda:	88 23       	and	r24, r24
    2edc:	01 f5       	brne	.+64     	; 0x2f1e <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2ede:	0f b6       	in	r0, 0x3f	; 63
    2ee0:	f8 94       	cli
    2ee2:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2ee4:	e0 91 f9 03 	lds	r30, 0x03F9
    2ee8:	f0 91 fa 03 	lds	r31, 0x03FA
    2eec:	80 85       	ldd	r24, Z+8	; 0x08
    2eee:	91 85       	ldd	r25, Z+9	; 0x09
    2ef0:	9a 83       	std	Y+2, r25	; 0x02
    2ef2:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2ef4:	89 81       	ldd	r24, Y+1	; 0x01
    2ef6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ef8:	02 96       	adiw	r24, 0x02	; 2
    2efa:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListRemove>
					--uxCurrentNumberOfTasks;
    2efe:	80 91 1b 03 	lds	r24, 0x031B
    2f02:	81 50       	subi	r24, 0x01	; 1
    2f04:	80 93 1b 03 	sts	0x031B, r24
					--uxTasksDeleted;
    2f08:	80 91 1a 03 	lds	r24, 0x031A
    2f0c:	81 50       	subi	r24, 0x01	; 1
    2f0e:	80 93 1a 03 	sts	0x031A, r24
				}
				taskEXIT_CRITICAL();
    2f12:	0f 90       	pop	r0
    2f14:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2f16:	89 81       	ldd	r24, Y+1	; 0x01
    2f18:	9a 81       	ldd	r25, Y+2	; 0x02
    2f1a:	0e 94 4d 18 	call	0x309a	; 0x309a <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2f1e:	0f 90       	pop	r0
    2f20:	0f 90       	pop	r0
    2f22:	0f 90       	pop	r0
    2f24:	cf 91       	pop	r28
    2f26:	df 91       	pop	r29
    2f28:	08 95       	ret

00002f2a <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2f2a:	df 93       	push	r29
    2f2c:	cf 93       	push	r28
    2f2e:	00 d0       	rcall	.+0      	; 0x2f30 <prvAddCurrentTaskToDelayedList+0x6>
    2f30:	00 d0       	rcall	.+0      	; 0x2f32 <prvAddCurrentTaskToDelayedList+0x8>
    2f32:	cd b7       	in	r28, 0x3d	; 61
    2f34:	de b7       	in	r29, 0x3e	; 62
    2f36:	69 83       	std	Y+1, r22	; 0x01
    2f38:	7a 83       	std	Y+2, r23	; 0x02
    2f3a:	8b 83       	std	Y+3, r24	; 0x03
    2f3c:	9c 83       	std	Y+4, r25	; 0x04
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2f3e:	e0 91 18 03 	lds	r30, 0x0318
    2f42:	f0 91 19 03 	lds	r31, 0x0319
    2f46:	89 81       	ldd	r24, Y+1	; 0x01
    2f48:	9a 81       	ldd	r25, Y+2	; 0x02
    2f4a:	ab 81       	ldd	r26, Y+3	; 0x03
    2f4c:	bc 81       	ldd	r27, Y+4	; 0x04
    2f4e:	82 83       	std	Z+2, r24	; 0x02
    2f50:	93 83       	std	Z+3, r25	; 0x03
    2f52:	a4 83       	std	Z+4, r26	; 0x04
    2f54:	b5 83       	std	Z+5, r27	; 0x05

	if( xTimeToWake < xTickCount )
    2f56:	20 91 1c 03 	lds	r18, 0x031C
    2f5a:	30 91 1d 03 	lds	r19, 0x031D
    2f5e:	40 91 1e 03 	lds	r20, 0x031E
    2f62:	50 91 1f 03 	lds	r21, 0x031F
    2f66:	89 81       	ldd	r24, Y+1	; 0x01
    2f68:	9a 81       	ldd	r25, Y+2	; 0x02
    2f6a:	ab 81       	ldd	r26, Y+3	; 0x03
    2f6c:	bc 81       	ldd	r27, Y+4	; 0x04
    2f6e:	82 17       	cp	r24, r18
    2f70:	93 07       	cpc	r25, r19
    2f72:	a4 07       	cpc	r26, r20
    2f74:	b5 07       	cpc	r27, r21
    2f76:	70 f4       	brcc	.+28     	; 0x2f94 <prvAddCurrentTaskToDelayedList+0x6a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2f78:	80 91 e5 03 	lds	r24, 0x03E5
    2f7c:	90 91 e6 03 	lds	r25, 0x03E6
    2f80:	20 91 18 03 	lds	r18, 0x0318
    2f84:	30 91 19 03 	lds	r19, 0x0319
    2f88:	2e 5f       	subi	r18, 0xFE	; 254
    2f8a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f8c:	b9 01       	movw	r22, r18
    2f8e:	0e 94 af 07 	call	0xf5e	; 0xf5e <vListInsert>
    2f92:	2c c0       	rjmp	.+88     	; 0x2fec <prvAddCurrentTaskToDelayedList+0xc2>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2f94:	40 91 e3 03 	lds	r20, 0x03E3
    2f98:	50 91 e4 03 	lds	r21, 0x03E4
    2f9c:	80 91 18 03 	lds	r24, 0x0318
    2fa0:	90 91 19 03 	lds	r25, 0x0319
    2fa4:	9c 01       	movw	r18, r24
    2fa6:	2e 5f       	subi	r18, 0xFE	; 254
    2fa8:	3f 4f       	sbci	r19, 0xFF	; 255
    2faa:	ca 01       	movw	r24, r20
    2fac:	b9 01       	movw	r22, r18
    2fae:	0e 94 af 07 	call	0xf5e	; 0xf5e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2fb2:	20 91 6f 00 	lds	r18, 0x006F
    2fb6:	30 91 70 00 	lds	r19, 0x0070
    2fba:	40 91 71 00 	lds	r20, 0x0071
    2fbe:	50 91 72 00 	lds	r21, 0x0072
    2fc2:	89 81       	ldd	r24, Y+1	; 0x01
    2fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc6:	ab 81       	ldd	r26, Y+3	; 0x03
    2fc8:	bc 81       	ldd	r27, Y+4	; 0x04
    2fca:	82 17       	cp	r24, r18
    2fcc:	93 07       	cpc	r25, r19
    2fce:	a4 07       	cpc	r26, r20
    2fd0:	b5 07       	cpc	r27, r21
    2fd2:	60 f4       	brcc	.+24     	; 0x2fec <prvAddCurrentTaskToDelayedList+0xc2>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2fd4:	89 81       	ldd	r24, Y+1	; 0x01
    2fd6:	9a 81       	ldd	r25, Y+2	; 0x02
    2fd8:	ab 81       	ldd	r26, Y+3	; 0x03
    2fda:	bc 81       	ldd	r27, Y+4	; 0x04
    2fdc:	80 93 6f 00 	sts	0x006F, r24
    2fe0:	90 93 70 00 	sts	0x0070, r25
    2fe4:	a0 93 71 00 	sts	0x0071, r26
    2fe8:	b0 93 72 00 	sts	0x0072, r27
		}
	}
}
    2fec:	0f 90       	pop	r0
    2fee:	0f 90       	pop	r0
    2ff0:	0f 90       	pop	r0
    2ff2:	0f 90       	pop	r0
    2ff4:	cf 91       	pop	r28
    2ff6:	df 91       	pop	r29
    2ff8:	08 95       	ret

00002ffa <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2ffa:	df 93       	push	r29
    2ffc:	cf 93       	push	r28
    2ffe:	cd b7       	in	r28, 0x3d	; 61
    3000:	de b7       	in	r29, 0x3e	; 62
    3002:	28 97       	sbiw	r28, 0x08	; 8
    3004:	0f b6       	in	r0, 0x3f	; 63
    3006:	f8 94       	cli
    3008:	de bf       	out	0x3e, r29	; 62
    300a:	0f be       	out	0x3f, r0	; 63
    300c:	cd bf       	out	0x3d, r28	; 61
    300e:	9c 83       	std	Y+4, r25	; 0x04
    3010:	8b 83       	std	Y+3, r24	; 0x03
    3012:	7e 83       	std	Y+6, r23	; 0x06
    3014:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    3016:	8d e2       	ldi	r24, 0x2D	; 45
    3018:	90 e0       	ldi	r25, 0x00	; 0
    301a:	0e 94 b9 06 	call	0xd72	; 0xd72 <pvPortMalloc>
    301e:	9a 83       	std	Y+2, r25	; 0x02
    3020:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    3022:	89 81       	ldd	r24, Y+1	; 0x01
    3024:	9a 81       	ldd	r25, Y+2	; 0x02
    3026:	00 97       	sbiw	r24, 0x00	; 0
    3028:	69 f1       	breq	.+90     	; 0x3084 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    302a:	8d 81       	ldd	r24, Y+5	; 0x05
    302c:	9e 81       	ldd	r25, Y+6	; 0x06
    302e:	00 97       	sbiw	r24, 0x00	; 0
    3030:	39 f4       	brne	.+14     	; 0x3040 <prvAllocateTCBAndStack+0x46>
    3032:	8b 81       	ldd	r24, Y+3	; 0x03
    3034:	9c 81       	ldd	r25, Y+4	; 0x04
    3036:	0e 94 b9 06 	call	0xd72	; 0xd72 <pvPortMalloc>
    303a:	98 87       	std	Y+8, r25	; 0x08
    303c:	8f 83       	std	Y+7, r24	; 0x07
    303e:	04 c0       	rjmp	.+8      	; 0x3048 <prvAllocateTCBAndStack+0x4e>
    3040:	8d 81       	ldd	r24, Y+5	; 0x05
    3042:	9e 81       	ldd	r25, Y+6	; 0x06
    3044:	98 87       	std	Y+8, r25	; 0x08
    3046:	8f 83       	std	Y+7, r24	; 0x07
    3048:	e9 81       	ldd	r30, Y+1	; 0x01
    304a:	fa 81       	ldd	r31, Y+2	; 0x02
    304c:	8f 81       	ldd	r24, Y+7	; 0x07
    304e:	98 85       	ldd	r25, Y+8	; 0x08
    3050:	94 8f       	std	Z+28, r25	; 0x1c
    3052:	83 8f       	std	Z+27, r24	; 0x1b

		if( pxNewTCB->pxStack == NULL )
    3054:	e9 81       	ldd	r30, Y+1	; 0x01
    3056:	fa 81       	ldd	r31, Y+2	; 0x02
    3058:	83 8d       	ldd	r24, Z+27	; 0x1b
    305a:	94 8d       	ldd	r25, Z+28	; 0x1c
    305c:	00 97       	sbiw	r24, 0x00	; 0
    305e:	39 f4       	brne	.+14     	; 0x306e <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    3060:	89 81       	ldd	r24, Y+1	; 0x01
    3062:	9a 81       	ldd	r25, Y+2	; 0x02
    3064:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortFree>
			pxNewTCB = NULL;
    3068:	1a 82       	std	Y+2, r1	; 0x02
    306a:	19 82       	std	Y+1, r1	; 0x01
    306c:	0b c0       	rjmp	.+22     	; 0x3084 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    306e:	e9 81       	ldd	r30, Y+1	; 0x01
    3070:	fa 81       	ldd	r31, Y+2	; 0x02
    3072:	83 8d       	ldd	r24, Z+27	; 0x1b
    3074:	94 8d       	ldd	r25, Z+28	; 0x1c
    3076:	2b 81       	ldd	r18, Y+3	; 0x03
    3078:	3c 81       	ldd	r19, Y+4	; 0x04
    307a:	65 ea       	ldi	r22, 0xA5	; 165
    307c:	70 e0       	ldi	r23, 0x00	; 0
    307e:	a9 01       	movw	r20, r18
    3080:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <memset>
		}
	}

	return pxNewTCB;
    3084:	89 81       	ldd	r24, Y+1	; 0x01
    3086:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3088:	28 96       	adiw	r28, 0x08	; 8
    308a:	0f b6       	in	r0, 0x3f	; 63
    308c:	f8 94       	cli
    308e:	de bf       	out	0x3e, r29	; 62
    3090:	0f be       	out	0x3f, r0	; 63
    3092:	cd bf       	out	0x3d, r28	; 61
    3094:	cf 91       	pop	r28
    3096:	df 91       	pop	r29
    3098:	08 95       	ret

0000309a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    309a:	df 93       	push	r29
    309c:	cf 93       	push	r28
    309e:	00 d0       	rcall	.+0      	; 0x30a0 <prvDeleteTCB+0x6>
    30a0:	cd b7       	in	r28, 0x3d	; 61
    30a2:	de b7       	in	r29, 0x3e	; 62
    30a4:	9a 83       	std	Y+2, r25	; 0x02
    30a6:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    30a8:	e9 81       	ldd	r30, Y+1	; 0x01
    30aa:	fa 81       	ldd	r31, Y+2	; 0x02
    30ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    30ae:	94 8d       	ldd	r25, Z+28	; 0x1c
    30b0:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortFree>
		vPortFree( pxTCB );
    30b4:	89 81       	ldd	r24, Y+1	; 0x01
    30b6:	9a 81       	ldd	r25, Y+2	; 0x02
    30b8:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortFree>
	}
    30bc:	0f 90       	pop	r0
    30be:	0f 90       	pop	r0
    30c0:	cf 91       	pop	r28
    30c2:	df 91       	pop	r29
    30c4:	08 95       	ret

000030c6 <memcpy>:
    30c6:	fb 01       	movw	r30, r22
    30c8:	dc 01       	movw	r26, r24
    30ca:	02 c0       	rjmp	.+4      	; 0x30d0 <memcpy+0xa>
    30cc:	01 90       	ld	r0, Z+
    30ce:	0d 92       	st	X+, r0
    30d0:	41 50       	subi	r20, 0x01	; 1
    30d2:	50 40       	sbci	r21, 0x00	; 0
    30d4:	d8 f7       	brcc	.-10     	; 0x30cc <memcpy+0x6>
    30d6:	08 95       	ret

000030d8 <memset>:
    30d8:	dc 01       	movw	r26, r24
    30da:	01 c0       	rjmp	.+2      	; 0x30de <memset+0x6>
    30dc:	6d 93       	st	X+, r22
    30de:	41 50       	subi	r20, 0x01	; 1
    30e0:	50 40       	sbci	r21, 0x00	; 0
    30e2:	e0 f7       	brcc	.-8      	; 0x30dc <memset+0x4>
    30e4:	08 95       	ret

000030e6 <strncpy>:
    30e6:	fb 01       	movw	r30, r22
    30e8:	dc 01       	movw	r26, r24
    30ea:	41 50       	subi	r20, 0x01	; 1
    30ec:	50 40       	sbci	r21, 0x00	; 0
    30ee:	48 f0       	brcs	.+18     	; 0x3102 <strncpy+0x1c>
    30f0:	01 90       	ld	r0, Z+
    30f2:	0d 92       	st	X+, r0
    30f4:	00 20       	and	r0, r0
    30f6:	c9 f7       	brne	.-14     	; 0x30ea <strncpy+0x4>
    30f8:	01 c0       	rjmp	.+2      	; 0x30fc <strncpy+0x16>
    30fa:	1d 92       	st	X+, r1
    30fc:	41 50       	subi	r20, 0x01	; 1
    30fe:	50 40       	sbci	r21, 0x00	; 0
    3100:	e0 f7       	brcc	.-8      	; 0x30fa <strncpy+0x14>
    3102:	08 95       	ret

00003104 <_exit>:
    3104:	f8 94       	cli

00003106 <__stop_program>:
    3106:	ff cf       	rjmp	.-2      	; 0x3106 <__stop_program>
